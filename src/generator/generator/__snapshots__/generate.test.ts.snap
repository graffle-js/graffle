// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`custom scalars module results in client prefilling those custom scalars 1`] = `
"import type * as $$Utilities from "graffle/utilities-for-generated";

import * as CustomScalars from "../../scalars.js";

export * from "../../scalars.js";
export { Date } from "../../scalars.js";
//
//
//
//
// CUSTOM SCALAR TYPE
// DATE
// --------------------------------------------------------------------------------------------------
//                                                Date
// --------------------------------------------------------------------------------------------------
//
//

export type Date = typeof CustomScalars.Date;
// Without this we get error:
// "Exported type alias 'DateDecoded' has or is using private name 'Date'."
type Date_ = typeof CustomScalars.Date;
export type DateDecoded = $$Utilities.Schema.Scalar.GetDecoded<Date_>;
export type DateEncoded = $$Utilities.Schema.Scalar.GetEncoded<Date_>;

export * from "graffle/generator-helpers/standard-scalar-types";

//
//
//
//
//
//
// ==================================================================================================
//                                              Registry
// ==================================================================================================
//
//
//
//
//
//

export const $registry = {
  map: {
    Date: Date,
  },
} as $Registry;

export type $Registry = $$Utilities.Schema.Scalar.Registry<
  {
    Date: Date_;
  },
  $$Utilities.Schema.Scalar.GetEncoded<Date_>,
  $$Utilities.Schema.Scalar.GetDecoded<Date_>
>;
"
`;

exports[`kitchen-sink generated modules > _.ts 1`] = `
"// We import the global module for good measure although it is not clear it is always needed.
// It at least helps with Twoslash wherein without this import here Twoslash will not include the global module.
// In real TypeScript projects it seems the global module is included automatically. But there could be certain tsconfig
// setups where this still indeed does help.
import './modules/global.js'

export { create } from './modules/client.js'
export { schemaDrivenDataMap as schemaMap } from './modules/schema-driven-data-map.js'
export { Select } from './modules/select.js'
export * as SelectionSets from './modules/selection-sets.js'
"
`;

exports[`kitchen-sink generated modules > __.ts 1`] = `
"export * as Graffle from './_.js'
export { schemaDrivenDataMap as schemaMap } from './modules/schema-driven-data-map.js'
"
`;

exports[`kitchen-sink generated modules > modules/client.ts 1`] = `
"import { TransportHttp } from '../../../../../../src/entrypoints/extensions/transport-http/runtime.js'
import * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$Data from './data.js'
import * as $$Scalar from './scalar.js'
import * as $$SchemaDrivenDataMap from './schema-driven-data-map.js'

const context = $$Utilities.useReducer(
  {
    ...$$Utilities.Context.States.contextEmpty,
    name: $$Data.Name,
    schemaMap: $$SchemaDrivenDataMap.schemaDrivenDataMap,
    scalars: $$Scalar.$registry,
  },
  TransportHttp({
    url: $$Data.defaultSchemaUrl,
  }),
)

export const create = $$Utilities.createConstructorWithContext(
  context,
)
"
`;

exports[`kitchen-sink generated modules > modules/data.ts 1`] = `
"export const Name = \`default\`
export type Name = 'default'

export const defaultSchemaUrl = undefined
"
`;

exports[`kitchen-sink generated modules > modules/global.ts 1`] = `
"import * as $$Data from './data.js'
import * as $$MethodsDocument from './methods-document.js'
import * as $$MethodsRoot from './methods-root.js'
import * as $$MethodsSelect from './methods-select.js'
import * as $$Schema from './schema.js'

declare global {
  export namespace GraffleGlobal {
    export interface Clients {
      default: {
        name: $$Data.Name
        schema: $$Schema.Schema
        interfaces: {
          MethodsSelect: $$MethodsSelect.$MethodsSelect
          Document: $$MethodsDocument.BuilderMethodsDocumentFn
          Root: $$MethodsRoot.BuilderMethodsRootFn
        }
        defaultSchemaUrl: null
      }
    }
  }
}
"
`;

exports[`kitchen-sink generated modules > modules/methods-document.ts 1`] = `
"import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$Schema from './schema.js'
import * as $$SelectionSets from './selection-sets.js'

export interface Document<$Context extends $$Utilities.Context> {
  <$Document>(
    document: $$Utilities.ExactNonEmpty<$Document, $$SelectionSets.$Document<$Context['scalars']>>,
  ): $$Utilities.DocumentRunner<
    $Context,
    $$Schema.Schema,
    // @ts-expect-error We use Exact instead of constraint on this function. TypeScript does not see that as
    // Satisfying the constraint on the DocumentRunner type.
    $Document
  >
}

export interface BuilderMethodsDocumentFn extends $$Utilities.TypeFunction {
  // @ts-expect-error parameter is Untyped.
  return: Document<this['params']>
}
"
`;

exports[`kitchen-sink generated modules > modules/methods-root.ts 1`] = `
"import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$Schema from './schema.js'
import * as $$SelectionSets from './selection-sets.js'

export interface QueryMethods<$Context extends $$Utilities.Context> {
  $batch: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutput<
      $Context,
      InferResult.OperationQuery<$$Utilities.AssertExtendsObject<$SelectionSet>, $$Schema.Schema<$Context['scalars']>>
    >
  >
  __typename: () => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      { __typename: 'Query' },
      '__typename'
    >
  >

  InputObjectNested: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.InputObjectNested<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ InputObjectNested: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'InputObjectNested'
    >
  >

  InputObjectNestedNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.InputObjectNestedNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ InputObjectNestedNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'InputObjectNestedNonNull'
    >
  >
  /**
   * Query enum field documentation.
   */
  abcEnum: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.abcEnum<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ abcEnum: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'abcEnum'
    >
  >

  argInputObjectCircular: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.argInputObjectCircular<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ argInputObjectCircular: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'argInputObjectCircular'
    >
  >

  date: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.date<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ date: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'date'
    >
  >

  dateArg: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateArg<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArg: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArg'
    >
  >

  dateArgInputObject: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateArgInputObject<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArgInputObject: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArgInputObject'
    >
  >

  dateArgList: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateArgList<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArgList: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArgList'
    >
  >

  dateArgNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateArgNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArgNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArgNonNull'
    >
  >

  dateArgNonNullList: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateArgNonNullList<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArgNonNullList: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArgNonNullList'
    >
  >

  dateArgNonNullListNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.dateArgNonNullListNonNull<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateArgNonNullListNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateArgNonNullListNonNull'
    >
  >

  dateInterface1: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateInterface1<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateInterface1: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateInterface1'
    >
  >

  dateList: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateList<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateList: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateList'
    >
  >

  dateListList: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateListList<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateListList: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateListList'
    >
  >

  dateListNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateListNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateListNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateListNonNull'
    >
  >

  dateNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateNonNull'
    >
  >

  dateObject1: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateObject1<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateObject1: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateObject1'
    >
  >

  dateUnion: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.dateUnion<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ dateUnion: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'dateUnion'
    >
  >

  error: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.error<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ error: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'error'
    >
  >

  id: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.id<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ id: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'id'
    >
  >

  idNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.idNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ idNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'idNonNull'
    >
  >

  interface: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.$interface<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interface: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interface'
    >
  >

  interfaceHierarchyChildA: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.interfaceHierarchyChildA<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interfaceHierarchyChildA: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interfaceHierarchyChildA'
    >
  >

  interfaceHierarchyChildB: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.interfaceHierarchyChildB<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interfaceHierarchyChildB: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interfaceHierarchyChildB'
    >
  >

  interfaceHierarchyGrandparents: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.interfaceHierarchyGrandparents<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<
        { interfaceHierarchyGrandparents: $SelectionSet },
        $$Schema.Schema<$Context['scalars']>
      >,
      'interfaceHierarchyGrandparents'
    >
  >

  interfaceHierarchyParents: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.interfaceHierarchyParents<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interfaceHierarchyParents: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interfaceHierarchyParents'
    >
  >

  interfaceNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.interfaceNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interfaceNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interfaceNonNull'
    >
  >

  interfaceWithArgs: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.interfaceWithArgs<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ interfaceWithArgs: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'interfaceWithArgs'
    >
  >

  listInt: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.listInt<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ listInt: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'listInt'
    >
  >

  listIntNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.listIntNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ listIntNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'listIntNonNull'
    >
  >

  listListInt: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.listListInt<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ listListInt: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'listListInt'
    >
  >

  listListIntNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.listListIntNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ listListIntNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'listListIntNonNull'
    >
  >

  lowerCaseUnion: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.lowerCaseUnion<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ lowerCaseUnion: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'lowerCaseUnion'
    >
  >

  object: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.$object<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ object: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'object'
    >
  >

  objectList: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.objectList<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ objectList: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'objectList'
    >
  >

  objectListNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.objectListNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ objectListNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'objectListNonNull'
    >
  >

  objectNested: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.objectNested<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ objectNested: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'objectNested'
    >
  >

  objectNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.objectNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ objectNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'objectNonNull'
    >
  >

  objectWithArgs: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.objectWithArgs<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ objectWithArgs: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'objectWithArgs'
    >
  >

  result: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.result<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ result: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'result'
    >
  >

  resultNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.resultNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ resultNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'resultNonNull'
    >
  >

  string: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.$string<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ string: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'string'
    >
  >

  stringWithArgEnum: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.stringWithArgEnum<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithArgEnum: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithArgEnum'
    >
  >

  stringWithArgInputObject: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.stringWithArgInputObject<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithArgInputObject: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithArgInputObject'
    >
  >

  stringWithArgInputObjectRequired: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.stringWithArgInputObjectRequired<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<
        { stringWithArgInputObjectRequired: $SelectionSet },
        $$Schema.Schema<$Context['scalars']>
      >,
      'stringWithArgInputObjectRequired'
    >
  >
  /**
   * The given arguments are reflected back as a JSON string.
   */
  stringWithArgs: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.stringWithArgs<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithArgs: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithArgs'
    >
  >

  stringWithListArg: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.stringWithListArg<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithListArg: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithListArg'
    >
  >

  stringWithListArgRequired: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.Query.stringWithListArgRequired<$Context['scalars']>
    >,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithListArgRequired: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithListArgRequired'
    >
  >

  stringWithRequiredArg: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.stringWithRequiredArg<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ stringWithRequiredArg: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'stringWithRequiredArg'
    >
  >

  unionFooBar: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.unionFooBar<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ unionFooBar: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'unionFooBar'
    >
  >

  unionFooBarNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.unionFooBarNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ unionFooBarNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'unionFooBarNonNull'
    >
  >

  unionFooBarWithArgs: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.unionFooBarWithArgs<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ unionFooBarWithArgs: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'unionFooBarWithArgs'
    >
  >

  unionObject: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.unionObject<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ unionObject: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'unionObject'
    >
  >

  unionObjectNonNull: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query.unionObjectNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationQuery<{ unionObjectNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'unionObjectNonNull'
    >
  >
}

export interface MutationMethods<$Context extends $$Utilities.Context> {
  $batch: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Mutation<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutput<
      $Context,
      InferResult.OperationMutation<
        $$Utilities.AssertExtendsObject<$SelectionSet>,
        $$Schema.Schema<$Context['scalars']>
      >
    >
  >
  __typename: () => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      { __typename: 'Mutation' },
      '__typename'
    >
  >

  id: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Mutation.id<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationMutation<{ id: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'id'
    >
  >

  idNonNull: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Mutation.idNonNull<$Context['scalars']>>,
  ) => Promise<
    & (null | {})
    & $$Utilities.HandleOutputGraffleRootField<
      $Context,
      InferResult.OperationMutation<{ idNonNull: $SelectionSet }, $$Schema.Schema<$Context['scalars']>>,
      'idNonNull'
    >
  >
}

export interface BuilderMethodsRoot<$Context extends $$Utilities.Context> {
  query: QueryMethods<$Context>
  mutation: MutationMethods<$Context>
}

export interface BuilderMethodsRootFn extends $$Utilities.TypeFunction {
  // @ts-expect-error parameter is Untyped.
  return: BuilderMethodsRoot<this['params']>
}
"
`;

exports[`kitchen-sink generated modules > modules/methods-select.ts 1`] = `
"import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$SelectionSets from './selection-sets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                      Select Methods Interface
// ==================================================================================================
//
//
//
//
//
//

export interface $MethodsSelect {
  Query: Query
  Mutation: Mutation
  Bar: Bar
  DateObject1: DateObject1
  DateObject2: DateObject2
  ErrorOne: ErrorOne
  ErrorTwo: ErrorTwo
  Foo: Foo
  Object1: Object1
  Object1ImplementingInterface: Object1ImplementingInterface
  Object2ImplementingInterface: Object2ImplementingInterface
  ObjectChildA: ObjectChildA
  ObjectChildB: ObjectChildB
  ObjectGrandparent: ObjectGrandparent
  ObjectNested: ObjectNested
  ObjectParent: ObjectParent
  ObjectUnion: ObjectUnion
  lowerCaseObject: lowerCaseObject
  lowerCaseObject2: lowerCaseObject2
  DateUnion: DateUnion
  FooBarUnion: FooBarUnion
  Result: Result
  lowerCaseUnion: lowerCaseUnion
  DateInterface1: DateInterface1
  Error: Error
  Interface: Interface
  InterfaceChildA: InterfaceChildA
  InterfaceChildB: InterfaceChildB
  InterfaceGrandparent: InterfaceGrandparent
  InterfaceParent: InterfaceParent
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

export interface Query {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Query>): $SelectionSet
}

export interface Mutation {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Mutation>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                            OutputObject
// ==================================================================================================
//
//
//
//
//
//

export interface Bar {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Bar>): $SelectionSet
}

export interface DateObject1 {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.DateObject1>): $SelectionSet
}

export interface DateObject2 {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.DateObject2>): $SelectionSet
}

export interface ErrorOne {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ErrorOne>): $SelectionSet
}

export interface ErrorTwo {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ErrorTwo>): $SelectionSet
}

export interface Foo {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Foo>): $SelectionSet
}

export interface Object1 {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Object1>): $SelectionSet
}

export interface Object1ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Object1ImplementingInterface>,
  ): $SelectionSet
}

export interface Object2ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Object2ImplementingInterface>,
  ): $SelectionSet
}

export interface ObjectChildA {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectChildA>): $SelectionSet
}

export interface ObjectChildB {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectChildB>): $SelectionSet
}

export interface ObjectGrandparent {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectGrandparent>): $SelectionSet
}

export interface ObjectNested {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectNested>): $SelectionSet
}

export interface ObjectParent {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectParent>): $SelectionSet
}

export interface ObjectUnion {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.ObjectUnion>): $SelectionSet
}

export interface lowerCaseObject {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.lowerCaseObject>): $SelectionSet
}

export interface lowerCaseObject2 {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.lowerCaseObject2>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

export interface DateUnion {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.DateUnion>): $SelectionSet
}

export interface FooBarUnion {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.FooBarUnion>): $SelectionSet
}

export interface Result {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Result>): $SelectionSet
}

export interface lowerCaseUnion {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.lowerCaseUnion>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

export interface DateInterface1 {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.DateInterface1>): $SelectionSet
}

export interface Error {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Error>): $SelectionSet
}

export interface Interface {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.Interface>): $SelectionSet
}

export interface InterfaceChildA {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.InterfaceChildA>): $SelectionSet
}

export interface InterfaceChildB {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.InterfaceChildB>): $SelectionSet
}

export interface InterfaceGrandparent {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.InterfaceGrandparent>): $SelectionSet
}

export interface InterfaceParent {
  <$SelectionSet>(selectionSet: $$Utilities.Exact<$SelectionSet, $$SelectionSets.InterfaceParent>): $SelectionSet
}
"
`;

exports[`kitchen-sink generated modules > modules/scalar.ts 1`] = `
"import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'

export * from '../../../../../../src/types/Schema/StandardTypes/scalar.js'

//
//
//
//
// CUSTOM SCALAR TYPE
// DATE
// --------------------------------------------------------------------------------------------------
//                                                Date
// --------------------------------------------------------------------------------------------------
//
//

export type Date = $$Utilities.Schema.Scalar.ScalarCodecless<'Date'>

//
//
//
//
//
//
// ==================================================================================================
//                                              Registry
// ==================================================================================================
//
//
//
//
//
//

export const $registry = {
  map: {},
} as $Registry

export type $Registry = $$Utilities.Schema.Scalar.Registry.Empty
"
`;

exports[`kitchen-sink generated modules > modules/schema.ts 1`] = `
"import type { Schema as $ } from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$Data from './data.js'
import * as $$Scalar from './scalar.js'

export namespace Schema {
  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Root
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                               Query
  // --------------------------------------------------------------------------------------------------
  //

  export interface Query extends $.OutputObject {
    name: 'Query'
    fields: {
      __typename: Query.__typename
      InputObjectNested: Query.InputObjectNested
      InputObjectNestedNonNull: Query.InputObjectNestedNonNull
      abcEnum: Query.abcEnum
      argInputObjectCircular: Query.argInputObjectCircular
      date: Query.date
      dateArg: Query.dateArg
      dateArgInputObject: Query.dateArgInputObject
      dateArgList: Query.dateArgList
      dateArgNonNull: Query.dateArgNonNull
      dateArgNonNullList: Query.dateArgNonNullList
      dateArgNonNullListNonNull: Query.dateArgNonNullListNonNull
      dateInterface1: Query.dateInterface1
      dateList: Query.dateList
      dateListList: Query.dateListList
      dateListNonNull: Query.dateListNonNull
      dateNonNull: Query.dateNonNull
      dateObject1: Query.dateObject1
      dateUnion: Query.dateUnion
      error: Query.error
      id: Query.id
      idNonNull: Query.idNonNull
      interface: Query.$interface
      interfaceHierarchyChildA: Query.interfaceHierarchyChildA
      interfaceHierarchyChildB: Query.interfaceHierarchyChildB
      interfaceHierarchyGrandparents: Query.interfaceHierarchyGrandparents
      interfaceHierarchyParents: Query.interfaceHierarchyParents
      interfaceNonNull: Query.interfaceNonNull
      interfaceWithArgs: Query.interfaceWithArgs
      listInt: Query.listInt
      listIntNonNull: Query.listIntNonNull
      listListInt: Query.listListInt
      listListIntNonNull: Query.listListIntNonNull
      lowerCaseUnion: Query.lowerCaseUnion
      object: Query.$object
      objectList: Query.objectList
      objectListNonNull: Query.objectListNonNull
      objectNested: Query.objectNested
      objectNonNull: Query.objectNonNull
      objectWithArgs: Query.objectWithArgs
      result: Query.result
      resultNonNull: Query.resultNonNull
      string: Query.$string
      stringWithArgEnum: Query.stringWithArgEnum
      stringWithArgInputObject: Query.stringWithArgInputObject
      stringWithArgInputObjectRequired: Query.stringWithArgInputObjectRequired
      stringWithArgs: Query.stringWithArgs
      stringWithListArg: Query.stringWithListArg
      stringWithListArgRequired: Query.stringWithListArgRequired
      stringWithRequiredArg: Query.stringWithRequiredArg
      unionFooBar: Query.unionFooBar
      unionFooBarNonNull: Query.unionFooBarNonNull
      unionFooBarWithArgs: Query.unionFooBarWithArgs
      unionObject: Query.unionObject
      unionObjectNonNull: Query.unionObjectNonNull
    }
  }

  export namespace Query {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Query'
      }
    }

    export interface InputObjectNested extends $.OutputField {
      name: 'InputObjectNested'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [0]
          namedType: $$NamedTypes.$$InputObjectNested
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface InputObjectNestedNonNull extends $.OutputField {
      name: 'InputObjectNestedNonNull'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [1]
          namedType: $$NamedTypes.$$InputObjectNestedNonNull
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    /**
     * Query enum field documentation.
     */
    export interface abcEnum extends $.OutputField {
      name: 'abcEnum'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ABCEnum
    }

    export interface argInputObjectCircular extends $.OutputField {
      name: 'argInputObjectCircular'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [0]
          namedType: $$NamedTypes.$$InputObjectCircular
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface date extends $.OutputField {
      name: 'date'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArg extends $.OutputField {
      name: 'dateArg'
      arguments: {
        date: {
          kind: 'InputField'
          name: 'date'
          inlineType: [0]
          namedType: $$NamedTypes.$$Date
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArgInputObject extends $.OutputField {
      name: 'dateArgInputObject'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [0]
          namedType: $$NamedTypes.$$InputObject
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArgList extends $.OutputField {
      name: 'dateArgList'
      arguments: {
        date: {
          kind: 'InputField'
          name: 'date'
          inlineType: [0, [1]]
          namedType: $$NamedTypes.$$Date
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArgNonNull extends $.OutputField {
      name: 'dateArgNonNull'
      arguments: {
        date: {
          kind: 'InputField'
          name: 'date'
          inlineType: [1]
          namedType: $$NamedTypes.$$Date
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArgNonNullList extends $.OutputField {
      name: 'dateArgNonNullList'
      arguments: {
        date: {
          kind: 'InputField'
          name: 'date'
          inlineType: [1, [0]]
          namedType: $$NamedTypes.$$Date
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateArgNonNullListNonNull extends $.OutputField {
      name: 'dateArgNonNullListNonNull'
      arguments: {
        date: {
          kind: 'InputField'
          name: 'date'
          inlineType: [1, [1]]
          namedType: $$NamedTypes.$$Date
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateInterface1 extends $.OutputField {
      name: 'dateInterface1'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$DateInterface1
    }

    export interface dateList extends $.OutputField {
      name: 'dateList'
      arguments: {}
      inlineType: [0, [1]]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateListList extends $.OutputField {
      name: 'dateListList'
      arguments: {}
      inlineType: [0, [1, [1]]]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateListNonNull extends $.OutputField {
      name: 'dateListNonNull'
      arguments: {}
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateNonNull extends $.OutputField {
      name: 'dateNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateObject1 extends $.OutputField {
      name: 'dateObject1'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$DateObject1
    }

    export interface dateUnion extends $.OutputField {
      name: 'dateUnion'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$DateUnion
    }

    export interface error extends $.OutputField {
      name: 'error'
      arguments: {
        case: {
          kind: 'InputField'
          name: 'case'
          inlineType: [0]
          namedType: $$NamedTypes.$$String
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface idNonNull extends $.OutputField {
      name: 'idNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$ID
    }

    export interface $interface extends $.OutputField {
      name: 'interface'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Interface
    }

    export interface interfaceHierarchyChildA extends $.OutputField {
      name: 'interfaceHierarchyChildA'
      arguments: {
        type: {
          kind: 'InputField'
          name: 'type'
          inlineType: [0]
          namedType: $$NamedTypes.$$ChildAInterfaceHierarchyMember
        }
      }
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$InterfaceChildA
    }

    export interface interfaceHierarchyChildB extends $.OutputField {
      name: 'interfaceHierarchyChildB'
      arguments: {
        type: {
          kind: 'InputField'
          name: 'type'
          inlineType: [0]
          namedType: $$NamedTypes.$$ChildBInterfaceHierarchyMember
        }
      }
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$InterfaceChildB
    }

    export interface interfaceHierarchyGrandparents extends $.OutputField {
      name: 'interfaceHierarchyGrandparents'
      arguments: {
        type: {
          kind: 'InputField'
          name: 'type'
          inlineType: [0]
          namedType: $$NamedTypes.$$GrandparentInterfaceHierarchyMember
        }
      }
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$InterfaceGrandparent
    }

    export interface interfaceHierarchyParents extends $.OutputField {
      name: 'interfaceHierarchyParents'
      arguments: {
        type: {
          kind: 'InputField'
          name: 'type'
          inlineType: [0]
          namedType: $$NamedTypes.$$ParentInterfaceHierarchyMember
        }
      }
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$InterfaceParent
    }

    export interface interfaceNonNull extends $.OutputField {
      name: 'interfaceNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$Interface
    }

    export interface interfaceWithArgs extends $.OutputField {
      name: 'interfaceWithArgs'
      arguments: {
        id: {
          kind: 'InputField'
          name: 'id'
          inlineType: [1]
          namedType: $$NamedTypes.$$ID
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Interface
    }

    export interface listInt extends $.OutputField {
      name: 'listInt'
      arguments: {}
      inlineType: [0, [0]]
      namedType: $$NamedTypes.$$Int
    }

    export interface listIntNonNull extends $.OutputField {
      name: 'listIntNonNull'
      arguments: {}
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$Int
    }

    export interface listListInt extends $.OutputField {
      name: 'listListInt'
      arguments: {}
      inlineType: [0, [0, [0]]]
      namedType: $$NamedTypes.$$Int
    }

    export interface listListIntNonNull extends $.OutputField {
      name: 'listListIntNonNull'
      arguments: {}
      inlineType: [1, [1, [1]]]
      namedType: $$NamedTypes.$$Int
    }

    export interface lowerCaseUnion extends $.OutputField {
      name: 'lowerCaseUnion'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$lowerCaseUnion
    }

    export interface $object extends $.OutputField {
      name: 'object'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Object1
    }

    export interface objectList extends $.OutputField {
      name: 'objectList'
      arguments: {}
      inlineType: [0, [1]]
      namedType: $$NamedTypes.$$Object1
    }

    export interface objectListNonNull extends $.OutputField {
      name: 'objectListNonNull'
      arguments: {}
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$Object1
    }

    export interface objectNested extends $.OutputField {
      name: 'objectNested'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ObjectNested
    }

    export interface objectNonNull extends $.OutputField {
      name: 'objectNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$Object1
    }

    export interface objectWithArgs extends $.OutputField {
      name: 'objectWithArgs'
      arguments: {
        boolean: {
          kind: 'InputField'
          name: 'boolean'
          inlineType: [0]
          namedType: $$NamedTypes.$$Boolean
        }
        float: {
          kind: 'InputField'
          name: 'float'
          inlineType: [0]
          namedType: $$NamedTypes.$$Float
        }
        id: {
          kind: 'InputField'
          name: 'id'
          inlineType: [0]
          namedType: $$NamedTypes.$$ID
        }
        int: {
          kind: 'InputField'
          name: 'int'
          inlineType: [0]
          namedType: $$NamedTypes.$$Int
        }
        string: {
          kind: 'InputField'
          name: 'string'
          inlineType: [0]
          namedType: $$NamedTypes.$$String
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Object1
    }

    export interface result extends $.OutputField {
      name: 'result'
      arguments: {
        case: {
          kind: 'InputField'
          name: 'case'
          inlineType: [1]
          namedType: $$NamedTypes.$$Case
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$Result
    }

    export interface resultNonNull extends $.OutputField {
      name: 'resultNonNull'
      arguments: {
        case: {
          kind: 'InputField'
          name: 'case'
          inlineType: [0]
          namedType: $$NamedTypes.$$Case
        }
      }
      inlineType: [1]
      namedType: $$NamedTypes.$$Result
    }

    export interface $string extends $.OutputField {
      name: 'string'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithArgEnum extends $.OutputField {
      name: 'stringWithArgEnum'
      arguments: {
        ABCEnum: {
          kind: 'InputField'
          name: 'ABCEnum'
          inlineType: [0]
          namedType: $$NamedTypes.$$ABCEnum
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithArgInputObject extends $.OutputField {
      name: 'stringWithArgInputObject'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [0]
          namedType: $$NamedTypes.$$InputObject
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithArgInputObjectRequired extends $.OutputField {
      name: 'stringWithArgInputObjectRequired'
      arguments: {
        input: {
          kind: 'InputField'
          name: 'input'
          inlineType: [1]
          namedType: $$NamedTypes.$$InputObject
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    /**
     * The given arguments are reflected back as a JSON string.
     */
    export interface stringWithArgs extends $.OutputField {
      name: 'stringWithArgs'
      arguments: {
        boolean: {
          kind: 'InputField'
          name: 'boolean'
          inlineType: [0]
          namedType: $$NamedTypes.$$Boolean
        }
        float: {
          kind: 'InputField'
          name: 'float'
          inlineType: [0]
          namedType: $$NamedTypes.$$Float
        }
        id: {
          kind: 'InputField'
          name: 'id'
          inlineType: [0]
          namedType: $$NamedTypes.$$ID
        }
        /**
         * @deprecated Example of argument deprecation reason here.
         */
        int: {
          kind: 'InputField'
          name: 'int'
          inlineType: [0]
          namedType: $$NamedTypes.$$Int
        }
        /**
         * Example of some argument documentation here.
         */
        string: {
          kind: 'InputField'
          name: 'string'
          inlineType: [0]
          namedType: $$NamedTypes.$$String
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithListArg extends $.OutputField {
      name: 'stringWithListArg'
      arguments: {
        ints: {
          kind: 'InputField'
          name: 'ints'
          inlineType: [0, [0]]
          namedType: $$NamedTypes.$$Int
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithListArgRequired extends $.OutputField {
      name: 'stringWithListArgRequired'
      arguments: {
        ints: {
          kind: 'InputField'
          name: 'ints'
          inlineType: [1, [1]]
          namedType: $$NamedTypes.$$Int
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface stringWithRequiredArg extends $.OutputField {
      name: 'stringWithRequiredArg'
      arguments: {
        string: {
          kind: 'InputField'
          name: 'string'
          inlineType: [1]
          namedType: $$NamedTypes.$$String
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }

    export interface unionFooBar extends $.OutputField {
      name: 'unionFooBar'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$FooBarUnion
    }

    export interface unionFooBarNonNull extends $.OutputField {
      name: 'unionFooBarNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$FooBarUnion
    }

    export interface unionFooBarWithArgs extends $.OutputField {
      name: 'unionFooBarWithArgs'
      arguments: {
        id: {
          kind: 'InputField'
          name: 'id'
          inlineType: [0]
          namedType: $$NamedTypes.$$ID
        }
      }
      inlineType: [0]
      namedType: $$NamedTypes.$$FooBarUnion
    }

    export interface unionObject extends $.OutputField {
      name: 'unionObject'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ObjectUnion
    }

    export interface unionObjectNonNull extends $.OutputField {
      name: 'unionObjectNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$ObjectUnion
    }
  }

  //                                              Mutation
  // --------------------------------------------------------------------------------------------------
  //

  export interface Mutation extends $.OutputObject {
    name: 'Mutation'
    fields: {
      __typename: Mutation.__typename
      id: Mutation.id
      idNonNull: Mutation.idNonNull
    }
  }

  export namespace Mutation {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Mutation'
      }
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface idNonNull extends $.OutputField {
      name: 'idNonNull'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$ID
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            OutputObject
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                                Bar
  // --------------------------------------------------------------------------------------------------
  //

  export interface Bar extends $.OutputObject {
    name: 'Bar'
    fields: {
      __typename: Bar.__typename
      int: Bar.int
    }
  }

  export namespace Bar {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Bar'
      }
    }

    export interface int extends $.OutputField {
      name: 'int'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Int
    }
  }

  //                                            DateObject1
  // --------------------------------------------------------------------------------------------------
  //

  export interface DateObject1 extends $.OutputObject {
    name: 'DateObject1'
    fields: {
      __typename: DateObject1.__typename
      date1: DateObject1.date1
    }
  }

  export namespace DateObject1 {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'DateObject1'
      }
    }

    export interface date1 extends $.OutputField {
      name: 'date1'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }
  }

  //                                            DateObject2
  // --------------------------------------------------------------------------------------------------
  //

  export interface DateObject2 extends $.OutputObject {
    name: 'DateObject2'
    fields: {
      __typename: DateObject2.__typename
      date2: DateObject2.date2
    }
  }

  export namespace DateObject2 {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'DateObject2'
      }
    }

    export interface date2 extends $.OutputField {
      name: 'date2'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }
  }

  //                                              ErrorOne
  // --------------------------------------------------------------------------------------------------
  //

  export interface ErrorOne extends $.OutputObject {
    name: 'ErrorOne'
    fields: {
      __typename: ErrorOne.__typename
      infoId: ErrorOne.infoId
      message: ErrorOne.message
    }
  }

  export namespace ErrorOne {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ErrorOne'
      }
    }

    export interface infoId extends $.OutputField {
      name: 'infoId'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface message extends $.OutputField {
      name: 'message'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                              ErrorTwo
  // --------------------------------------------------------------------------------------------------
  //

  export interface ErrorTwo extends $.OutputObject {
    name: 'ErrorTwo'
    fields: {
      __typename: ErrorTwo.__typename
      infoInt: ErrorTwo.infoInt
      message: ErrorTwo.message
    }
  }

  export namespace ErrorTwo {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ErrorTwo'
      }
    }

    export interface infoInt extends $.OutputField {
      name: 'infoInt'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Int
    }

    export interface message extends $.OutputField {
      name: 'message'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                                Foo
  // --------------------------------------------------------------------------------------------------
  //

  /**
   * Object documentation.
   */
  export interface Foo extends $.OutputObject {
    name: 'Foo'
    fields: {
      __typename: Foo.__typename
      id: Foo.id
    }
  }

  export namespace Foo {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Foo'
      }
    }

    /**
     * Field documentation.
     *
     * @deprecated Field a is deprecated.
     */
    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }
  }

  //                                              Object1
  // --------------------------------------------------------------------------------------------------
  //

  export interface Object1 extends $.OutputObject {
    name: 'Object1'
    fields: {
      __typename: Object1.__typename
      ABCEnum: Object1.ABCEnum
      boolean: Object1.$boolean
      float: Object1.float
      id: Object1.id
      int: Object1.int
      string: Object1.$string
    }
  }

  export namespace Object1 {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Object1'
      }
    }

    export interface ABCEnum extends $.OutputField {
      name: 'ABCEnum'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ABCEnum
    }

    export interface $boolean extends $.OutputField {
      name: 'boolean'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Boolean
    }

    export interface float extends $.OutputField {
      name: 'float'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Float
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface int extends $.OutputField {
      name: 'int'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Int
    }

    export interface $string extends $.OutputField {
      name: 'string'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                    Object1ImplementingInterface
  // --------------------------------------------------------------------------------------------------
  //

  export interface Object1ImplementingInterface extends $.OutputObject {
    name: 'Object1ImplementingInterface'
    fields: {
      __typename: Object1ImplementingInterface.__typename
      id: Object1ImplementingInterface.id
      int: Object1ImplementingInterface.int
    }
  }

  export namespace Object1ImplementingInterface {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Object1ImplementingInterface'
      }
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface int extends $.OutputField {
      name: 'int'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Int
    }
  }

  //                                    Object2ImplementingInterface
  // --------------------------------------------------------------------------------------------------
  //

  export interface Object2ImplementingInterface extends $.OutputObject {
    name: 'Object2ImplementingInterface'
    fields: {
      __typename: Object2ImplementingInterface.__typename
      boolean: Object2ImplementingInterface.$boolean
      id: Object2ImplementingInterface.id
    }
  }

  export namespace Object2ImplementingInterface {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Object2ImplementingInterface'
      }
    }

    export interface $boolean extends $.OutputField {
      name: 'boolean'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Boolean
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }
  }

  //                                            ObjectChildA
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectChildA extends $.OutputObject {
    name: 'ObjectChildA'
    fields: {
      __typename: ObjectChildA.__typename
      a: ObjectChildA.a
      b: ObjectChildA.b
      c1: ObjectChildA.c1
      me: ObjectChildA.me
    }
  }

  export namespace ObjectChildA {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectChildA'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface c1 extends $.OutputField {
      name: 'c1'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface me extends $.OutputField {
      name: 'me'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$Boolean
    }
  }

  //                                            ObjectChildB
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectChildB extends $.OutputObject {
    name: 'ObjectChildB'
    fields: {
      __typename: ObjectChildB.__typename
      a: ObjectChildB.a
      b: ObjectChildB.b
      c2: ObjectChildB.c2
      me: ObjectChildB.me
    }
  }

  export namespace ObjectChildB {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectChildB'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface c2 extends $.OutputField {
      name: 'c2'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface me extends $.OutputField {
      name: 'me'
      arguments: {}
      inlineType: [1, [1]]
      namedType: $$NamedTypes.$$Int
    }
  }

  //                                         ObjectGrandparent
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectGrandparent extends $.OutputObject {
    name: 'ObjectGrandparent'
    fields: {
      __typename: ObjectGrandparent.__typename
      a: ObjectGrandparent.a
      me: ObjectGrandparent.me
    }
  }

  export namespace ObjectGrandparent {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectGrandparent'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface me extends $.OutputField {
      name: 'me'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$Int
    }
  }

  //                                            ObjectNested
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectNested extends $.OutputObject {
    name: 'ObjectNested'
    fields: {
      __typename: ObjectNested.__typename
      id: ObjectNested.id
      object: ObjectNested.$object
    }
  }

  export namespace ObjectNested {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectNested'
      }
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface $object extends $.OutputField {
      name: 'object'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Object1
    }
  }

  //                                            ObjectParent
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectParent extends $.OutputObject {
    name: 'ObjectParent'
    fields: {
      __typename: ObjectParent.__typename
      a: ObjectParent.a
      b: ObjectParent.b
      me: ObjectParent.me
    }
  }

  export namespace ObjectParent {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectParent'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface me extends $.OutputField {
      name: 'me'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                            ObjectUnion
  // --------------------------------------------------------------------------------------------------
  //

  export interface ObjectUnion extends $.OutputObject {
    name: 'ObjectUnion'
    fields: {
      __typename: ObjectUnion.__typename
      fooBarUnion: ObjectUnion.fooBarUnion
    }
  }

  export namespace ObjectUnion {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'ObjectUnion'
      }
    }

    export interface fooBarUnion extends $.OutputField {
      name: 'fooBarUnion'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$FooBarUnion
    }
  }

  //                                          lowerCaseObject
  // --------------------------------------------------------------------------------------------------
  //

  export interface lowerCaseObject extends $.OutputObject {
    name: 'lowerCaseObject'
    fields: {
      __typename: lowerCaseObject.__typename
      id: lowerCaseObject.id
    }
  }

  export namespace lowerCaseObject {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'lowerCaseObject'
      }
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }
  }

  //                                          lowerCaseObject2
  // --------------------------------------------------------------------------------------------------
  //

  export interface lowerCaseObject2 extends $.OutputObject {
    name: 'lowerCaseObject2'
    fields: {
      __typename: lowerCaseObject2.__typename
      int: lowerCaseObject2.int
    }
  }

  export namespace lowerCaseObject2 {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'lowerCaseObject2'
      }
    }

    export interface int extends $.OutputField {
      name: 'int'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Int
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            InputObject
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                            InputObject
  // --------------------------------------------------------------------------------------------------
  //

  export interface InputObject extends $.InputObject {
    name: 'InputObject'
    isAllFieldsNullable: true
    fields: {
      date: InputObject.date
      dateRequired: InputObject.dateRequired
      id: InputObject.id
      idRequired: InputObject.idRequired
    }
  }

  export namespace InputObject {
    export interface date extends $.InputField {
      name: 'date'
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }

    export interface dateRequired extends $.InputField {
      name: 'dateRequired'
      inlineType: [1]
      namedType: $$NamedTypes.$$Date
    }

    export interface id extends $.InputField {
      name: 'id'
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }

    export interface idRequired extends $.InputField {
      name: 'idRequired'
      inlineType: [1]
      namedType: $$NamedTypes.$$ID
    }
  }

  //                                        InputObjectCircular
  // --------------------------------------------------------------------------------------------------
  //

  export interface InputObjectCircular extends $.InputObject {
    name: 'InputObjectCircular'
    isAllFieldsNullable: true
    fields: {
      circular: InputObjectCircular.circular
      date: InputObjectCircular.date
    }
  }

  export namespace InputObjectCircular {
    export interface circular extends $.InputField {
      name: 'circular'
      inlineType: [0]
      namedType: $$NamedTypes.$$InputObjectCircular
    }

    export interface date extends $.InputField {
      name: 'date'
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }
  }

  //                                         InputObjectNested
  // --------------------------------------------------------------------------------------------------
  //

  export interface InputObjectNested extends $.InputObject {
    name: 'InputObjectNested'
    isAllFieldsNullable: true
    fields: {
      InputObject: InputObjectNested.InputObject
    }
  }

  export namespace InputObjectNested {
    export interface InputObject extends $.InputField {
      name: 'InputObject'
      inlineType: [0]
      namedType: $$NamedTypes.$$InputObject
    }
  }

  //                                      InputObjectNestedNonNull
  // --------------------------------------------------------------------------------------------------
  //

  export interface InputObjectNestedNonNull extends $.InputObject {
    name: 'InputObjectNestedNonNull'
    isAllFieldsNullable: false
    fields: {
      InputObject: InputObjectNestedNonNull.InputObject
    }
  }

  export namespace InputObjectNestedNonNull {
    export interface InputObject extends $.InputField {
      name: 'InputObject'
      inlineType: [1]
      namedType: $$NamedTypes.$$InputObject
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                             Interface
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                           DateInterface1
  // --------------------------------------------------------------------------------------------------
  //

  export interface DateInterface1 extends $.Interface {
    fields: {
      date1: DateInterface1.date1
    }
    name: 'DateInterface1'
    implementors: [DateObject1]
    implementorsUnion: DateObject1
    implementorsIndex: {
      DateObject1: DateObject1
    }
  }

  export namespace DateInterface1 {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'DateInterface1'
      }
    }

    export interface date1 extends $.OutputField {
      name: 'date1'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$Date
    }
  }

  //                                               Error
  // --------------------------------------------------------------------------------------------------
  //

  export interface Error extends $.Interface {
    fields: {
      message: Error.message
    }
    name: 'Error'
    implementors: [ErrorOne, ErrorTwo]
    implementorsUnion:
      | ErrorOne
      | ErrorTwo
    implementorsIndex: {
      ErrorOne: ErrorOne
      ErrorTwo: ErrorTwo
    }
  }

  export namespace Error {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Error'
      }
    }

    export interface message extends $.OutputField {
      name: 'message'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                             Interface
  // --------------------------------------------------------------------------------------------------
  //

  export interface Interface extends $.Interface {
    fields: {
      id: Interface.id
    }
    name: 'Interface'
    implementors: [Object1ImplementingInterface, Object2ImplementingInterface]
    implementorsUnion:
      | Object1ImplementingInterface
      | Object2ImplementingInterface
    implementorsIndex: {
      Object1ImplementingInterface: Object1ImplementingInterface
      Object2ImplementingInterface: Object2ImplementingInterface
    }
  }

  export namespace Interface {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'Interface'
      }
    }

    export interface id extends $.OutputField {
      name: 'id'
      arguments: {}
      inlineType: [0]
      namedType: $$NamedTypes.$$ID
    }
  }

  //                                          InterfaceChildA
  // --------------------------------------------------------------------------------------------------
  //

  export interface InterfaceChildA extends $.Interface {
    fields: {
      a: InterfaceChildA.a
      b: InterfaceChildA.b
      c1: InterfaceChildA.c1
    }
    name: 'InterfaceChildA'
    implementors: [ObjectChildA]
    implementorsUnion: ObjectChildA
    implementorsIndex: {
      ObjectChildA: ObjectChildA
    }
  }

  export namespace InterfaceChildA {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'InterfaceChildA'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface c1 extends $.OutputField {
      name: 'c1'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                          InterfaceChildB
  // --------------------------------------------------------------------------------------------------
  //

  export interface InterfaceChildB extends $.Interface {
    fields: {
      a: InterfaceChildB.a
      b: InterfaceChildB.b
      c2: InterfaceChildB.c2
    }
    name: 'InterfaceChildB'
    implementors: [ObjectChildB]
    implementorsUnion: ObjectChildB
    implementorsIndex: {
      ObjectChildB: ObjectChildB
    }
  }

  export namespace InterfaceChildB {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'InterfaceChildB'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface c2 extends $.OutputField {
      name: 'c2'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                        InterfaceGrandparent
  // --------------------------------------------------------------------------------------------------
  //

  export interface InterfaceGrandparent extends $.Interface {
    fields: {
      a: InterfaceGrandparent.a
    }
    name: 'InterfaceGrandparent'
    implementors: [
      ObjectChildA,
      ObjectChildB,
      ObjectGrandparent,
      ObjectParent,
      InterfaceChildA,
      InterfaceChildB,
      InterfaceParent,
    ]
    implementorsUnion:
      | ObjectChildA
      | ObjectChildB
      | ObjectGrandparent
      | ObjectParent
      | InterfaceChildA
      | InterfaceChildB
      | InterfaceParent
    implementorsIndex: {
      ObjectChildA: ObjectChildA
      ObjectChildB: ObjectChildB
      ObjectGrandparent: ObjectGrandparent
      ObjectParent: ObjectParent
      InterfaceChildA: InterfaceChildA
      InterfaceChildB: InterfaceChildB
      InterfaceParent: InterfaceParent
    }
  }

  export namespace InterfaceGrandparent {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'InterfaceGrandparent'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //                                          InterfaceParent
  // --------------------------------------------------------------------------------------------------
  //

  export interface InterfaceParent extends $.Interface {
    fields: {
      a: InterfaceParent.a
      b: InterfaceParent.b
    }
    name: 'InterfaceParent'
    implementors: [ObjectChildA, ObjectChildB, ObjectParent, InterfaceChildA, InterfaceChildB]
    implementorsUnion:
      | ObjectChildA
      | ObjectChildB
      | ObjectParent
      | InterfaceChildA
      | InterfaceChildB
    implementorsIndex: {
      ObjectChildA: ObjectChildA
      ObjectChildB: ObjectChildB
      ObjectParent: ObjectParent
      InterfaceChildA: InterfaceChildA
      InterfaceChildB: InterfaceChildB
    }
  }

  export namespace InterfaceParent {
    export interface __typename extends $.OutputField {
      name: '__typename'
      arguments: {}
      inlineType: [1]
      namedType: {
        kind: '__typename'
        value: 'InterfaceParent'
      }
    }

    export interface a extends $.OutputField {
      name: 'a'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }

    export interface b extends $.OutputField {
      name: 'b'
      arguments: {}
      inlineType: [1]
      namedType: $$NamedTypes.$$String
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                               Union
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                             DateUnion
  // --------------------------------------------------------------------------------------------------
  //

  export interface DateUnion extends $.Union {
    name: 'DateUnion'
    members: [DateObject1, DateObject2]
    membersUnion:
      | DateObject1
      | DateObject2
    membersIndex: {
      DateObject1: DateObject1
      DateObject2: DateObject2
    }
  }

  //                                            FooBarUnion
  // --------------------------------------------------------------------------------------------------
  //

  /**
   * Union documentation.
   */
  export interface FooBarUnion extends $.Union {
    name: 'FooBarUnion'
    members: [Bar, Foo]
    membersUnion:
      | Bar
      | Foo
    membersIndex: {
      Bar: Bar
      Foo: Foo
    }
  }

  //                                               Result
  // --------------------------------------------------------------------------------------------------
  //

  export interface Result extends $.Union {
    name: 'Result'
    members: [ErrorOne, ErrorTwo, Object1]
    membersUnion:
      | ErrorOne
      | ErrorTwo
      | Object1
    membersIndex: {
      ErrorOne: ErrorOne
      ErrorTwo: ErrorTwo
      Object1: Object1
    }
  }

  //                                           lowerCaseUnion
  // --------------------------------------------------------------------------------------------------
  //

  export interface lowerCaseUnion extends $.Union {
    name: 'lowerCaseUnion'
    members: [lowerCaseObject, lowerCaseObject2]
    membersUnion:
      | lowerCaseObject
      | lowerCaseObject2
    membersIndex: {
      lowerCaseObject: lowerCaseObject
      lowerCaseObject2: lowerCaseObject2
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Enum
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                              ABCEnum
  // --------------------------------------------------------------------------------------------------
  //

  /**
   * Enum documentation.
   *
   * Members
   * "A" - (DEPRECATED: Enum value A is deprecated.)
   * "B" - Enum B member documentation.
   * "C" - (DEPRECATED: Enum value C is deprecated.)
   */
  export interface ABCEnum extends $.Enum {
    name: 'ABCEnum'
    members: ['A', 'B', 'C']
    membersUnion:
      | 'A'
      | 'B'
      | 'C'
  }

  //                                                Case
  // --------------------------------------------------------------------------------------------------
  //

  export interface Case extends $.Enum {
    name: 'Case'
    members: ['ErrorOne', 'ErrorTwo', 'Object1']
    membersUnion:
      | 'ErrorOne'
      | 'ErrorTwo'
      | 'Object1'
  }

  //                                   ChildAInterfaceHierarchyMember
  // --------------------------------------------------------------------------------------------------
  //

  export interface ChildAInterfaceHierarchyMember extends $.Enum {
    name: 'ChildAInterfaceHierarchyMember'
    members: ['InterfaceChildA']
    membersUnion: 'InterfaceChildA'
  }

  //                                   ChildBInterfaceHierarchyMember
  // --------------------------------------------------------------------------------------------------
  //

  export interface ChildBInterfaceHierarchyMember extends $.Enum {
    name: 'ChildBInterfaceHierarchyMember'
    members: ['InterfaceChildB']
    membersUnion: 'InterfaceChildB'
  }

  //                                GrandparentInterfaceHierarchyMember
  // --------------------------------------------------------------------------------------------------
  //

  export interface GrandparentInterfaceHierarchyMember extends $.Enum {
    name: 'GrandparentInterfaceHierarchyMember'
    members: ['InterfaceChildA', 'InterfaceChildB', 'InterfaceGrandparent', 'InterfaceParent']
    membersUnion:
      | 'InterfaceChildA'
      | 'InterfaceChildB'
      | 'InterfaceGrandparent'
      | 'InterfaceParent'
  }

  //                                   ParentInterfaceHierarchyMember
  // --------------------------------------------------------------------------------------------------
  //

  export interface ParentInterfaceHierarchyMember extends $.Enum {
    name: 'ParentInterfaceHierarchyMember'
    members: ['InterfaceChildA', 'InterfaceChildB', 'InterfaceParent']
    membersUnion:
      | 'InterfaceChildA'
      | 'InterfaceChildB'
      | 'InterfaceParent'
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            ScalarCustom
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                                Date
  // --------------------------------------------------------------------------------------------------
  //

  export type Date = $$Scalar.Date

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                           ScalarStandard
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                              Boolean
  // --------------------------------------------------------------------------------------------------
  //

  export type Boolean = $.StandardTypes.Boolean

  //                                               Float
  // --------------------------------------------------------------------------------------------------
  //

  export type Float = $.StandardTypes.Float

  //                                                 ID
  // --------------------------------------------------------------------------------------------------
  //

  export type ID = $.StandardTypes.ID

  //                                                Int
  // --------------------------------------------------------------------------------------------------
  //

  export type Int = $.StandardTypes.Int

  //                                               String
  // --------------------------------------------------------------------------------------------------
  //

  export type String = $.StandardTypes.String

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                         Named Types Index
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  /**
   * [1] These definitions serve to allow field selection interfaces to extend their respective object type without
   *     name clashing between the field name and the object name.
   *
   *     For example imagine \`Query.Foo\` field with type also called \`Foo\`. Our generated interfaces for each field
   *     would end up with an error of \`export interface Foo extends Foo ...\`
   */

  namespace $$NamedTypes {
    export type $$Query = Query
    export type $$Mutation = Mutation
    export type $$Bar = Bar
    export type $$DateObject1 = DateObject1
    export type $$DateObject2 = DateObject2
    export type $$ErrorOne = ErrorOne
    export type $$ErrorTwo = ErrorTwo
    export type $$Foo = Foo
    export type $$Object1 = Object1
    export type $$Object1ImplementingInterface = Object1ImplementingInterface
    export type $$Object2ImplementingInterface = Object2ImplementingInterface
    export type $$ObjectChildA = ObjectChildA
    export type $$ObjectChildB = ObjectChildB
    export type $$ObjectGrandparent = ObjectGrandparent
    export type $$ObjectNested = ObjectNested
    export type $$ObjectParent = ObjectParent
    export type $$ObjectUnion = ObjectUnion
    export type $$lowerCaseObject = lowerCaseObject
    export type $$lowerCaseObject2 = lowerCaseObject2
    export type $$InputObject = InputObject
    export type $$InputObjectCircular = InputObjectCircular
    export type $$InputObjectNested = InputObjectNested
    export type $$InputObjectNestedNonNull = InputObjectNestedNonNull
    export type $$DateInterface1 = DateInterface1
    export type $$Error = Error
    export type $$Interface = Interface
    export type $$InterfaceChildA = InterfaceChildA
    export type $$InterfaceChildB = InterfaceChildB
    export type $$InterfaceGrandparent = InterfaceGrandparent
    export type $$InterfaceParent = InterfaceParent
    export type $$DateUnion = DateUnion
    export type $$FooBarUnion = FooBarUnion
    export type $$Result = Result
    export type $$lowerCaseUnion = lowerCaseUnion
    export type $$ABCEnum = ABCEnum
    export type $$Case = Case
    export type $$ChildAInterfaceHierarchyMember = ChildAInterfaceHierarchyMember
    export type $$ChildBInterfaceHierarchyMember = ChildBInterfaceHierarchyMember
    export type $$GrandparentInterfaceHierarchyMember = GrandparentInterfaceHierarchyMember
    export type $$ParentInterfaceHierarchyMember = ParentInterfaceHierarchyMember
    export type $$Date = Date
    export type $$Boolean = Boolean
    export type $$Float = Float
    export type $$ID = ID
    export type $$Int = Int
    export type $$String = String
  }
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Schema
// ==================================================================================================
//
//
//
//
//
//

export interface Schema<$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Scalar.$Registry> extends $ {
  name: $$Data.Name
  operationsAvailable: ['query', 'mutation']
  RootUnion:
    | Schema.Query
    | Schema.Mutation
  Root: {
    query: Schema.Query
    mutation: Schema.Mutation
    subscription: null
  }
  allTypes: {
    Query: Schema.Query
    Mutation: Schema.Mutation
    ABCEnum: Schema.ABCEnum
    Case: Schema.Case
    ChildAInterfaceHierarchyMember: Schema.ChildAInterfaceHierarchyMember
    ChildBInterfaceHierarchyMember: Schema.ChildBInterfaceHierarchyMember
    GrandparentInterfaceHierarchyMember: Schema.GrandparentInterfaceHierarchyMember
    ParentInterfaceHierarchyMember: Schema.ParentInterfaceHierarchyMember
    Bar: Schema.Bar
    DateObject1: Schema.DateObject1
    DateObject2: Schema.DateObject2
    ErrorOne: Schema.ErrorOne
    ErrorTwo: Schema.ErrorTwo
    Foo: Schema.Foo
    Object1: Schema.Object1
    Object1ImplementingInterface: Schema.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object2ImplementingInterface
    ObjectChildA: Schema.ObjectChildA
    ObjectChildB: Schema.ObjectChildB
    ObjectGrandparent: Schema.ObjectGrandparent
    ObjectNested: Schema.ObjectNested
    ObjectParent: Schema.ObjectParent
    ObjectUnion: Schema.ObjectUnion
    lowerCaseObject: Schema.lowerCaseObject
    lowerCaseObject2: Schema.lowerCaseObject2
    DateUnion: Schema.DateUnion
    FooBarUnion: Schema.FooBarUnion
    Result: Schema.Result
    lowerCaseUnion: Schema.lowerCaseUnion
    DateInterface1: Schema.DateInterface1
    Error: Schema.Error
    Interface: Schema.Interface
    InterfaceChildA: Schema.InterfaceChildA
    InterfaceChildB: Schema.InterfaceChildB
    InterfaceGrandparent: Schema.InterfaceGrandparent
    InterfaceParent: Schema.InterfaceParent
  }
  objects: {
    Bar: Schema.Bar
    DateObject1: Schema.DateObject1
    DateObject2: Schema.DateObject2
    ErrorOne: Schema.ErrorOne
    ErrorTwo: Schema.ErrorTwo
    Foo: Schema.Foo
    Object1: Schema.Object1
    Object1ImplementingInterface: Schema.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object2ImplementingInterface
    ObjectChildA: Schema.ObjectChildA
    ObjectChildB: Schema.ObjectChildB
    ObjectGrandparent: Schema.ObjectGrandparent
    ObjectNested: Schema.ObjectNested
    ObjectParent: Schema.ObjectParent
    ObjectUnion: Schema.ObjectUnion
    lowerCaseObject: Schema.lowerCaseObject
    lowerCaseObject2: Schema.lowerCaseObject2
  }
  unions: {
    DateUnion: Schema.DateUnion
    FooBarUnion: Schema.FooBarUnion
    Result: Schema.Result
    lowerCaseUnion: Schema.lowerCaseUnion
  }
  interfaces: {
    DateInterface1: Schema.DateInterface1
    Error: Schema.Error
    Interface: Schema.Interface
    InterfaceChildA: Schema.InterfaceChildA
    InterfaceChildB: Schema.InterfaceChildB
    InterfaceGrandparent: Schema.InterfaceGrandparent
    InterfaceParent: Schema.InterfaceParent
  }
  scalarNamesUnion:
    | 'Date'
    | 'Boolean'
    | 'Float'
    | 'ID'
    | 'Int'
    | 'String'
  scalars: {
    Date: Schema.Date
    Boolean: Schema.Boolean
    Float: Schema.Float
    ID: Schema.ID
    Int: Schema.Int
    String: Schema.String
  }
  scalarRegistry: $Scalars
  extensions: $$Utilities.GlobalRegistry.TypeExtensions
}
"
`;

exports[`kitchen-sink generated modules > modules/schema-driven-data-map.ts 1`] = `
"import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $$Scalar from './scalar.js'
//
//
//
//
//
//
// ==================================================================================================
//                                           ScalarStandard
// ==================================================================================================
//
//
//
//
//
//

const Boolean = $$Scalar.Boolean

const Float = $$Scalar.Float

const ID = $$Scalar.ID

const Int = $$Scalar.Int

const String = $$Scalar.String

//
//
//
//
//
//
// ==================================================================================================
//                                            ScalarCustom
// ==================================================================================================
//
//
//
//
//
//

const Date = 'Date'

//
//
//
//
//
//
// ==================================================================================================
//                                                Enum
// ==================================================================================================
//
//
//
//
//
//

const ABCEnum: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ABCEnum',
}

const Case: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'Case',
}

const ChildAInterfaceHierarchyMember: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ChildAInterfaceHierarchyMember',
}

const ChildBInterfaceHierarchyMember: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ChildBInterfaceHierarchyMember',
}

const GrandparentInterfaceHierarchyMember: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'GrandparentInterfaceHierarchyMember',
}

const ParentInterfaceHierarchyMember: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ParentInterfaceHierarchyMember',
}

//
//
//
//
//
//
// ==================================================================================================
//                                            InputObject
// ==================================================================================================
//
//
//
//
//
//

const InputObject: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObject',
  fcs: ['date', 'dateRequired'],
  f: {
    date: {
      nt: Date,
    },
    dateRequired: {
      nt: Date,
    },
    id: {},
    idRequired: {},
  },
}

const InputObjectCircular: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectCircular',
  fcs: ['circular', 'date'],
  f: {
    circular: {
      // nt: InputObjectCircular, <-- Assigned later to avoid potential circular dependency.
    },
    date: {
      nt: Date,
    },
  },
}

const InputObjectNested: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNested',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const InputObjectNestedNonNull: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNestedNonNull',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                            OutputObject
// ==================================================================================================
//
//
//
//
//
//

const Bar: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

const DateObject1: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date1: {
      nt: Date,
    },
  },
}

const DateObject2: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date2: {
      nt: Date,
    },
  },
}

const ErrorOne: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    infoId: {},
    message: {},
  },
}

const ErrorTwo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    infoInt: {},
    message: {},
  },
}

const Foo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const Object1: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ABCEnum: {},
    boolean: {},
    float: {},
    id: {},
    int: {},
    string: {},
  },
}

const Object1ImplementingInterface: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    int: {},
  },
}

const Object2ImplementingInterface: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    boolean: {},
    id: {},
  },
}

const ObjectChildA: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    a: {},
    b: {},
    c1: {},
    me: {},
  },
}

const ObjectChildB: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    a: {},
    b: {},
    c2: {},
    me: {},
  },
}

const ObjectGrandparent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    a: {},
    me: {},
  },
}

const ObjectNested: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ObjectParent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    a: {},
    b: {},
    me: {},
  },
}

const ObjectUnion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    fooBarUnion: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const lowerCaseObject: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const lowerCaseObject2: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

const DateInterface1: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
  },
}

const Error: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Interface: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const InterfaceChildA: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const InterfaceChildB: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const InterfaceGrandparent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const InterfaceParent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

const DateUnion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
    ...DateObject2.f,
  },
}

const FooBarUnion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Result: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const lowerCaseUnion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

const Query: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    InputObjectNested: {
      a: {
        input: {
          nt: InputObjectNested,
          it: [0],
        },
      },
    },
    InputObjectNestedNonNull: {
      a: {
        input: {
          nt: InputObjectNestedNonNull,
          it: [1],
        },
      },
    },
    abcEnum: {},
    argInputObjectCircular: {
      a: {
        input: {
          nt: InputObjectCircular,
          it: [0],
        },
      },
    },
    date: {
      nt: Date,
    },
    dateArg: {
      a: {
        date: {
          nt: Date,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgList: {
      a: {
        date: {
          nt: Date,
          it: [0, [1]],
        },
      },
      nt: Date,
    },
    dateArgNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1],
        },
      },
      nt: Date,
    },
    dateArgNonNullList: {
      a: {
        date: {
          nt: Date,
          it: [1, [0]],
        },
      },
      nt: Date,
    },
    dateArgNonNullListNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1, [1]],
        },
      },
      nt: Date,
    },
    dateInterface1: {
      // nt: DateInterface1, <-- Assigned later to avoid potential circular dependency.
    },
    dateList: {
      nt: Date,
    },
    dateListList: {
      nt: Date,
    },
    dateListNonNull: {
      nt: Date,
    },
    dateNonNull: {
      nt: Date,
    },
    dateObject1: {
      // nt: DateObject1, <-- Assigned later to avoid potential circular dependency.
    },
    dateUnion: {
      // nt: DateUnion, <-- Assigned later to avoid potential circular dependency.
    },
    error: {
      a: {
        case: {
          nt: String,
          it: [0],
        },
      },
    },
    id: {},
    idNonNull: {},
    interface: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceHierarchyChildA: {
      a: {
        type: {
          nt: ChildAInterfaceHierarchyMember,
          it: [0],
        },
      },
      // nt: InterfaceChildA, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceHierarchyChildB: {
      a: {
        type: {
          nt: ChildBInterfaceHierarchyMember,
          it: [0],
        },
      },
      // nt: InterfaceChildB, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceHierarchyGrandparents: {
      a: {
        type: {
          nt: GrandparentInterfaceHierarchyMember,
          it: [0],
        },
      },
      // nt: InterfaceGrandparent, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceHierarchyParents: {
      a: {
        type: {
          nt: ParentInterfaceHierarchyMember,
          it: [0],
        },
      },
      // nt: InterfaceParent, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceNonNull: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [1],
        },
      },
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    listInt: {},
    listIntNonNull: {},
    listListInt: {},
    listListIntNonNull: {},
    lowerCaseUnion: {
      // nt: lowerCaseUnion, <-- Assigned later to avoid potential circular dependency.
    },
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectList: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectListNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectNested: {
      // nt: ObjectNested, <-- Assigned later to avoid potential circular dependency.
    },
    objectNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    result: {
      a: {
        case: {
          nt: Case,
          it: [1],
        },
      },
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    resultNonNull: {
      a: {
        case: {
          nt: Case,
          it: [0],
        },
      },
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    string: {},
    stringWithArgEnum: {
      a: {
        ABCEnum: {
          nt: ABCEnum,
          it: [0],
        },
      },
    },
    stringWithArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
    },
    stringWithArgInputObjectRequired: {
      a: {
        input: {
          nt: InputObject,
          it: [1],
        },
      },
    },
    stringWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
    },
    stringWithListArg: {
      a: {
        ints: {
          nt: Int,
          it: [0, [0]],
        },
      },
    },
    stringWithListArgRequired: {
      a: {
        ints: {
          nt: Int,
          it: [1, [1]],
        },
      },
    },
    stringWithRequiredArg: {
      a: {
        string: {
          nt: String,
          it: [1],
        },
      },
    },
    unionFooBar: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarNonNull: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [0],
        },
      },
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObject: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObjectNonNull: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Mutation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    idNonNull: {},
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                       Reference Assignments
//                                (avoids circular assignment issues)
// ==================================================================================================
//
//
//
//
//
//

InputObjectCircular.f![\`circular\`]!.nt = InputObjectCircular
InputObjectNested.f![\`InputObject\`]!.nt = InputObject
InputObjectNestedNonNull.f![\`InputObject\`]!.nt = InputObject
ObjectNested.f[\`object\`]!.nt = Object1
ObjectUnion.f[\`fooBarUnion\`]!.nt = FooBarUnion
Query.f[\`dateInterface1\`]!.nt = DateInterface1
Query.f[\`dateObject1\`]!.nt = DateObject1
Query.f[\`dateUnion\`]!.nt = DateUnion
Query.f[\`interface\`]!.nt = Interface
Query.f[\`interfaceHierarchyChildA\`]!.nt = InterfaceChildA
Query.f[\`interfaceHierarchyChildB\`]!.nt = InterfaceChildB
Query.f[\`interfaceHierarchyGrandparents\`]!.nt = InterfaceGrandparent
Query.f[\`interfaceHierarchyParents\`]!.nt = InterfaceParent
Query.f[\`interfaceNonNull\`]!.nt = Interface
Query.f[\`interfaceWithArgs\`]!.nt = Interface
Query.f[\`lowerCaseUnion\`]!.nt = lowerCaseUnion
Query.f[\`object\`]!.nt = Object1
Query.f[\`objectList\`]!.nt = Object1
Query.f[\`objectListNonNull\`]!.nt = Object1
Query.f[\`objectNested\`]!.nt = ObjectNested
Query.f[\`objectNonNull\`]!.nt = Object1
Query.f[\`objectWithArgs\`]!.nt = Object1
Query.f[\`result\`]!.nt = Result
Query.f[\`resultNonNull\`]!.nt = Result
Query.f[\`unionFooBar\`]!.nt = FooBarUnion
Query.f[\`unionFooBarNonNull\`]!.nt = FooBarUnion
Query.f[\`unionFooBarWithArgs\`]!.nt = FooBarUnion
Query.f[\`unionObject\`]!.nt = ObjectUnion
Query.f[\`unionObjectNonNull\`]!.nt = ObjectUnion

//
//
//
//
//
//
// ==================================================================================================
//                                               Index
// ==================================================================================================
//
//
//
//
//
//

const $schemaDrivenDataMap: $$Utilities.SchemaDrivenDataMap = {
  operations: {
    query: Query,
    mutation: Mutation,
  },
  directives: {},
  types: {
    Boolean,
    Float,
    ID,
    Int,
    String,
    Date,
    ABCEnum,
    Case,
    ChildAInterfaceHierarchyMember,
    ChildBInterfaceHierarchyMember,
    GrandparentInterfaceHierarchyMember,
    ParentInterfaceHierarchyMember,
    InputObject,
    InputObjectCircular,
    InputObjectNested,
    InputObjectNestedNonNull,
    Bar,
    DateObject1,
    DateObject2,
    ErrorOne,
    ErrorTwo,
    Foo,
    Object1,
    Object1ImplementingInterface,
    Object2ImplementingInterface,
    ObjectChildA,
    ObjectChildB,
    ObjectGrandparent,
    ObjectNested,
    ObjectParent,
    ObjectUnion,
    lowerCaseObject,
    lowerCaseObject2,
    DateInterface1,
    Error,
    Interface,
    InterfaceChildA,
    InterfaceChildB,
    InterfaceGrandparent,
    InterfaceParent,
    DateUnion,
    FooBarUnion,
    Result,
    lowerCaseUnion,
    Query,
    Mutation,
  },
}

export { $schemaDrivenDataMap as schemaDrivenDataMap }
"
`;

exports[`kitchen-sink generated modules > modules/select.ts 1`] = `
"import type { OperationTypeNode } from 'graphql'
import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import * as $$Data from './data.js'
import * as $$Schema from './schema.js'
import * as $$SelectionSets from './selection-sets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                              Runtime
// ==================================================================================================
//
//
//
//
//
//
import { createSelect } from '../../../../../../src/entrypoints/client.js'
export const Select = createSelect($$Data.Name)

//
//
//
//
//
//
// ==================================================================================================
//                                             Buildtime
// ==================================================================================================
//
//
//
//
//
//

export namespace Select {
  //                                                Root
  // --------------------------------------------------------------------------------------------------
  //
  export type Query<$SelectionSet extends $$SelectionSets.Query> = InferResult.Operation<
    $SelectionSet,
    $$Schema.Schema,
    OperationTypeNode.QUERY
  >
  export type Mutation<$SelectionSet extends $$SelectionSets.Mutation> = InferResult.Operation<
    $SelectionSet,
    $$Schema.Schema,
    OperationTypeNode.MUTATION
  >
  //                                            OutputObject
  // --------------------------------------------------------------------------------------------------
  //
  export type Bar<$SelectionSet extends $$SelectionSets.Bar> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Bar']
  >
  export type DateObject1<$SelectionSet extends $$SelectionSets.DateObject1> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['DateObject1']
  >
  export type DateObject2<$SelectionSet extends $$SelectionSets.DateObject2> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['DateObject2']
  >
  export type ErrorOne<$SelectionSet extends $$SelectionSets.ErrorOne> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ErrorOne']
  >
  export type ErrorTwo<$SelectionSet extends $$SelectionSets.ErrorTwo> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ErrorTwo']
  >
  export type Foo<$SelectionSet extends $$SelectionSets.Foo> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Foo']
  >
  export type Object1<$SelectionSet extends $$SelectionSets.Object1> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Object1']
  >
  export type Object1ImplementingInterface<$SelectionSet extends $$SelectionSets.Object1ImplementingInterface> =
    InferResult.OutputObjectLike<
      $SelectionSet,
      $$Schema.Schema,
      $$Schema.Schema['allTypes']['Object1ImplementingInterface']
    >
  export type Object2ImplementingInterface<$SelectionSet extends $$SelectionSets.Object2ImplementingInterface> =
    InferResult.OutputObjectLike<
      $SelectionSet,
      $$Schema.Schema,
      $$Schema.Schema['allTypes']['Object2ImplementingInterface']
    >
  export type ObjectChildA<$SelectionSet extends $$SelectionSets.ObjectChildA> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectChildA']
  >
  export type ObjectChildB<$SelectionSet extends $$SelectionSets.ObjectChildB> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectChildB']
  >
  export type ObjectGrandparent<$SelectionSet extends $$SelectionSets.ObjectGrandparent> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectGrandparent']
  >
  export type ObjectNested<$SelectionSet extends $$SelectionSets.ObjectNested> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectNested']
  >
  export type ObjectParent<$SelectionSet extends $$SelectionSets.ObjectParent> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectParent']
  >
  export type ObjectUnion<$SelectionSet extends $$SelectionSets.ObjectUnion> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['ObjectUnion']
  >
  export type lowerCaseObject<$SelectionSet extends $$SelectionSets.lowerCaseObject> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['lowerCaseObject']
  >
  export type lowerCaseObject2<$SelectionSet extends $$SelectionSets.lowerCaseObject2> = InferResult.OutputObjectLike<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['lowerCaseObject2']
  >
  //                                               Union
  // --------------------------------------------------------------------------------------------------
  //
  export type DateUnion<$SelectionSet extends $$SelectionSets.DateUnion> = InferResult.Union<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['DateUnion']
  >
  export type FooBarUnion<$SelectionSet extends $$SelectionSets.FooBarUnion> = InferResult.Union<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['FooBarUnion']
  >
  export type Result<$SelectionSet extends $$SelectionSets.Result> = InferResult.Union<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Result']
  >
  export type lowerCaseUnion<$SelectionSet extends $$SelectionSets.lowerCaseUnion> = InferResult.Union<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['lowerCaseUnion']
  >
  //                                             Interface
  // --------------------------------------------------------------------------------------------------
  //
  export type DateInterface1<$SelectionSet extends $$SelectionSets.DateInterface1> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['DateInterface1']
  >
  export type Error<$SelectionSet extends $$SelectionSets.Error> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Error']
  >
  export type Interface<$SelectionSet extends $$SelectionSets.Interface> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['Interface']
  >
  export type InterfaceChildA<$SelectionSet extends $$SelectionSets.InterfaceChildA> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['InterfaceChildA']
  >
  export type InterfaceChildB<$SelectionSet extends $$SelectionSets.InterfaceChildB> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['InterfaceChildB']
  >
  export type InterfaceGrandparent<$SelectionSet extends $$SelectionSets.InterfaceGrandparent> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['InterfaceGrandparent']
  >
  export type InterfaceParent<$SelectionSet extends $$SelectionSets.InterfaceParent> = InferResult.Interface<
    $SelectionSet,
    $$Schema.Schema,
    $$Schema.Schema['allTypes']['InterfaceParent']
  >
}
"
`;

exports[`kitchen-sink generated modules > modules/selection-sets.ts 1`] = `
"import type { Select as $Select } from '../../../../../../src/entrypoints/schema.js'
import type * as $$Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'

//
//
//
//
//
//
// ==================================================================================================
//                                              Document
// ==================================================================================================
//
//
//
//
//
//

export interface $Document<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  query?: Record<string, Query<_$Scalars>>
  mutation?: Record<string, Mutation<_$Scalars>>
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

//                                               Query
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Query<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * Select the \`InputObjectNested\` field on the \`Query\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  InputObjectNested?:
    | Query.InputObjectNested$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.InputObjectNested<_$Scalars>>
  /**
   * Select the \`InputObjectNestedNonNull\` field on the \`Query\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  InputObjectNestedNonNull?:
    | Query.InputObjectNestedNonNull<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.InputObjectNestedNonNull<_$Scalars>>
  /**
   * Select the \`abcEnum\` field on the \`Query\` object. Its type is \`ABCEnum\` (a \`Enum\` kind of type).
   */
  abcEnum?: Query.abcEnum$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.abcEnum<_$Scalars>>
  /**
   * Select the \`argInputObjectCircular\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  argInputObjectCircular?:
    | Query.argInputObjectCircular$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.argInputObjectCircular<_$Scalars>>
  /**
   * Select the \`date\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  date?: Query.date$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.date<_$Scalars>>
  /**
   * Select the \`dateArg\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArg?: Query.dateArg$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateArg<_$Scalars>>
  /**
   * Select the \`dateArgInputObject\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArgInputObject?:
    | Query.dateArgInputObject$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.dateArgInputObject<_$Scalars>>
  /**
   * Select the \`dateArgList\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArgList?: Query.dateArgList$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateArgList<_$Scalars>>
  /**
   * Select the \`dateArgNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArgNonNull?: Query.dateArgNonNull<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateArgNonNull<_$Scalars>>
  /**
   * Select the \`dateArgNonNullList\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArgNonNullList?:
    | Query.dateArgNonNullList<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.dateArgNonNullList<_$Scalars>>
  /**
   * Select the \`dateArgNonNullListNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateArgNonNullListNonNull?:
    | Query.dateArgNonNullListNonNull<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.dateArgNonNullListNonNull<_$Scalars>>
  /**
   * Select the \`dateInterface1\` field on the \`Query\` object. Its type is \`DateInterface1\` (a \`Interface\` kind of type).
   */
  dateInterface1?:
    | Query.dateInterface1$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.dateInterface1<_$Scalars>>
  /**
   * Select the \`dateList\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateList?: Query.dateList$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateList<_$Scalars>>
  /**
   * Select the \`dateListList\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateListList?: Query.dateListList$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateListList<_$Scalars>>
  /**
   * Select the \`dateListNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateListNonNull?:
    | Query.dateListNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.dateListNonNull<_$Scalars>>
  /**
   * Select the \`dateNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  dateNonNull?: Query.dateNonNull$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateNonNull<_$Scalars>>
  /**
   * Select the \`dateObject1\` field on the \`Query\` object. Its type is \`DateObject1\` (a \`OutputObject\` kind of type).
   */
  dateObject1?: Query.dateObject1$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateObject1<_$Scalars>>
  /**
   * Select the \`dateUnion\` field on the \`Query\` object. Its type is \`DateUnion\` (a \`Union\` kind of type).
   */
  dateUnion?: Query.dateUnion$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.dateUnion<_$Scalars>>
  /**
   * Select the \`error\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  error?: Query.error$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.error<_$Scalars>>
  /**
   * Select the \`id\` field on the \`Query\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: Query.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.id<_$Scalars>>
  /**
   * Select the \`idNonNull\` field on the \`Query\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  idNonNull?: Query.idNonNull$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.idNonNull<_$Scalars>>
  /**
   * Select the \`interface\` field on the \`Query\` object. Its type is \`Interface\` (a \`Interface\` kind of type).
   */
  interface?: Query.$interface$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.$interface<_$Scalars>>
  /**
   * Select the \`interfaceHierarchyChildA\` field on the \`Query\` object. Its type is \`InterfaceChildA\` (a \`Interface\` kind of type).
   */
  interfaceHierarchyChildA?:
    | Query.interfaceHierarchyChildA$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceHierarchyChildA<_$Scalars>>
  /**
   * Select the \`interfaceHierarchyChildB\` field on the \`Query\` object. Its type is \`InterfaceChildB\` (a \`Interface\` kind of type).
   */
  interfaceHierarchyChildB?:
    | Query.interfaceHierarchyChildB$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceHierarchyChildB<_$Scalars>>
  /**
   * Select the \`interfaceHierarchyGrandparents\` field on the \`Query\` object. Its type is \`InterfaceGrandparent\` (a \`Interface\` kind of type).
   */
  interfaceHierarchyGrandparents?:
    | Query.interfaceHierarchyGrandparents$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceHierarchyGrandparents<_$Scalars>>
  /**
   * Select the \`interfaceHierarchyParents\` field on the \`Query\` object. Its type is \`InterfaceParent\` (a \`Interface\` kind of type).
   */
  interfaceHierarchyParents?:
    | Query.interfaceHierarchyParents$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceHierarchyParents<_$Scalars>>
  /**
   * Select the \`interfaceNonNull\` field on the \`Query\` object. Its type is \`Interface\` (a \`Interface\` kind of type).
   */
  interfaceNonNull?:
    | Query.interfaceNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceNonNull<_$Scalars>>
  /**
   * Select the \`interfaceWithArgs\` field on the \`Query\` object. Its type is \`Interface\` (a \`Interface\` kind of type).
   */
  interfaceWithArgs?:
    | Query.interfaceWithArgs<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.interfaceWithArgs<_$Scalars>>
  /**
   * Select the \`listInt\` field on the \`Query\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  listInt?: Query.listInt$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.listInt<_$Scalars>>
  /**
   * Select the \`listIntNonNull\` field on the \`Query\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  listIntNonNull?:
    | Query.listIntNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.listIntNonNull<_$Scalars>>
  /**
   * Select the \`listListInt\` field on the \`Query\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  listListInt?: Query.listListInt$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.listListInt<_$Scalars>>
  /**
   * Select the \`listListIntNonNull\` field on the \`Query\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  listListIntNonNull?:
    | Query.listListIntNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.listListIntNonNull<_$Scalars>>
  /**
   * Select the \`lowerCaseUnion\` field on the \`Query\` object. Its type is \`lowerCaseUnion\` (a \`Union\` kind of type).
   */
  lowerCaseUnion?:
    | Query.lowerCaseUnion$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.lowerCaseUnion<_$Scalars>>
  /**
   * Select the \`object\` field on the \`Query\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  object?: Query.$object$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.$object<_$Scalars>>
  /**
   * Select the \`objectList\` field on the \`Query\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  objectList?: Query.objectList$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.objectList<_$Scalars>>
  /**
   * Select the \`objectListNonNull\` field on the \`Query\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  objectListNonNull?:
    | Query.objectListNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.objectListNonNull<_$Scalars>>
  /**
   * Select the \`objectNested\` field on the \`Query\` object. Its type is \`ObjectNested\` (a \`OutputObject\` kind of type).
   */
  objectNested?: Query.objectNested$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.objectNested<_$Scalars>>
  /**
   * Select the \`objectNonNull\` field on the \`Query\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  objectNonNull?:
    | Query.objectNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.objectNonNull<_$Scalars>>
  /**
   * Select the \`objectWithArgs\` field on the \`Query\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  objectWithArgs?:
    | Query.objectWithArgs$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.objectWithArgs<_$Scalars>>
  /**
   * Select the \`result\` field on the \`Query\` object. Its type is \`Result\` (a \`Union\` kind of type).
   */
  result?: Query.result<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.result<_$Scalars>>
  /**
   * Select the \`resultNonNull\` field on the \`Query\` object. Its type is \`Result\` (a \`Union\` kind of type).
   */
  resultNonNull?:
    | Query.resultNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.resultNonNull<_$Scalars>>
  /**
   * Select the \`string\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  string?: Query.$string$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.$string<_$Scalars>>
  /**
   * Select the \`stringWithArgEnum\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithArgEnum?:
    | Query.stringWithArgEnum$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgEnum<_$Scalars>>
  /**
   * Select the \`stringWithArgInputObject\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithArgInputObject?:
    | Query.stringWithArgInputObject$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgInputObject<_$Scalars>>
  /**
   * Select the \`stringWithArgInputObjectRequired\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithArgInputObjectRequired?:
    | Query.stringWithArgInputObjectRequired<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgInputObjectRequired<_$Scalars>>
  /**
   * Select the \`stringWithArgs\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithArgs?:
    | Query.stringWithArgs$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgs<_$Scalars>>
  /**
   * Select the \`stringWithListArg\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithListArg?:
    | Query.stringWithListArg$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithListArg<_$Scalars>>
  /**
   * Select the \`stringWithListArgRequired\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithListArgRequired?:
    | Query.stringWithListArgRequired<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithListArgRequired<_$Scalars>>
  /**
   * Select the \`stringWithRequiredArg\` field on the \`Query\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  stringWithRequiredArg?:
    | Query.stringWithRequiredArg<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.stringWithRequiredArg<_$Scalars>>
  /**
   * Select the \`unionFooBar\` field on the \`Query\` object. Its type is \`FooBarUnion\` (a \`Union\` kind of type).
   */
  unionFooBar?: Query.unionFooBar$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.unionFooBar<_$Scalars>>
  /**
   * Select the \`unionFooBarNonNull\` field on the \`Query\` object. Its type is \`FooBarUnion\` (a \`Union\` kind of type).
   */
  unionFooBarNonNull?:
    | Query.unionFooBarNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.unionFooBarNonNull<_$Scalars>>
  /**
   * Select the \`unionFooBarWithArgs\` field on the \`Query\` object. Its type is \`FooBarUnion\` (a \`Union\` kind of type).
   */
  unionFooBarWithArgs?:
    | Query.unionFooBarWithArgs$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.unionFooBarWithArgs<_$Scalars>>
  /**
   * Select the \`unionObject\` field on the \`Query\` object. Its type is \`ObjectUnion\` (a \`OutputObject\` kind of type).
   */
  unionObject?: Query.unionObject$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Query.unionObject<_$Scalars>>
  /**
   * Select the \`unionObjectNonNull\` field on the \`Query\` object. Its type is \`ObjectUnion\` (a \`OutputObject\` kind of type).
   */
  unionObjectNonNull?:
    | Query.unionObjectNonNull$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Query.unionObjectNonNull<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Query$FragmentInline<_$Scalars>
    | Query$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Query$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Query<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Query {
  export type InputObjectNested<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | InputObjectNested$SelectionSet<_$Scalars>

  export interface InputObjectNested$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`InputObjectNested\` field. No arguments are required so you may omit this.
     */
    $?: InputObjectNested$Arguments<_$Scalars>
  }

  export interface InputObjectNested$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input?: $NamedTypes.$InputObjectNested<_$Scalars> | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`InputObjectNested\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type InputObjectNested$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | InputObjectNested$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type InputObjectNestedNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InputObjectNestedNonNull$SelectionSet<_$Scalars>

  export interface InputObjectNestedNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`InputObjectNestedNonNull\` field. All arguments are required so you must include this.
     */
    $: InputObjectNestedNonNull$Arguments<_$Scalars>
  }

  export interface InputObjectNestedNonNull$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input: $NamedTypes.$InputObjectNestedNonNull<_$Scalars>
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`InputObjectNestedNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type InputObjectNestedNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    InputObjectNestedNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type abcEnum<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | abcEnum$SelectionSet<_$Scalars>

  export interface abcEnum$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`abcEnum\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type abcEnum$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | abcEnum$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type argInputObjectCircular<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | argInputObjectCircular$SelectionSet<_$Scalars>

  export interface argInputObjectCircular$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`argInputObjectCircular\` field. No arguments are required so you may omit this.
     */
    $?: argInputObjectCircular$Arguments<_$Scalars>
  }

  export interface argInputObjectCircular$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input?: $NamedTypes.$InputObjectCircular<_$Scalars> | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`argInputObjectCircular\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type argInputObjectCircular$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | argInputObjectCircular$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type date<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | date$SelectionSet<_$Scalars>

  export interface date$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`date\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | date$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArg<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | dateArg$SelectionSet<_$Scalars>

  export interface dateArg$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArg\` field. No arguments are required so you may omit this.
     */
    $?: dateArg$Arguments<_$Scalars>
  }

  export interface dateArg$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    date?:
      | $$Utilities.Schema.Scalar.GetDecoded<
        $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
      >
      | undefined
      | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArg\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArg$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateArg$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArgInputObject<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateArgInputObject$SelectionSet<_$Scalars>

  export interface dateArgInputObject$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgInputObject\` field. No arguments are required so you may omit this.
     */
    $?: dateArgInputObject$Arguments<_$Scalars>
  }

  export interface dateArgInputObject$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input?: $NamedTypes.$InputObject<_$Scalars> | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArgInputObject\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgInputObject$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateArgInputObject$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArgList<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateArgList$SelectionSet<_$Scalars>

  export interface dateArgList$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgList\` field. No arguments are required so you may omit this.
     */
    $?: dateArgList$Arguments<_$Scalars>
  }

  export interface dateArgList$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    date?:
      | Array<
        | $$Utilities.Schema.Scalar.GetDecoded<
          $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
        >
        | undefined
        | null
      >
      | undefined
      | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArgList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgList$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateArgList$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArgNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateArgNonNull$SelectionSet<_$Scalars>

  export interface dateArgNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNull\` field. All arguments are required so you must include this.
     */
    $: dateArgNonNull$Arguments<_$Scalars>
  }

  export interface dateArgNonNull$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    date: $$Utilities.Schema.Scalar.GetDecoded<
      $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
    >
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArgNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateArgNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArgNonNullList<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateArgNonNullList$SelectionSet<_$Scalars>

  export interface dateArgNonNullList$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNullList\` field. All arguments are required so you must include this.
     */
    $: dateArgNonNullList$Arguments<_$Scalars>
  }

  export interface dateArgNonNullList$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    date: Array<
      | $$Utilities.Schema.Scalar.GetDecoded<
        $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
      >
      | undefined
      | null
    >
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArgNonNullList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgNonNullList$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateArgNonNullList$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateArgNonNullListNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateArgNonNullListNonNull$SelectionSet<_$Scalars>

  export interface dateArgNonNullListNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNullListNonNull\` field. All arguments are required so you must include this.
     */
    $: dateArgNonNullListNonNull$Arguments<_$Scalars>
  }

  export interface dateArgNonNullListNonNull$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    date: Array<
      | $$Utilities.Schema.Scalar.GetDecoded<
        $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
      >
      | undefined
      | null
    >
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateArgNonNullListNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgNonNullListNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateArgNonNullListNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateInterface1<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateInterface1$SelectionSet<_$Scalars>

  export interface dateInterface1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$DateInterface1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateInterface1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateInterface1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateInterface1$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateList<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateList$SelectionSet<_$Scalars>

  export interface dateList$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateList$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateList$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateListList<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateListList$SelectionSet<_$Scalars>

  export interface dateListList$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateListList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateListList$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateListList$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateListNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateListNonNull$SelectionSet<_$Scalars>

  export interface dateListNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateListNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateListNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateListNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | dateNonNull$SelectionSet<_$Scalars>

  export interface dateNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | dateNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateObject1<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateObject1$SelectionSet<_$Scalars>

  export interface dateObject1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$DateObject1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateObject1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateObject1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateObject1$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type dateUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = dateUnion$SelectionSet<_$Scalars>

  export interface dateUnion$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$DateUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`dateUnion\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateUnion$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    dateUnion$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type error<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | error$SelectionSet<_$Scalars>

  export interface error$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`error\` field. No arguments are required so you may omit this.
     */
    $?: error$Arguments<_$Scalars>
  }

  export interface error$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    case?: string | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`error\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type error$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | error$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type idNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | idNonNull$SelectionSet<_$Scalars>

  export interface idNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`idNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type idNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | idNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $interface<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $interface$SelectionSet<_$Scalars>

  export interface $interface$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Interface<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$interface\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $interface$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    $interface$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceHierarchyChildA<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceHierarchyChildA$SelectionSet<_$Scalars>

  export interface interfaceHierarchyChildA$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$InterfaceChildA<_$Scalars> {
    /**
     * Arguments for \`interfaceHierarchyChildA\` field. No arguments are required so you may omit this.
     */
    $?: interfaceHierarchyChildA$Arguments<_$Scalars>
  }

  export interface interfaceHierarchyChildA$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $type?: $NamedTypes.$ChildAInterfaceHierarchyMember | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceHierarchyChildA\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceHierarchyChildA$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceHierarchyChildA$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceHierarchyChildB<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceHierarchyChildB$SelectionSet<_$Scalars>

  export interface interfaceHierarchyChildB$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$InterfaceChildB<_$Scalars> {
    /**
     * Arguments for \`interfaceHierarchyChildB\` field. No arguments are required so you may omit this.
     */
    $?: interfaceHierarchyChildB$Arguments<_$Scalars>
  }

  export interface interfaceHierarchyChildB$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $type?: $NamedTypes.$ChildBInterfaceHierarchyMember | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceHierarchyChildB\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceHierarchyChildB$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceHierarchyChildB$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceHierarchyGrandparents<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceHierarchyGrandparents$SelectionSet<_$Scalars>

  export interface interfaceHierarchyGrandparents$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$InterfaceGrandparent<_$Scalars> {
    /**
     * Arguments for \`interfaceHierarchyGrandparents\` field. No arguments are required so you may omit this.
     */
    $?: interfaceHierarchyGrandparents$Arguments<_$Scalars>
  }

  export interface interfaceHierarchyGrandparents$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $type?: $NamedTypes.$GrandparentInterfaceHierarchyMember | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceHierarchyGrandparents\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceHierarchyGrandparents$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceHierarchyGrandparents$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceHierarchyParents<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceHierarchyParents$SelectionSet<_$Scalars>

  export interface interfaceHierarchyParents$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$InterfaceParent<_$Scalars> {
    /**
     * Arguments for \`interfaceHierarchyParents\` field. No arguments are required so you may omit this.
     */
    $?: interfaceHierarchyParents$Arguments<_$Scalars>
  }

  export interface interfaceHierarchyParents$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $type?: $NamedTypes.$ParentInterfaceHierarchyMember | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceHierarchyParents\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceHierarchyParents$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceHierarchyParents$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceNonNull$SelectionSet<_$Scalars>

  export interface interfaceNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Interface<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type interfaceWithArgs<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = interfaceWithArgs$SelectionSet<_$Scalars>

  export interface interfaceWithArgs$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Interface<_$Scalars> {
    /**
     * Arguments for \`interfaceWithArgs\` field. All arguments are required so you must include this.
     */
    $: interfaceWithArgs$Arguments<_$Scalars>
  }

  export interface interfaceWithArgs$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    id: string
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`interfaceWithArgs\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type interfaceWithArgs$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    interfaceWithArgs$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type listInt<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | listInt$SelectionSet<_$Scalars>

  export interface listInt$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`listInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listInt$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | listInt$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type listIntNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | listIntNonNull$SelectionSet<_$Scalars>

  export interface listIntNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`listIntNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listIntNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | listIntNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type listListInt<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | listListInt$SelectionSet<_$Scalars>

  export interface listListInt$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`listListInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listListInt$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | listListInt$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type listListIntNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | listListIntNonNull$SelectionSet<_$Scalars>

  export interface listListIntNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`listListIntNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listListIntNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | listListIntNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type lowerCaseUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = lowerCaseUnion$SelectionSet<_$Scalars>

  export interface lowerCaseUnion$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$lowerCaseUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`lowerCaseUnion\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type lowerCaseUnion$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    lowerCaseUnion$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $object<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    $object$SelectionSet<_$Scalars>

  export interface $object$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$object\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $object$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    $object$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type objectList<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = objectList$SelectionSet<_$Scalars>

  export interface objectList$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`objectList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type objectList$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    objectList$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type objectListNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = objectListNonNull$SelectionSet<_$Scalars>

  export interface objectListNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`objectListNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type objectListNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    objectListNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type objectNested<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = objectNested$SelectionSet<_$Scalars>

  export interface objectNested$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$ObjectNested<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`objectNested\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type objectNested$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    objectNested$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type objectNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = objectNonNull$SelectionSet<_$Scalars>

  export interface objectNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`objectNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type objectNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    objectNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type objectWithArgs<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = objectWithArgs$SelectionSet<_$Scalars>

  export interface objectWithArgs$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {
    /**
     * Arguments for \`objectWithArgs\` field. No arguments are required so you may omit this.
     */
    $?: objectWithArgs$Arguments<_$Scalars>
  }

  export interface objectWithArgs$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    boolean?: boolean | undefined | null
    float?: number | undefined | null
    id?: string | undefined | null
    int?: number | undefined | null
    string?: string | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`objectWithArgs\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type objectWithArgs$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    objectWithArgs$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type result<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    result$SelectionSet<_$Scalars>

  export interface result$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Result<_$Scalars> {
    /**
     * Arguments for \`result\` field. All arguments are required so you must include this.
     */
    $: result$Arguments<_$Scalars>
  }

  export interface result$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $case: $NamedTypes.$Case
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`result\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type result$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    result$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type resultNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = resultNonNull$SelectionSet<_$Scalars>

  export interface resultNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Result<_$Scalars> {
    /**
     * Arguments for \`resultNonNull\` field. No arguments are required so you may omit this.
     */
    $?: resultNonNull$Arguments<_$Scalars>
  }

  export interface resultNonNull$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $case?: $NamedTypes.$Case | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`resultNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type resultNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    resultNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $string<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | $string$SelectionSet<_$Scalars>

  export interface $string$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$string\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $string$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | $string$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithArgEnum<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgEnum$SelectionSet<_$Scalars>

  export interface stringWithArgEnum$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithArgEnum\` field. No arguments are required so you may omit this.
     */
    $?: stringWithArgEnum$Arguments<_$Scalars>
  }

  export interface stringWithArgEnum$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    $ABCEnum?: $NamedTypes.$ABCEnum | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithArgEnum\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgEnum$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgEnum$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithArgInputObject<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgInputObject$SelectionSet<_$Scalars>

  export interface stringWithArgInputObject$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithArgInputObject\` field. No arguments are required so you may omit this.
     */
    $?: stringWithArgInputObject$Arguments<_$Scalars>
  }

  export interface stringWithArgInputObject$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input?: $NamedTypes.$InputObject<_$Scalars> | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithArgInputObject\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgInputObject$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgInputObject$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithArgInputObjectRequired<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = stringWithArgInputObjectRequired$SelectionSet<_$Scalars>

  export interface stringWithArgInputObjectRequired$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithArgInputObjectRequired\` field. All arguments are required so you must include this.
     */
    $: stringWithArgInputObjectRequired$Arguments<_$Scalars>
  }

  export interface stringWithArgInputObjectRequired$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    input: $NamedTypes.$InputObject<_$Scalars>
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithArgInputObjectRequired\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgInputObjectRequired$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    stringWithArgInputObjectRequired$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithArgs<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgs$SelectionSet<_$Scalars>

  export interface stringWithArgs$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithArgs\` field. No arguments are required so you may omit this.
     */
    $?: stringWithArgs$Arguments<_$Scalars>
  }

  export interface stringWithArgs$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    boolean?: boolean | undefined | null
    float?: number | undefined | null
    id?: string | undefined | null
    /**
     * @deprecated Example of argument deprecation reason here.
     */
    int?: number | undefined | null
    /**
     * Example of some argument documentation here.
     */
    string?: string | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithArgs\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgs$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | stringWithArgs$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithListArg<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | stringWithListArg$SelectionSet<_$Scalars>

  export interface stringWithListArg$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithListArg\` field. No arguments are required so you may omit this.
     */
    $?: stringWithListArg$Arguments<_$Scalars>
  }

  export interface stringWithListArg$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    ints?: Array<number | undefined | null> | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithListArg\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithListArg$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | stringWithListArg$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithListArgRequired<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = stringWithListArgRequired$SelectionSet<_$Scalars>

  export interface stringWithListArgRequired$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithListArgRequired\` field. All arguments are required so you must include this.
     */
    $: stringWithListArgRequired$Arguments<_$Scalars>
  }

  export interface stringWithListArgRequired$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    ints: Array<number | undefined | null>
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithListArgRequired\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithListArgRequired$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    stringWithListArgRequired$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type stringWithRequiredArg<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = stringWithRequiredArg$SelectionSet<_$Scalars>

  export interface stringWithRequiredArg$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithRequiredArg\` field. All arguments are required so you must include this.
     */
    $: stringWithRequiredArg$Arguments<_$Scalars>
  }

  export interface stringWithRequiredArg$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    string: string
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`stringWithRequiredArg\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithRequiredArg$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    stringWithRequiredArg$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type unionFooBar<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = unionFooBar$SelectionSet<_$Scalars>

  export interface unionFooBar$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$FooBarUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`unionFooBar\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type unionFooBar$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    unionFooBar$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type unionFooBarNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = unionFooBarNonNull$SelectionSet<_$Scalars>

  export interface unionFooBarNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$FooBarUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`unionFooBarNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type unionFooBarNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    unionFooBarNonNull$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type unionFooBarWithArgs<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = unionFooBarWithArgs$SelectionSet<_$Scalars>

  export interface unionFooBarWithArgs$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$FooBarUnion<_$Scalars> {
    /**
     * Arguments for \`unionFooBarWithArgs\` field. No arguments are required so you may omit this.
     */
    $?: unionFooBarWithArgs$Arguments<_$Scalars>
  }

  export interface unionFooBarWithArgs$Arguments<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > {
    id?: string | undefined | null
  }

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`unionFooBarWithArgs\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type unionFooBarWithArgs$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    unionFooBarWithArgs$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type unionObject<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = unionObject$SelectionSet<_$Scalars>

  export interface unionObject$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$ObjectUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`unionObject\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type unionObject$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    unionObject$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type unionObjectNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = unionObjectNonNull$SelectionSet<_$Scalars>

  export interface unionObjectNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$ObjectUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`unionObjectNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type unionObjectNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    unionObjectNonNull$SelectionSet<_$Scalars>
  >
}

//                                              Mutation
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Mutation<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * Select the \`id\` field on the \`Mutation\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: Mutation.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Mutation.id<_$Scalars>>
  /**
   * Select the \`idNonNull\` field on the \`Mutation\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  idNonNull?: Mutation.idNonNull$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Mutation.idNonNull<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Mutation$FragmentInline<_$Scalars>
    | Mutation$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Mutation$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Mutation<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Mutation {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type idNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | idNonNull$SelectionSet<_$Scalars>

  export interface idNonNull$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`idNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type idNonNull$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | idNonNull$SelectionSet<_$Scalars>
  >
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Enum
// ==================================================================================================
//
//
//
//
//
//

/**
 * Enum documentation.
 *
 * Members
 * "A" - (DEPRECATED: Enum value A is deprecated.)
 * "B" - Enum B member documentation.
 * "C" - (DEPRECATED: Enum value C is deprecated.)
 */
export type ABCEnum =
  | 'A'
  | 'B'
  | 'C'

export type Case =
  | 'ErrorOne'
  | 'ErrorTwo'
  | 'Object1'

export type ChildAInterfaceHierarchyMember = 'InterfaceChildA'

export type ChildBInterfaceHierarchyMember = 'InterfaceChildB'

export type GrandparentInterfaceHierarchyMember =
  | 'InterfaceChildA'
  | 'InterfaceChildB'
  | 'InterfaceGrandparent'
  | 'InterfaceParent'

export type ParentInterfaceHierarchyMember =
  | 'InterfaceChildA'
  | 'InterfaceChildB'
  | 'InterfaceParent'

//
//
//
//
//
//
// ==================================================================================================
//                                            InputObject
// ==================================================================================================
//
//
//
//
//
//

export interface InputObject<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  date?:
    | $$Utilities.Schema.Scalar.GetDecoded<
      $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
    >
    | undefined
    | null
  dateRequired: $$Utilities.Schema.Scalar.GetDecoded<
    $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
  >
  id?: string | undefined | null
  idRequired: string
}

export interface InputObjectCircular<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  circular?: $NamedTypes.$InputObjectCircular<_$Scalars> | undefined | null
  date?:
    | $$Utilities.Schema.Scalar.GetDecoded<
      $$Utilities.Schema.Scalar.LookupCustomScalarOrFallbackToString<'Date', _$Scalars>
    >
    | undefined
    | null
}

export interface InputObjectNested<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  InputObject?: $NamedTypes.$InputObject<_$Scalars> | undefined | null
}

export interface InputObjectNestedNonNull<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  InputObject: $NamedTypes.$InputObject<_$Scalars>
}

//
//
//
//
//
//
// ==================================================================================================
//                                            OutputObject
// ==================================================================================================
//
//
//
//
//
//

//                                                Bar
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Bar<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty>
  extends $Select.Bases.ObjectLike
{
  /**
   * Select the \`int\` field on the \`Bar\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  int?: Bar.int$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Bar.int<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Bar$FragmentInline<_$Scalars>
    | Bar$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Bar$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Bar<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Bar {
  export type int<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>

  export interface int$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>
  >
}

//                                            DateObject1
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface DateObject1<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`date1\` field on the \`DateObject1\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  date1?: DateObject1.date1$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<DateObject1.date1<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | DateObject1$FragmentInline<_$Scalars>
    | DateObject1$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateObject1$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends DateObject1<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace DateObject1 {
  export type date1<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | date1$SelectionSet<_$Scalars>

  export interface date1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`date1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | date1$SelectionSet<_$Scalars>
  >
}

//                                            DateObject2
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface DateObject2<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`date2\` field on the \`DateObject2\` object. Its type is \`Date\` (a \`ScalarCustom\` kind of type).
   */
  date2?: DateObject2.date2$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<DateObject2.date2<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | DateObject2$FragmentInline<_$Scalars>
    | DateObject2$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateObject2$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends DateObject2<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace DateObject2 {
  export type date2<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | date2$SelectionSet<_$Scalars>

  export interface date2$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`date2\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date2$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | date2$SelectionSet<_$Scalars>
  >
}

//                                              ErrorOne
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ErrorOne<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`infoId\` field on the \`ErrorOne\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  infoId?: ErrorOne.infoId$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ErrorOne.infoId<_$Scalars>>
  /**
   * Select the \`message\` field on the \`ErrorOne\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  message?: ErrorOne.message$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ErrorOne.message<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ErrorOne$FragmentInline<_$Scalars>
    | ErrorOne$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ErrorOne$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ErrorOne<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ErrorOne {
  export type infoId<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | infoId$SelectionSet<_$Scalars>

  export interface infoId$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`infoId\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type infoId$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | infoId$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type message<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>

  export interface message$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>
  >
}

//                                              ErrorTwo
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ErrorTwo<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`infoInt\` field on the \`ErrorTwo\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  infoInt?: ErrorTwo.infoInt$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ErrorTwo.infoInt<_$Scalars>>
  /**
   * Select the \`message\` field on the \`ErrorTwo\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  message?: ErrorTwo.message$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ErrorTwo.message<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ErrorTwo$FragmentInline<_$Scalars>
    | ErrorTwo$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ErrorTwo$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ErrorTwo<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ErrorTwo {
  export type infoInt<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | infoInt$SelectionSet<_$Scalars>

  export interface infoInt$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`infoInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type infoInt$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | infoInt$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type message<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>

  export interface message$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>
  >
}

//                                                Foo
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

/**
 * Object documentation.
 */
export interface Foo<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty>
  extends $Select.Bases.ObjectLike
{
  /**
   * Select the \`id\` field on the \`Foo\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: Foo.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Foo.id<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Foo$FragmentInline<_$Scalars>
    | Foo$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Foo$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Foo<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Foo {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >
}

//                                              Object1
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Object1<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`ABCEnum\` field on the \`Object1\` object. Its type is \`ABCEnum\` (a \`Enum\` kind of type).
   */
  ABCEnum?: Object1.ABCEnum$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.ABCEnum<_$Scalars>>
  /**
   * Select the \`boolean\` field on the \`Object1\` object. Its type is \`Boolean\` (a \`ScalarStandard\` kind of type).
   */
  boolean?: Object1.$boolean$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.$boolean<_$Scalars>>
  /**
   * Select the \`float\` field on the \`Object1\` object. Its type is \`Float\` (a \`ScalarStandard\` kind of type).
   */
  float?: Object1.float$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.float<_$Scalars>>
  /**
   * Select the \`id\` field on the \`Object1\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: Object1.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.id<_$Scalars>>
  /**
   * Select the \`int\` field on the \`Object1\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  int?: Object1.int$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.int<_$Scalars>>
  /**
   * Select the \`string\` field on the \`Object1\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  string?: Object1.$string$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<Object1.$string<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Object1$FragmentInline<_$Scalars>
    | Object1$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object1$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Object1<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Object1 {
  export type ABCEnum<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | ABCEnum$SelectionSet<_$Scalars>

  export interface ABCEnum$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`ABCEnum\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type ABCEnum$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | ABCEnum$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $boolean<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | $boolean$SelectionSet<_$Scalars>

  export interface $boolean$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$boolean\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $boolean$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | $boolean$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type float<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | float$SelectionSet<_$Scalars>

  export interface float$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`float\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type float$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | float$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type int<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>

  export interface int$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $string<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | $string$SelectionSet<_$Scalars>

  export interface $string$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$string\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $string$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | $string$SelectionSet<_$Scalars>
  >
}

//                                    Object1ImplementingInterface
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Object1ImplementingInterface<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`Object1ImplementingInterface\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?:
    | Object1ImplementingInterface.id$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Object1ImplementingInterface.id<_$Scalars>>
  /**
   * Select the \`int\` field on the \`Object1ImplementingInterface\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  int?:
    | Object1ImplementingInterface.int$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Object1ImplementingInterface.int<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Object1ImplementingInterface$FragmentInline<_$Scalars>
    | Object1ImplementingInterface$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object1ImplementingInterface$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Object1ImplementingInterface<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Object1ImplementingInterface {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type int<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>

  export interface int$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>
  >
}

//                                    Object2ImplementingInterface
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface Object2ImplementingInterface<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`boolean\` field on the \`Object2ImplementingInterface\` object. Its type is \`Boolean\` (a \`ScalarStandard\` kind of type).
   */
  boolean?:
    | Object2ImplementingInterface.$boolean$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Object2ImplementingInterface.$boolean<_$Scalars>>
  /**
   * Select the \`id\` field on the \`Object2ImplementingInterface\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?:
    | Object2ImplementingInterface.id$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<Object2ImplementingInterface.id<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Object2ImplementingInterface$FragmentInline<_$Scalars>
    | Object2ImplementingInterface$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object2ImplementingInterface$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Object2ImplementingInterface<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace Object2ImplementingInterface {
  export type $boolean<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > =
    | $Select.Indicator.NoArgsIndicator
    | $boolean$SelectionSet<_$Scalars>

  export interface $boolean$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$boolean\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $boolean$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | $boolean$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >
}

//                                            ObjectChildA
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectChildA<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`a\` field on the \`ObjectChildA\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  a?: ObjectChildA.a$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildA.a<_$Scalars>>
  /**
   * Select the \`b\` field on the \`ObjectChildA\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  b?: ObjectChildA.b$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildA.b<_$Scalars>>
  /**
   * Select the \`c1\` field on the \`ObjectChildA\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  c1?: ObjectChildA.c1$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildA.c1<_$Scalars>>
  /**
   * Select the \`me\` field on the \`ObjectChildA\` object. Its type is \`Boolean\` (a \`ScalarStandard\` kind of type).
   */
  me?: ObjectChildA.me$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildA.me<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectChildA$FragmentInline<_$Scalars>
    | ObjectChildA$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectChildA$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectChildA<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectChildA {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type c1<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | c1$SelectionSet<_$Scalars>

  export interface c1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`c1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type c1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | c1$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type me<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>

  export interface me$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`me\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type me$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>
  >
}

//                                            ObjectChildB
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectChildB<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`a\` field on the \`ObjectChildB\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  a?: ObjectChildB.a$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildB.a<_$Scalars>>
  /**
   * Select the \`b\` field on the \`ObjectChildB\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  b?: ObjectChildB.b$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildB.b<_$Scalars>>
  /**
   * Select the \`c2\` field on the \`ObjectChildB\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  c2?: ObjectChildB.c2$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildB.c2<_$Scalars>>
  /**
   * Select the \`me\` field on the \`ObjectChildB\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  me?: ObjectChildB.me$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectChildB.me<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectChildB$FragmentInline<_$Scalars>
    | ObjectChildB$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectChildB$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectChildB<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectChildB {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type c2<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | c2$SelectionSet<_$Scalars>

  export interface c2$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`c2\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type c2$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | c2$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type me<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>

  export interface me$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`me\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type me$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>
  >
}

//                                         ObjectGrandparent
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectGrandparent<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`a\` field on the \`ObjectGrandparent\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  a?: ObjectGrandparent.a$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectGrandparent.a<_$Scalars>>
  /**
   * Select the \`me\` field on the \`ObjectGrandparent\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  me?: ObjectGrandparent.me$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectGrandparent.me<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectGrandparent$FragmentInline<_$Scalars>
    | ObjectGrandparent$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectGrandparent$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectGrandparent<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectGrandparent {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type me<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>

  export interface me$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`me\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type me$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>
  >
}

//                                            ObjectNested
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectNested<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`ObjectNested\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: ObjectNested.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectNested.id<_$Scalars>>
  /**
   * Select the \`object\` field on the \`ObjectNested\` object. Its type is \`Object1\` (a \`OutputObject\` kind of type).
   */
  object?: ObjectNested.$object$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectNested.$object<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectNested$FragmentInline<_$Scalars>
    | ObjectNested$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectNested$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectNested<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectNested {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type $object<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    $object$SelectionSet<_$Scalars>

  export interface $object$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$Object1<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`$object\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $object$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    $object$SelectionSet<_$Scalars>
  >
}

//                                            ObjectParent
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectParent<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`a\` field on the \`ObjectParent\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  a?: ObjectParent.a$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectParent.a<_$Scalars>>
  /**
   * Select the \`b\` field on the \`ObjectParent\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  b?: ObjectParent.b$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectParent.b<_$Scalars>>
  /**
   * Select the \`me\` field on the \`ObjectParent\` object. Its type is \`String\` (a \`ScalarStandard\` kind of type).
   */
  me?: ObjectParent.me$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<ObjectParent.me<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectParent$FragmentInline<_$Scalars>
    | ObjectParent$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectParent$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectParent<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectParent {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >

  // --------------------------------------------------------------------------------------------------

  export type me<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>

  export interface me$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`me\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type me$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | me$SelectionSet<_$Scalars>
  >
}

//                                            ObjectUnion
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectUnion<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`fooBarUnion\` field on the \`ObjectUnion\` object. Its type is \`FooBarUnion\` (a \`Union\` kind of type).
   */
  fooBarUnion?:
    | ObjectUnion.fooBarUnion$Expanded<_$Scalars>
    | $Select.SelectAlias.SelectAlias<ObjectUnion.fooBarUnion<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | ObjectUnion$FragmentInline<_$Scalars>
    | ObjectUnion$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectUnion$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends ObjectUnion<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace ObjectUnion {
  export type fooBarUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = fooBarUnion$SelectionSet<_$Scalars>

  export interface fooBarUnion$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base, $NamedTypes.$FooBarUnion<_$Scalars> {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`fooBarUnion\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type fooBarUnion$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    fooBarUnion$SelectionSet<_$Scalars>
  >
}

//                                          lowerCaseObject
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface lowerCaseObject<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`lowerCaseObject\` object. Its type is \`ID\` (a \`ScalarStandard\` kind of type).
   */
  id?: lowerCaseObject.id$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<lowerCaseObject.id<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | lowerCaseObject$FragmentInline<_$Scalars>
    | lowerCaseObject$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface lowerCaseObject$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends lowerCaseObject<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace lowerCaseObject {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >
}

//                                          lowerCaseObject2
// --------------------------------------------------------------------------------------------------
//

// ----------------------------------------| Entrypoint Interface |

export interface lowerCaseObject2<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  /**
   * Select the \`int\` field on the \`lowerCaseObject2\` object. Its type is \`Int\` (a \`ScalarStandard\` kind of type).
   */
  int?: lowerCaseObject2.int$Expanded<_$Scalars> | $Select.SelectAlias.SelectAlias<lowerCaseObject2.int<_$Scalars>>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | lowerCaseObject2$FragmentInline<_$Scalars>
    | lowerCaseObject2$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface lowerCaseObject2$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends lowerCaseObject2<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

// ----------------------------------------| Fields |

export namespace lowerCaseObject2 {
  export type int<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>

  export interface int$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | int$SelectionSet<_$Scalars>
  >
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

export interface DateUnion<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>

  ___on_DateObject1?: DateObject1<_$Scalars>
  ___on_DateObject2?: DateObject2<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | DateUnion$FragmentInline<_$Scalars>
    | DateUnion$FragmentInline<_$Scalars>[]
}
export interface DateUnion$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends DateUnion<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

/**
 * Union documentation.
 */
export interface FooBarUnion<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>

  ___on_Bar?: Bar<_$Scalars>
  ___on_Foo?: Foo<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | FooBarUnion$FragmentInline<_$Scalars>
    | FooBarUnion$FragmentInline<_$Scalars>[]
}
export interface FooBarUnion$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends FooBarUnion<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export interface Result<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>

  ___on_ErrorOne?: ErrorOne<_$Scalars>
  ___on_ErrorTwo?: ErrorTwo<_$Scalars>
  ___on_Object1?: Object1<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Result$FragmentInline<_$Scalars>
    | Result$FragmentInline<_$Scalars>[]
}
export interface Result$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Result<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export interface lowerCaseUnion<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> {
  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>

  ___on_lowerCaseObject?: lowerCaseObject<_$Scalars>
  ___on_lowerCaseObject2?: lowerCaseObject2<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | lowerCaseUnion$FragmentInline<_$Scalars>
    | lowerCaseUnion$FragmentInline<_$Scalars>[]
}
export interface lowerCaseUnion$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends lowerCaseUnion<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

//                                           DateInterface1
// --------------------------------------------------------------------------------------------------
//

export interface DateInterface1<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  date1?: DateInterface1.date1<_$Scalars>
  ___on_DateObject1?: DateObject1<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | DateInterface1$FragmentInline<_$Scalars>
    | DateInterface1$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateInterface1$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends DateInterface1<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace DateInterface1 {
  export type date1<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | date1$SelectionSet<_$Scalars>

  export interface date1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`date1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | date1$SelectionSet<_$Scalars>
  >
}

//                                               Error
// --------------------------------------------------------------------------------------------------
//

export interface Error<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty>
  extends $Select.Bases.ObjectLike
{
  message?: Error.message<_$Scalars>
  ___on_ErrorOne?: ErrorOne<_$Scalars>
  ___on_ErrorTwo?: ErrorTwo<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Error$FragmentInline<_$Scalars>
    | Error$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Error$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Error<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace Error {
  export type message<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>

  export interface message$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | message$SelectionSet<_$Scalars>
  >
}

//                                             Interface
// --------------------------------------------------------------------------------------------------
//

export interface Interface<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  id?: Interface.id<_$Scalars>
  ___on_Object1ImplementingInterface?: Object1ImplementingInterface<_$Scalars>
  ___on_Object2ImplementingInterface?: Object2ImplementingInterface<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | Interface$FragmentInline<_$Scalars>
    | Interface$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Interface$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends Interface<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace Interface {
  export type id<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>

  export interface id$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | id$SelectionSet<_$Scalars>
  >
}

//                                          InterfaceChildA
// --------------------------------------------------------------------------------------------------
//

export interface InterfaceChildA<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  a?: InterfaceChildA.a<_$Scalars>
  b?: InterfaceChildA.b<_$Scalars>
  c1?: InterfaceChildA.c1<_$Scalars>
  ___on_ObjectChildA?: ObjectChildA<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | InterfaceChildA$FragmentInline<_$Scalars>
    | InterfaceChildA$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface InterfaceChildA$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends InterfaceChildA<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace InterfaceChildA {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >

  export type c1<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | c1$SelectionSet<_$Scalars>

  export interface c1$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`c1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type c1$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | c1$SelectionSet<_$Scalars>
  >
}

//                                          InterfaceChildB
// --------------------------------------------------------------------------------------------------
//

export interface InterfaceChildB<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  a?: InterfaceChildB.a<_$Scalars>
  b?: InterfaceChildB.b<_$Scalars>
  c2?: InterfaceChildB.c2<_$Scalars>
  ___on_ObjectChildB?: ObjectChildB<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | InterfaceChildB$FragmentInline<_$Scalars>
    | InterfaceChildB$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface InterfaceChildB$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends InterfaceChildB<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace InterfaceChildB {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >

  export type c2<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | c2$SelectionSet<_$Scalars>

  export interface c2$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`c2\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type c2$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | c2$SelectionSet<_$Scalars>
  >
}

//                                        InterfaceGrandparent
// --------------------------------------------------------------------------------------------------
//

export interface InterfaceGrandparent<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  a?: InterfaceGrandparent.a<_$Scalars>
  ___on_ObjectChildA?: ObjectChildA<_$Scalars>
  ___on_ObjectChildB?: ObjectChildB<_$Scalars>
  ___on_ObjectGrandparent?: ObjectGrandparent<_$Scalars>
  ___on_ObjectParent?: ObjectParent<_$Scalars>
  ___on_InterfaceChildA?: InterfaceChildA<_$Scalars>
  ___on_InterfaceChildB?: InterfaceChildB<_$Scalars>
  ___on_InterfaceParent?: InterfaceParent<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | InterfaceGrandparent$FragmentInline<_$Scalars>
    | InterfaceGrandparent$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface InterfaceGrandparent$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends InterfaceGrandparent<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace InterfaceGrandparent {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >
}

//                                          InterfaceParent
// --------------------------------------------------------------------------------------------------
//

export interface InterfaceParent<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends $Select.Bases.ObjectLike {
  a?: InterfaceParent.a<_$Scalars>
  b?: InterfaceParent.b<_$Scalars>
  ___on_ObjectChildA?: ObjectChildA<_$Scalars>
  ___on_ObjectChildB?: ObjectChildB<_$Scalars>
  ___on_ObjectParent?: ObjectParent<_$Scalars>
  ___on_InterfaceChildA?: InterfaceChildA<_$Scalars>
  ___on_InterfaceChildB?: InterfaceChildB<_$Scalars>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?:
    | InterfaceParent$FragmentInline<_$Scalars>
    | InterfaceParent$FragmentInline<_$Scalars>[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface InterfaceParent$FragmentInline<
  _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
> extends InterfaceParent<_$Scalars>, $Select.Directive.$Groups.InlineFragment.Fields {
}

export namespace InterfaceParent {
  export type a<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>

  export interface a$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`a\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type a$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | a$SelectionSet<_$Scalars>
  >

  export type b<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>

  export interface b$SelectionSet<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > extends $Select.Bases.Base {}

  // --- expanded ---

  /**
   * This is the "expanded" version of the \`b\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type b$Expanded<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = $$Utilities.Simplify<
    | $Select.Indicator.NoArgsIndicator
    | b$SelectionSet<_$Scalars>
  >
}

/**
 * [1] These definitions serve to allow field selection interfaces to extend their respective object type without
 *     name clashing between the field name and the object name.
 *
 *     For example imagine \`Query.Foo\` field with type also called \`Foo\`. Our generated interfaces for each field
 *     would end up with an error of \`export interface Foo extends Foo ...\`
 */
export namespace $NamedTypes {
  export type $Query<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    Query<_$Scalars>
  export type $Mutation<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = Mutation<_$Scalars>
  export type $ABCEnum = ABCEnum
  export type $Case = Case
  export type $ChildAInterfaceHierarchyMember = ChildAInterfaceHierarchyMember
  export type $ChildBInterfaceHierarchyMember = ChildBInterfaceHierarchyMember
  export type $GrandparentInterfaceHierarchyMember = GrandparentInterfaceHierarchyMember
  export type $ParentInterfaceHierarchyMember = ParentInterfaceHierarchyMember
  export type $InputObject<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InputObject<_$Scalars>
  export type $InputObjectCircular<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InputObjectCircular<_$Scalars>
  export type $InputObjectNested<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InputObjectNested<_$Scalars>
  export type $InputObjectNestedNonNull<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InputObjectNestedNonNull<_$Scalars>
  export type $Bar<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    Bar<_$Scalars>
  export type $DateObject1<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = DateObject1<_$Scalars>
  export type $DateObject2<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = DateObject2<_$Scalars>
  export type $ErrorOne<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ErrorOne<_$Scalars>
  export type $ErrorTwo<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ErrorTwo<_$Scalars>
  export type $Foo<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    Foo<_$Scalars>
  export type $Object1<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = Object1<_$Scalars>
  export type $Object1ImplementingInterface<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = Object1ImplementingInterface<_$Scalars>
  export type $Object2ImplementingInterface<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = Object2ImplementingInterface<_$Scalars>
  export type $ObjectChildA<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectChildA<_$Scalars>
  export type $ObjectChildB<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectChildB<_$Scalars>
  export type $ObjectGrandparent<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectGrandparent<_$Scalars>
  export type $ObjectNested<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectNested<_$Scalars>
  export type $ObjectParent<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectParent<_$Scalars>
  export type $ObjectUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = ObjectUnion<_$Scalars>
  export type $lowerCaseObject<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = lowerCaseObject<_$Scalars>
  export type $lowerCaseObject2<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = lowerCaseObject2<_$Scalars>
  export type $DateUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = DateUnion<_$Scalars>
  export type $FooBarUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = FooBarUnion<_$Scalars>
  export type $Result<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    Result<_$Scalars>
  export type $lowerCaseUnion<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = lowerCaseUnion<_$Scalars>
  export type $DateInterface1<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = DateInterface1<_$Scalars>
  export type $Error<_$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty> =
    Error<_$Scalars>
  export type $Interface<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = Interface<_$Scalars>
  export type $InterfaceChildA<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InterfaceChildA<_$Scalars>
  export type $InterfaceChildB<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InterfaceChildB<_$Scalars>
  export type $InterfaceGrandparent<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InterfaceGrandparent<_$Scalars>
  export type $InterfaceParent<
    _$Scalars extends $$Utilities.Schema.Scalar.Registry = $$Utilities.Schema.Scalar.Registry.Empty,
  > = InterfaceParent<_$Scalars>
}
"
`;

exports[`root-types-mapped 1`] = `
"import * as $$Data from "./data.js";
import * as $$Scalar from "./scalar.js";
import type { Schema as $ } from "graffle/utilities-for-generated";
import type * as $$Utilities from "graffle/utilities-for-generated";

export namespace Schema {
  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Root
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                             QueryRoot
  // --------------------------------------------------------------------------------------------------
  //

  export interface QueryRoot extends $.OutputObject {
    name: "QueryRoot";
    fields: {
      __typename: QueryRoot.__typename;
      id: QueryRoot.id;
    };
  }

  export namespace QueryRoot {
    export interface __typename extends $.OutputField {
      name: "__typename";
      arguments: {};
      inlineType: [1];
      namedType: {
        kind: "__typename";
        value: "QueryRoot";
      };
    }

    export interface id extends $.OutputField {
      name: "id";
      arguments: {};
      inlineType: [0];
      namedType: $$NamedTypes.$$ID;
    }
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            OutputObject
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            InputObject
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                             Interface
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                               Union
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Enum
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            ScalarCustom
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                           ScalarStandard
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  //                                                 ID
  // --------------------------------------------------------------------------------------------------
  //

  export type ID = $.StandardTypes.ID;

  //                                              Boolean
  // --------------------------------------------------------------------------------------------------
  //

  export type Boolean = $.StandardTypes.Boolean;

  //                                               String
  // --------------------------------------------------------------------------------------------------
  //

  export type String = $.StandardTypes.String;

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                         Named Types Index
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  /**
   * [1] These definitions serve to allow field selection interfaces to extend their respective object type without
   *     name clashing between the field name and the object name.
   *
   *     For example imagine \`Query.Foo\` field with type also called \`Foo\`. Our generated interfaces for each field
   *     would end up with an error of \`export interface Foo extends Foo ...\`
   */

  namespace $$NamedTypes {
    export type $$QueryRoot = QueryRoot;
    export type $$ID = ID;
    export type $$Boolean = Boolean;
    export type $$String = String;
  }
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Schema
// ==================================================================================================
//
//
//
//
//
//

export interface Schema<
  $Scalars extends $$Utilities.Schema.Scalar.Registry = $$Scalar.$Registry,
> extends $ {
  name: $$Data.Name;
  operationsAvailable: ["query"];
  RootUnion: Schema.QueryRoot;
  Root: {
    query: Schema.QueryRoot;
    mutation: null;
    subscription: null;
  };
  allTypes: {
    QueryRoot: Schema.QueryRoot;
  };
  objects: {};
  unions: {};
  interfaces: {};
  scalarNamesUnion: "ID" | "Boolean" | "String";
  scalars: {
    ID: Schema.ID;
    Boolean: Schema.Boolean;
    String: Schema.String;
  };
  scalarRegistry: $Scalars;
  extensions: $$Utilities.GlobalRegistry.TypeExtensions;
}
"
`;

exports[`root-types-mapped 2`] = `
"import * as $$SelectionSets from "./selection-sets.js";
import * as $$Schema from "./schema.js";
import type * as $$Utilities from "graffle/utilities-for-generated";
import type { InferResult } from "graffle/schema";

export interface QueryRootMethods<$Context extends $$Utilities.Context> {
  $batch: <$SelectionSet>(
    selectionSet: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.QueryRoot<$Context["scalars"]>
    >,
  ) => Promise<
    (null | {}) &
      $$Utilities.HandleOutput<
        $Context,
        InferResult.OperationQuery<
          $$Utilities.AssertExtendsObject<$SelectionSet>,
          $$Schema.Schema<$Context["scalars"]>
        >
      >
  >;
  __typename: () => Promise<
    (null | {}) &
      $$Utilities.HandleOutputGraffleRootField<
        $Context,
        { __typename: "QueryRoot" },
        "__typename"
      >
  >;

  id: <$SelectionSet>(
    selectionSet?: $$Utilities.Exact<
      $SelectionSet,
      $$SelectionSets.QueryRoot.id<$Context["scalars"]>
    >,
  ) => Promise<
    (null | {}) &
      $$Utilities.HandleOutputGraffleRootField<
        $Context,
        InferResult.OperationQuery<
          { id: $SelectionSet },
          $$Schema.Schema<$Context["scalars"]>
        >,
        "id"
      >
  >;
}

export interface BuilderMethodsRoot<$Context extends $$Utilities.Context> {
  undefined: QueryRootMethods<$Context>;
}

export interface BuilderMethodsRootFn extends $$Utilities.TypeFunction {
  // @ts-expect-error parameter is Untyped.
  return: BuilderMethodsRoot<this["params"]>;
}
"
`;
