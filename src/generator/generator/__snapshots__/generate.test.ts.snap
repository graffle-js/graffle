// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`custom scalars module results in client prefilling those custom scalars 1`] = `
"import type * as $$Utilities from "graffle/utilities-for-generated";

import * as CustomScalars from "../../scalars.js";

//
//
//
//
// CUSTOM SCALAR TYPE
// DATE
// --------------------------------------------------------------------------------------------------
//                                                Date
// --------------------------------------------------------------------------------------------------
//
//

/**
 * Custom scalar codec for the \`Date\` type.
 *
 * Handles encoding (TypeScript → GraphQL) and decoding (GraphQL → TypeScript)
 * transformations for this custom scalar.
 */
export const Date = CustomScalars.Date;
export type Date = typeof CustomScalars.Date;
/**
 * The decoded (TypeScript-side) type for the \`Date\` scalar.
 *
 * This is the type you work with in your application code after the scalar
 * has been decoded from its GraphQL wire format.
 */
export type DateDecoded = $$Utilities.Schema.Scalar.GetDecoded<Date>;
/**
 * The encoded (GraphQL wire format) type for the \`Date\` scalar.
 *
 * This is the type used when transmitting the scalar value over the network.
 */
export type DateEncoded = $$Utilities.Schema.Scalar.GetEncoded<Date>;

export * from "graffle/generator-helpers/standard-scalar-types";

//
//
//
//
//
//
// ==================================================================================================
//                                              Registry
// ==================================================================================================
//
//
//
//
//
//

/**
 * Runtime registry of custom scalar codecs.
 *
 * Maps scalar type names to their codec implementations for encoding/decoding.
 */

export const $registry = {
  map: {
    Date: CustomScalars.Date,
  },
} as $Registry;

/**
 * Type-level registry of custom scalars.
 *
 * Provides type information about custom scalars for the type system.
 */
export type $Registry = $$Utilities.Schema.Scalar.Registry<
  {
    Date: Date;
  },
  $$Utilities.Schema.Scalar.GetEncoded<Date>,
  $$Utilities.Schema.Scalar.GetDecoded<Date>
>;
"
`;

exports[`root-types-mapped 1`] = `
"import type * as $ from "graffle/utilities-for-generated";
import * as $$Data from "../data.js";
import * as $$Scalar from "../scalar.js";
import * as $Types from "./$$.js";

export * as Schema from "./$$.js";

export interface Schema<
  $Scalars extends $.Schema.Scalar.Registry = $$Scalar.$Registry,
> {
  name: $$Data.Name;
  operationsAvailable: ["query"];
  RootUnion: $Types.RootTypeCustomNameForQuery;
  Root: {
    query: $Types.RootTypeCustomNameForQuery;
    mutation: null;
    subscription: null;
  };
  allTypes: {
    RootTypeCustomNameForQuery: $Types.RootTypeCustomNameForQuery;
  };
  objects: {};
  unions: {};
  interfaces: {};
  scalarNamesUnion: "ID" | "Boolean" | "String";
  scalars: {
    ID: $Types.ID;
    Boolean: $Types.Boolean;
    String: $Types.String;
  };
  scalarRegistry: $Scalars;
  extensions: $.GlobalRegistry.TypeExtensions;
}
"
`;

exports[`root-types-mapped 2`] = `
"import type * as $$SelectionSets from "./selection-sets/$.js";
import type * as $$Schema from "./schema/$.js";
import type * as $$Utilities from "graffle/utilities-for-generated";
import type * as $$ArgumentsMap from "./arguments-map.js";

/**
 * GraphQL {@link https://graphql.org/learn/schema/#the-query-and-mutation-types | Query} root methods.
 *
 * All methods return Promises. Use \`.query.$batch(...)\` to select multiple fields at once.
 */
export interface RootTypeCustomNameForQueryMethods<
  $Context extends $$Utilities.Context,
> {
  /**
   * Select multiple Query fields at once.
   *
   * Pass a selection set object that includes the fields you want.
   * Use this method to request multiple fields in a single request for better performance.
   */

  $batch: $$Utilities.GraffleKit.Context.Configuration.Check.Preflight<
    $Context,
    <$SelectionSet>(
      selectionSet: $$Utilities.Exact<
        $SelectionSet,
        $$SelectionSets.RootTypeCustomNameForQuery<{
          scalars: $Context["scalars"];
        }>
      >,
    ) => $$Utilities.Docpar.Object.Var.MethodReturn<
      $$Utilities.Docpar.Object.Var.InferFromQuery<
        $$Utilities.AssertExtendsObject<$SelectionSet>,
        $$ArgumentsMap.ArgumentsMap
      >,
      (null | {}) &
        $$Utilities.HandleOutput<
          $Context,
          $$Utilities.Docpar.Object.InferResult.OperationQuery<
            $$Utilities.AssertExtendsObject<$SelectionSet>,
            $$Schema.Schema<$Context["scalars"]>
          >
        >,
      $$Utilities.DocumentRunnerDeferred<
        $$Utilities.Docpar.Object.Var.InferFromQuery<
          $$Utilities.AssertExtendsObject<$SelectionSet>,
          $$ArgumentsMap.ArgumentsMap
        >,
        (null | {}) &
          $$Utilities.HandleOutput<
            $Context,
            $$Utilities.Docpar.Object.InferResult.OperationQuery<
              $$Utilities.AssertExtendsObject<$SelectionSet>,
              $$Schema.Schema<$Context["scalars"]>
            >
          >
      >
    >
  >;

  /**
   * Request the {@link https://graphql.org/learn/schema/#the-__typename-field | __typename} meta-field.
   *
   * The \`__typename\` field returns the name of the object type. In this case, it will always return \`"RootTypeCustomNameForQuery"\`.
   */

  __typename: $$Utilities.GraffleKit.Context.Configuration.Check.Preflight<
    $Context,
    () => Promise<
      (null | {}) &
        $$Utilities.HandleOutputDocumentBuilderRootField<
          $Context,
          { __typename: "RootTypeCustomNameForQuery" },
          "__typename"
        >
    >
  >;
  /**
   * \`\`\`graphql
   * id: ID
   * \`\`\`
   *
   * # Info
   *
   * | | |
   * | - | - |
   * | **Type** | {@link $Schema.ID} |
   * | **Kind** | {@link https://graphql.org/graphql-js/type/#scalars | ScalarStandard ↗} |
   * | **Parent** | {@link $Schema.RootTypeCustomNameForQuery} |
   * | **Path** | \`RootTypeCustomNameForQuery.id\` |
   * | **Nullability** | Optional |
   */

  id: $$Utilities.GraffleKit.Context.Configuration.Check.Preflight<
    $Context,
    <$SelectionSet>(
      selectionSet?: $$Utilities.Exact<
        $SelectionSet,
        $$SelectionSets.RootTypeCustomNameForQuery.id<{
          scalars: $Context["scalars"];
        }>
      >,
    ) => $$Utilities.Docpar.Object.Var.MethodReturn<
      $$Utilities.Docpar.Object.Var.InferFromQuery<
        { id: $SelectionSet },
        $$ArgumentsMap.ArgumentsMap
      >,
      (null | {}) &
        $$Utilities.HandleOutputDocumentBuilderRootField<
          $Context,
          $$Utilities.Docpar.Object.InferResult.OperationQuery<
            { id: $SelectionSet },
            $$Schema.Schema<$Context["scalars"]>
          >,
          "id"
        >,
      $$Utilities.DocumentRunnerDeferred<
        $$Utilities.Docpar.Object.Var.InferFromQuery<
          { id: $SelectionSet },
          $$ArgumentsMap.ArgumentsMap
        >,
        (null | {}) &
          $$Utilities.HandleOutputDocumentBuilderRootField<
            $Context,
            $$Utilities.Docpar.Object.InferResult.OperationQuery<
              { id: $SelectionSet },
              $$Schema.Schema<$Context["scalars"]>
            >,
            "id"
          >
      >
    >
  >;
}

export interface BuilderMethodsRoot<$Context extends $$Utilities.Context> {
  /**
   * Access to {@link https://graphql.org/learn/schema/#the-query-and-mutation-types | Query} root field methods.
   *
   * Each method corresponds to a root field on the GraphQL schema and returns a Promise.
   * Use \`.$batch(...)\` to select multiple query fields in a single request.
   *
   * @example Single field
   * \`\`\`ts
   * const user = await graffle.query.user({ id: true, name: true })
   * \`\`\`
   * @example Multiple fields with $batch
   * \`\`\`ts
   * const data = await graffle.query.$batch({
   * user: { id: true, name: true },
   * posts: { title: true, content: true }
   * })
   * \`\`\`
   */
  query: RootTypeCustomNameForQueryMethods<$Context>;
}

export interface BuilderMethodsRootFn extends $$Utilities.Kind.Kind {
  // @ts-expect-error parameter is Untyped.
  return: BuilderMethodsRoot<this["parameters"]>;
}
"
`;

exports[`schema with long type name 1`] = `
"import type * as $ from "graffle/utilities-for-generated";
import * as $$Data from "../data.js";
import * as $$Scalar from "../scalar.js";
import * as $Types from "./$$.js";

export * as Schema from "./$$.js";

export interface Schema<
  $Scalars extends $.Schema.Scalar.Registry = $$Scalar.$Registry,
> {
  name: $$Data.Name;
  operationsAvailable: ["query"];
  RootUnion: $Types.Query;
  Root: {
    query: $Types.Query;
    mutation: null;
    subscription: null;
  };
  allTypes: {
    Query: $Types.Query;
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: $Types.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;
  };
  objects: {
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: $Types.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;
  };
  unions: {};
  interfaces: {};
  scalarNamesUnion: "ID" | "Boolean" | "String";
  scalars: {
    ID: $Types.ID;
    Boolean: $Types.Boolean;
    String: $Types.String;
  };
  scalarRegistry: $Scalars;
  extensions: $.GlobalRegistry.TypeExtensions;
}
"
`;
