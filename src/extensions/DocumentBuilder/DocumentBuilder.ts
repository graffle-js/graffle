import { Extension } from '#graffle/extension'
import type { GlobalRegistry, Kind } from '#graffle/utilities-for-generated'
import { OperationTypeNode } from 'graphql'
import { createMethodOperationType } from './methods-instance/requestMethods.js'

export type ConfigurationInput = {
  /**
   * Domain organization modules generated by Graffle.
   * Each domain provides methods grouped by resource/entity.
   */
  domains?: Record<string, Record<string, (context: any) => any>> | undefined
}

export const DocumentBuilder = Extension
  .create(`DocumentBuilder`)
  .configurator(
    Extension.Configurator.create()
      .input<ConfigurationInput>()
      .normalized<ConfigurationInput>()
      .default({ domains: undefined })
      .inputResolver(({ current, input }) => ({
        domains: input.domains ?? current.domains,
      })),
  )
  // todo add an extensions unit test that this adds properties to the context
  .properties(({ context, configuration }) => {
    const props: any = {
      query: createMethodOperationType(context, OperationTypeNode.QUERY),
      mutation: createMethodOperationType(context, OperationTypeNode.MUTATION),
    }

    // Add domain namespaces if configured
    const domains = configuration.DocumentBuilder?.current?.domains
    if (domains) {
      for (const [namespaceName, namespaceMethods] of Object.entries(domains)) {
        // Create namespace object with methods bound to context
        const boundMethods: any = {}
        for (const [methodName, methodFactory] of Object.entries(namespaceMethods)) {
          // Each method is a factory that takes context and returns the actual method
          boundMethods[methodName] = methodFactory(context)
        }
        props[namespaceName] = boundMethods
      }
    }

    return props as any as Properties
  })
  .return()

export interface Properties extends Extension.PropertiesTypeFunction {
  // @ts-expect-error
  return: Properties_<this['parameters']>
}

type Properties_<
  $Parameters extends Extension.PropertiesTypeFunctionParameters,
  __Name extends string = $Parameters['context']['configuration']['schema']['current']['name'],
> =
  // todo
  // GlobalRegistry.Has<$Context['name']> extends false

  // @ts-ignore passes after generation
  GlobalRegistry.Has<__Name> extends false ? {}
    : (
      // @ts-ignore Passes after generation
      Kind.Apply<GlobalRegistry.GetOrDefault<__Name>['interfaces']['Root'], $Parameters['context']>
    )
