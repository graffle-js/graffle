// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`kitchen-sink generated modules > _.ts 1`] = `
"// We import the global module for good measure although it is not clear it is always needed.
// It at least helps with Twoslash wherein without this import here Twoslash will not include the global module.
// In real TypeScript projects it seems the global module is included automatically. But there could be certain tsconfig
// setups where this still indeed does help.
import './modules/Global.js'

export { create } from './modules/Client.js'
export { schemaDrivenDataMap } from './modules/SchemaDrivenDataMap.js'
export { Select } from './modules/Select.js'
export * as SelectionSets from './modules/SelectionSets.js'
"
`;

exports[`kitchen-sink generated modules > __.ts 1`] = `
"export * as Graffle from './_.js'
"
`;

exports[`kitchen-sink generated modules > modules/Client.ts 1`] = `
"import { createPrefilled } from '../../../../../../src/entrypoints/client.js'
import { defaultSchemaUrl } from './Data.js'
import { Name } from './Data.js'
import { schemaDrivenDataMap } from './SchemaDrivenDataMap.js'

export const create = createPrefilled(Name, schemaDrivenDataMap, defaultSchemaUrl)
"
`;

exports[`kitchen-sink generated modules > modules/Data.ts 1`] = `
"export const Name = \`default\`
export type Name = 'default'

export const defaultSchemaUrl = undefined
"
`;

exports[`kitchen-sink generated modules > modules/Global.ts 1`] = `
"import type * as Data from './Data.js'
import type * as MethodsDocument from './MethodsDocument.js'
import type * as MethodsRoot from './MethodsRoot.js'
import type * as MethodsSelect from './MethodsSelect.js'
import type * as Scalar from './Scalar.js'
import type { Schema } from './Schema.js'

declare global {
  export namespace GraffleGlobal {
    export interface Schemas {
      default: {
        name: Data.Name
        index: Schema
        interfaces: {
          MethodsSelect: MethodsSelect.$MethodsSelect
          Document: MethodsDocument.BuilderMethodsDocumentFn
          Root: MethodsRoot.BuilderMethodsRootFn
        }
        customScalars: {
          Date: Scalar.Date
        }
        defaultSchemaUrl: null
      }
    }
  }
}
"
`;

exports[`kitchen-sink generated modules > modules/MethodsDocument.ts 1`] = `
"import type * as Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type { Schema } from './Schema.js'
import type * as SelectionSets from './SelectionSets.js'

export interface Document<$Config extends Utilities.Config> {
  <$Document>(document: Utilities.ExactNonEmpty<$Document, SelectionSets.$Document>): Utilities.DocumentRunner<
    $Config,
    Schema,
    // @ts-expect-error We use Exact instead of constraint on this function. TypeScript does not see that as
    // Satisfying the constraint on the DocumentRunner type.
    $Document
  >
}

export interface BuilderMethodsDocumentFn extends Utilities.TypeFunction.Fn {
  // @ts-expect-error parameter is Untyped.
  return: Document<this['params']['config']>
}
"
`;

exports[`kitchen-sink generated modules > modules/MethodsRoot.ts 1`] = `
"import { type Simplify } from 'type-fest'
import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import type * as Utils from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type { Schema } from './Schema.js'
import type * as SelectionSet from './SelectionSets.js'

export interface MutationMethods<$Config extends Utils.Config> {
  // todo Use a static type here?
  $batch: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Mutation>) => Promise<
    Simplify<
      Utils.HandleOutput<
        $Config,
        InferResult.Mutation<$SelectionSet, Schema>
      >
    >
  >
  // todo Use a static type here?
  __typename: () => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        { __typename: 'Mutation' },
        '__typename'
      >
    >
  >
  id: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Mutation.id>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Mutation<{ id: $SelectionSet }, Schema>,
        'id'
      >
    >
  >
  idNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Mutation.idNonNull>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Mutation<{ idNonNull: $SelectionSet }, Schema>,
        'idNonNull'
      >
    >
  >
}

export interface QueryMethods<$Config extends Utils.Config> {
  // todo Use a static type here?
  $batch: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query>) => Promise<
    Simplify<
      Utils.HandleOutput<
        $Config,
        InferResult.Query<$SelectionSet, Schema>
      >
    >
  >
  // todo Use a static type here?
  __typename: () => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        { __typename: 'Query' },
        '__typename'
      >
    >
  >
  InputObjectNested: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.InputObjectNested>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ InputObjectNested: $SelectionSet }, Schema>,
        'InputObjectNested'
      >
    >
  >
  InputObjectNestedNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.InputObjectNestedNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ InputObjectNestedNonNull: $SelectionSet }, Schema>,
        'InputObjectNestedNonNull'
      >
    >
  >
  /**
   * Query enum field documentation.
   */
  abcEnum: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.abcEnum>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ abcEnum: $SelectionSet }, Schema>,
        'abcEnum'
      >
    >
  >
  argInputObjectCircular: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.argInputObjectCircular>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ argInputObjectCircular: $SelectionSet }, Schema>,
        'argInputObjectCircular'
      >
    >
  >
  date: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.date>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ date: $SelectionSet }, Schema>,
        'date'
      >
    >
  >
  dateArg: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArg>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArg: $SelectionSet }, Schema>,
        'dateArg'
      >
    >
  >
  dateArgInputObject: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgInputObject>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArgInputObject: $SelectionSet }, Schema>,
        'dateArgInputObject'
      >
    >
  >
  dateArgList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgList>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArgList: $SelectionSet }, Schema>,
        'dateArgList'
      >
    >
  >
  dateArgNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArgNonNull: $SelectionSet }, Schema>,
        'dateArgNonNull'
      >
    >
  >
  dateArgNonNullList: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNullList>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArgNonNullList: $SelectionSet }, Schema>,
        'dateArgNonNullList'
      >
    >
  >
  dateArgNonNullListNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNullListNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateArgNonNullListNonNull: $SelectionSet }, Schema>,
        'dateArgNonNullListNonNull'
      >
    >
  >
  dateInterface1: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateInterface1>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateInterface1: $SelectionSet }, Schema>,
        'dateInterface1'
      >
    >
  >
  dateList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateList>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateList: $SelectionSet }, Schema>,
        'dateList'
      >
    >
  >
  dateListList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateListList>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateListList: $SelectionSet }, Schema>,
        'dateListList'
      >
    >
  >
  dateListNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateListNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateListNonNull: $SelectionSet }, Schema>,
        'dateListNonNull'
      >
    >
  >
  dateNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateNonNull>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateNonNull: $SelectionSet }, Schema>,
        'dateNonNull'
      >
    >
  >
  dateObject1: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateObject1>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateObject1: $SelectionSet }, Schema>,
        'dateObject1'
      >
    >
  >
  dateUnion: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateUnion>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ dateUnion: $SelectionSet }, Schema>,
        'dateUnion'
      >
    >
  >
  error: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.error>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ error: $SelectionSet }, Schema>,
        'error'
      >
    >
  >
  id: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.id>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ id: $SelectionSet }, Schema>,
        'id'
      >
    >
  >
  idNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.idNonNull>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ idNonNull: $SelectionSet }, Schema>,
        'idNonNull'
      >
    >
  >
  interface: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.$interface>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ interface: $SelectionSet }, Schema>,
        'interface'
      >
    >
  >
  interfaceNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.interfaceNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ interfaceNonNull: $SelectionSet }, Schema>,
        'interfaceNonNull'
      >
    >
  >
  interfaceWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.interfaceWithArgs>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ interfaceWithArgs: $SelectionSet }, Schema>,
        'interfaceWithArgs'
      >
    >
  >
  listInt: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listInt>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ listInt: $SelectionSet }, Schema>,
        'listInt'
      >
    >
  >
  listIntNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listIntNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ listIntNonNull: $SelectionSet }, Schema>,
        'listIntNonNull'
      >
    >
  >
  listListInt: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listListInt>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ listListInt: $SelectionSet }, Schema>,
        'listListInt'
      >
    >
  >
  listListIntNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listListIntNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ listListIntNonNull: $SelectionSet }, Schema>,
        'listListIntNonNull'
      >
    >
  >
  lowerCaseUnion: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.lowerCaseUnion>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ lowerCaseUnion: $SelectionSet }, Schema>,
        'lowerCaseUnion'
      >
    >
  >
  object: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.$object>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ object: $SelectionSet }, Schema>,
        'object'
      >
    >
  >
  objectList: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectList>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ objectList: $SelectionSet }, Schema>,
        'objectList'
      >
    >
  >
  objectListNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectListNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ objectListNonNull: $SelectionSet }, Schema>,
        'objectListNonNull'
      >
    >
  >
  objectNested: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectNested>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ objectNested: $SelectionSet }, Schema>,
        'objectNested'
      >
    >
  >
  objectNonNull: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectNonNull>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ objectNonNull: $SelectionSet }, Schema>,
        'objectNonNull'
      >
    >
  >
  objectWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectWithArgs>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ objectWithArgs: $SelectionSet }, Schema>,
        'objectWithArgs'
      >
    >
  >
  result: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.result>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ result: $SelectionSet }, Schema>,
        'result'
      >
    >
  >
  resultNonNull: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.resultNonNull>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ resultNonNull: $SelectionSet }, Schema>,
        'resultNonNull'
      >
    >
  >
  string: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.$string>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ string: $SelectionSet }, Schema>,
        'string'
      >
    >
  >
  stringWithArgEnum: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgEnum>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithArgEnum: $SelectionSet }, Schema>,
        'stringWithArgEnum'
      >
    >
  >
  stringWithArgInputObject: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgInputObject>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithArgInputObject: $SelectionSet }, Schema>,
        'stringWithArgInputObject'
      >
    >
  >
  stringWithArgInputObjectRequired: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgInputObjectRequired>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithArgInputObjectRequired: $SelectionSet }, Schema>,
        'stringWithArgInputObjectRequired'
      >
    >
  >
  /**
   * The given arguments are reflected back as a JSON string.
   */
  stringWithArgs: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgs>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithArgs: $SelectionSet }, Schema>,
        'stringWithArgs'
      >
    >
  >
  stringWithListArg: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithListArg>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithListArg: $SelectionSet }, Schema>,
        'stringWithListArg'
      >
    >
  >
  stringWithListArgRequired: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithListArgRequired>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithListArgRequired: $SelectionSet }, Schema>,
        'stringWithListArgRequired'
      >
    >
  >
  stringWithRequiredArg: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithRequiredArg>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ stringWithRequiredArg: $SelectionSet }, Schema>,
        'stringWithRequiredArg'
      >
    >
  >
  unionFooBar: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBar>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ unionFooBar: $SelectionSet }, Schema>,
        'unionFooBar'
      >
    >
  >
  unionFooBarNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBarNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ unionFooBarNonNull: $SelectionSet }, Schema>,
        'unionFooBarNonNull'
      >
    >
  >
  unionFooBarWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBarWithArgs>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ unionFooBarWithArgs: $SelectionSet }, Schema>,
        'unionFooBarWithArgs'
      >
    >
  >
  unionObject: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionObject>) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ unionObject: $SelectionSet }, Schema>,
        'unionObject'
      >
    >
  >
  unionObjectNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionObjectNonNull>,
  ) => Promise<
    Simplify<
      Utils.HandleOutputGraffleRootField<
        $Config,
        InferResult.Query<{ unionObjectNonNull: $SelectionSet }, Schema>,
        'unionObjectNonNull'
      >
    >
  >
}

export interface BuilderMethodsRoot<$Config extends Utils.Config> {
  mutation: MutationMethods<$Config>
  query: QueryMethods<$Config>
}

export interface BuilderMethodsRootFn extends Utils.TypeFunction.Fn {
  // @ts-expect-error parameter is Untyped.
  return: BuilderMethodsRoot<this['params']['config']>
}
"
`;

exports[`kitchen-sink generated modules > modules/MethodsSelect.ts 1`] = `
"import type * as $Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as $SelectionSets from './SelectionSets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                      Select Methods Interface
// ==================================================================================================
//
//
//
//
//
//

export interface $MethodsSelect {
  Mutation: Mutation
  Query: Query
  Bar: Bar
  DateObject1: DateObject1
  DateObject2: DateObject2
  ErrorOne: ErrorOne
  ErrorTwo: ErrorTwo
  Foo: Foo
  Object1: Object1
  Object1ImplementingInterface: Object1ImplementingInterface
  Object2ImplementingInterface: Object2ImplementingInterface
  ObjectNested: ObjectNested
  ObjectUnion: ObjectUnion
  lowerCaseObject: lowerCaseObject
  lowerCaseObject2: lowerCaseObject2
  DateUnion: DateUnion
  FooBarUnion: FooBarUnion
  Result: Result
  lowerCaseUnion: lowerCaseUnion
  DateInterface1: DateInterface1
  Error: Error
  Interface: Interface
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

export interface Mutation {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Mutation>): $SelectionSet
}

export interface Query {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Query>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Object
// ==================================================================================================
//
//
//
//
//
//

export interface Bar {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Bar>): $SelectionSet
}

export interface DateObject1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateObject1>): $SelectionSet
}

export interface DateObject2 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateObject2>): $SelectionSet
}

export interface ErrorOne {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ErrorOne>): $SelectionSet
}

export interface ErrorTwo {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ErrorTwo>): $SelectionSet
}

export interface Foo {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Foo>): $SelectionSet
}

export interface Object1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object1>): $SelectionSet
}

export interface Object1ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object1ImplementingInterface>,
  ): $SelectionSet
}

export interface Object2ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object2ImplementingInterface>,
  ): $SelectionSet
}

export interface ObjectNested {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ObjectNested>): $SelectionSet
}

export interface ObjectUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ObjectUnion>): $SelectionSet
}

export interface lowerCaseObject {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseObject>): $SelectionSet
}

export interface lowerCaseObject2 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseObject2>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

export interface DateUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateUnion>): $SelectionSet
}

export interface FooBarUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.FooBarUnion>): $SelectionSet
}

export interface Result {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Result>): $SelectionSet
}

export interface lowerCaseUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseUnion>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

export interface DateInterface1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateInterface1>): $SelectionSet
}

export interface Error {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Error>): $SelectionSet
}

export interface Interface {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Interface>): $SelectionSet
}
"
`;

exports[`kitchen-sink generated modules > modules/Scalar.ts 1`] = `
"import type { SchemaKit } from '../../../../../../src/entrypoints/schema.js'

import * as CustomScalars from '../../customScalarCodecs.js'

export * from '../../customScalarCodecs.js'
export { Date } from '../../customScalarCodecs.js'
//
//
//
//
// CUSTOM SCALAR TYPE
// DATE
// --------------------------------------------------------------------------------------------------
//                                                Date
// --------------------------------------------------------------------------------------------------
//
//

export type Date = typeof CustomScalars.Date
// Without this we get error:
// "Exported type alias 'DateDecoded' has or is using private name 'Date'."
type Date_ = typeof CustomScalars.Date
export type DateDecoded = SchemaKit.Scalar.GetDecoded<Date_>
export type DateEncoded = SchemaKit.Scalar.GetEncoded<Date_>

export * from '../../../../../../src/layers/1_Schema/Hybrid/types/Scalar/Scalar.js'
"
`;

exports[`kitchen-sink generated modules > modules/Schema.ts 1`] = `
"import type * as $ from '../../../../../../src/entrypoints/schema.js'
import type * as $Scalar from './Scalar.js'

export namespace Schema {
  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Root
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace Root {
    export type Mutation = $.Output.ObjectMutation<{
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
      idNonNull: $.Field<'idNonNull', $Scalar.ID, null>
    }>

    export type Query = $.Output.ObjectQuery<{
      InputObjectNested: $.Field<
        'InputObjectNested',
        $.Output.Nullable<$Scalar.ID>,
        $.Args<{
          input: $.Input.Field<$.Input.Nullable<InputObject.InputObjectNested>>
        }, true>
      >
      InputObjectNestedNonNull: $.Field<
        'InputObjectNestedNonNull',
        $.Output.Nullable<$Scalar.ID>,
        $.Args<{
          input: $.Input.Field<InputObject.InputObjectNestedNonNull>
        }, false>
      >
      /**
       * Query enum field documentation.
       */
      abcEnum: $.Field<'abcEnum', $.Output.Nullable<Enum.ABCEnum>, null>
      argInputObjectCircular: $.Field<
        'argInputObjectCircular',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          input: $.Input.Field<$.Input.Nullable<InputObject.InputObjectCircular>>
        }, true>
      >
      date: $.Field<'date', $.Output.Nullable<$Scalar.Date>, null>
      dateArg: $.Field<
        'dateArg',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
        }, true>
      >
      dateArgInputObject: $.Field<
        'dateArgInputObject',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          input: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
        }, true>
      >
      dateArgList: $.Field<
        'dateArgList',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          date: $.Input.Field<$.Input.Nullable<$.Input.List<$Scalar.Date>>>
        }, true>
      >
      dateArgNonNull: $.Field<
        'dateArgNonNull',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          date: $.Input.Field<$Scalar.Date>
        }, false>
      >
      dateArgNonNullList: $.Field<
        'dateArgNonNullList',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          date: $.Input.Field<$.Input.List<$.Input.Nullable<$Scalar.Date>>>
        }, false>
      >
      dateArgNonNullListNonNull: $.Field<
        'dateArgNonNullListNonNull',
        $.Output.Nullable<$Scalar.Date>,
        $.Args<{
          date: $.Input.Field<$.Input.List<$Scalar.Date>>
        }, false>
      >
      dateInterface1: $.Field<'dateInterface1', $.Output.Nullable<Interface.DateInterface1>, null>
      dateList: $.Field<'dateList', $.Output.Nullable<$.Output.List<$Scalar.Date>>, null>
      dateListList: $.Field<'dateListList', $.Output.Nullable<$.Output.List<$.Output.List<$Scalar.Date>>>, null>
      dateListNonNull: $.Field<'dateListNonNull', $.Output.List<$Scalar.Date>, null>
      dateNonNull: $.Field<'dateNonNull', $Scalar.Date, null>
      dateObject1: $.Field<'dateObject1', $.Output.Nullable<Object.DateObject1>, null>
      dateUnion: $.Field<'dateUnion', $.Output.Nullable<Union.DateUnion>, null>
      error: $.Field<
        'error',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          case: $.Input.Field<$.Input.Nullable<$Scalar.String>>
        }, true>
      >
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
      idNonNull: $.Field<'idNonNull', $Scalar.ID, null>
      interface: $.Field<'interface', $.Output.Nullable<Interface.Interface>, null>
      interfaceNonNull: $.Field<'interfaceNonNull', Interface.Interface, null>
      interfaceWithArgs: $.Field<
        'interfaceWithArgs',
        $.Output.Nullable<Interface.Interface>,
        $.Args<{
          id: $.Input.Field<$Scalar.ID>
        }, false>
      >
      listInt: $.Field<'listInt', $.Output.Nullable<$.Output.List<$.Output.Nullable<$Scalar.Int>>>, null>
      listIntNonNull: $.Field<'listIntNonNull', $.Output.List<$Scalar.Int>, null>
      listListInt: $.Field<
        'listListInt',
        $.Output.Nullable<$.Output.List<$.Output.Nullable<$.Output.List<$.Output.Nullable<$Scalar.Int>>>>>,
        null
      >
      listListIntNonNull: $.Field<'listListIntNonNull', $.Output.List<$.Output.List<$Scalar.Int>>, null>
      lowerCaseUnion: $.Field<'lowerCaseUnion', $.Output.Nullable<Union.lowerCaseUnion>, null>
      object: $.Field<'object', $.Output.Nullable<Object.Object1>, null>
      objectList: $.Field<'objectList', $.Output.Nullable<$.Output.List<Object.Object1>>, null>
      objectListNonNull: $.Field<'objectListNonNull', $.Output.List<Object.Object1>, null>
      objectNested: $.Field<'objectNested', $.Output.Nullable<Object.ObjectNested>, null>
      objectNonNull: $.Field<'objectNonNull', Object.Object1, null>
      objectWithArgs: $.Field<
        'objectWithArgs',
        $.Output.Nullable<Object.Object1>,
        $.Args<{
          boolean: $.Input.Field<$.Input.Nullable<$Scalar.Boolean>>
          float: $.Input.Field<$.Input.Nullable<$Scalar.Float>>
          id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
          int: $.Input.Field<$.Input.Nullable<$Scalar.Int>>
          string: $.Input.Field<$.Input.Nullable<$Scalar.String>>
        }, true>
      >
      result: $.Field<
        'result',
        $.Output.Nullable<Union.Result>,
        $.Args<{
          case: $.Input.Field<Enum.Case>
        }, false>
      >
      resultNonNull: $.Field<
        'resultNonNull',
        Union.Result,
        $.Args<{
          case: $.Input.Field<$.Input.Nullable<Enum.Case>>
        }, true>
      >
      string: $.Field<'string', $.Output.Nullable<$Scalar.String>, null>
      stringWithArgEnum: $.Field<
        'stringWithArgEnum',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          ABCEnum: $.Input.Field<$.Input.Nullable<Enum.ABCEnum>>
        }, true>
      >
      stringWithArgInputObject: $.Field<
        'stringWithArgInputObject',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          input: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
        }, true>
      >
      stringWithArgInputObjectRequired: $.Field<
        'stringWithArgInputObjectRequired',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          input: $.Input.Field<InputObject.InputObject>
        }, false>
      >
      /**
       * The given arguments are reflected back as a JSON string.
       */
      stringWithArgs: $.Field<
        'stringWithArgs',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          boolean: $.Input.Field<$.Input.Nullable<$Scalar.Boolean>>
          float: $.Input.Field<$.Input.Nullable<$Scalar.Float>>
          id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
          int: $.Input.Field<$.Input.Nullable<$Scalar.Int>>
          string: $.Input.Field<$.Input.Nullable<$Scalar.String>>
        }, true>
      >
      stringWithListArg: $.Field<
        'stringWithListArg',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          ints: $.Input.Field<$.Input.Nullable<$.Input.List<$.Input.Nullable<$Scalar.Int>>>>
        }, true>
      >
      stringWithListArgRequired: $.Field<
        'stringWithListArgRequired',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          ints: $.Input.Field<$.Input.List<$Scalar.Int>>
        }, false>
      >
      stringWithRequiredArg: $.Field<
        'stringWithRequiredArg',
        $.Output.Nullable<$Scalar.String>,
        $.Args<{
          string: $.Input.Field<$Scalar.String>
        }, false>
      >
      unionFooBar: $.Field<'unionFooBar', $.Output.Nullable<Union.FooBarUnion>, null>
      unionFooBarNonNull: $.Field<'unionFooBarNonNull', Union.FooBarUnion, null>
      unionFooBarWithArgs: $.Field<
        'unionFooBarWithArgs',
        $.Output.Nullable<Union.FooBarUnion>,
        $.Args<{
          id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
        }, true>
      >
      unionObject: $.Field<'unionObject', $.Output.Nullable<Object.ObjectUnion>, null>
      unionObjectNonNull: $.Field<'unionObjectNonNull', Object.ObjectUnion, null>
    }>
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                                Enum
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace Enum {
    /**
     * Enum documentation.
     *
     * Members
     * "A" - (DEPRECATED: Enum value A is deprecated.)
     * "B" - Enum B member documentation.
     * "C" - (DEPRECATED: Enum value C is deprecated.)
     */
    export type ABCEnum = $.Enum<'ABCEnum', ['A', 'B', 'C']>

    export type Case = $.Enum<'Case', ['ErrorOne', 'ErrorTwo', 'Object1']>
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                            InputObject
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace InputObject {
    export type InputObject = $.InputObject<'InputObject', {
      date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
      dateRequired: $.Input.Field<$Scalar.Date>
      id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
      idRequired: $.Input.Field<$Scalar.ID>
    }, true>

    export type InputObjectCircular = $.InputObject<'InputObjectCircular', {
      circular: $.Input.Field<$.Input.Nullable<InputObject.InputObjectCircular>>
      date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
    }, true>

    export type InputObjectNested = $.InputObject<'InputObjectNested', {
      InputObject: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
    }, true>

    export type InputObjectNestedNonNull = $.InputObject<'InputObjectNestedNonNull', {
      InputObject: $.Input.Field<InputObject.InputObject>
    }, false>
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                             Interface
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace Interface {
    export type DateInterface1 = $.Interface<'DateInterface1', {
      date1: $.Field<'date1', $.Output.Nullable<$Scalar.Date>, null>
    }, [Object.DateObject1]>

    export type Error = $.Interface<'Error', {
      message: $.Field<'message', $Scalar.String, null>
    }, [Object.ErrorOne, Object.ErrorTwo]>

    export type Interface = $.Interface<'Interface', {
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    }, [Object.Object1ImplementingInterface, Object.Object2ImplementingInterface]>
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                               Object
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace Object {
    export type Bar = $.Object$2<'Bar', {
      int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
    }>

    export type DateObject1 = $.Object$2<'DateObject1', {
      date1: $.Field<'date1', $.Output.Nullable<$Scalar.Date>, null>
    }>

    export type DateObject2 = $.Object$2<'DateObject2', {
      date2: $.Field<'date2', $.Output.Nullable<$Scalar.Date>, null>
    }>

    export type ErrorOne = $.Object$2<'ErrorOne', {
      infoId: $.Field<'infoId', $.Output.Nullable<$Scalar.ID>, null>
      message: $.Field<'message', $Scalar.String, null>
    }>

    export type ErrorTwo = $.Object$2<'ErrorTwo', {
      infoInt: $.Field<'infoInt', $.Output.Nullable<$Scalar.Int>, null>
      message: $.Field<'message', $Scalar.String, null>
    }>

    /**
     * Object documentation.
     */
    export type Foo = $.Object$2<'Foo', {
      /**
       * Field documentation.
       *
       * @deprecated Field a is deprecated.
       */
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    }>

    export type Object1 = $.Object$2<'Object1', {
      boolean: $.Field<'boolean', $.Output.Nullable<$Scalar.Boolean>, null>
      float: $.Field<'float', $.Output.Nullable<$Scalar.Float>, null>
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
      int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
      string: $.Field<'string', $.Output.Nullable<$Scalar.String>, null>
    }>

    export type Object1ImplementingInterface = $.Object$2<'Object1ImplementingInterface', {
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
      int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
    }>

    export type Object2ImplementingInterface = $.Object$2<'Object2ImplementingInterface', {
      boolean: $.Field<'boolean', $.Output.Nullable<$Scalar.Boolean>, null>
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    }>

    export type ObjectNested = $.Object$2<'ObjectNested', {
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
      object: $.Field<'object', $.Output.Nullable<Object.Object1>, null>
    }>

    export type ObjectUnion = $.Object$2<'ObjectUnion', {
      fooBarUnion: $.Field<'fooBarUnion', $.Output.Nullable<Union.FooBarUnion>, null>
    }>

    export type lowerCaseObject = $.Object$2<'lowerCaseObject', {
      id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    }>

    export type lowerCaseObject2 = $.Object$2<'lowerCaseObject2', {
      int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
    }>
  }

  //
  //
  //
  //
  //
  //
  // ==================================================================================================
  //                                               Union
  // ==================================================================================================
  //
  //
  //
  //
  //
  //

  export namespace Union {
    export type DateUnion = $.Union<'DateUnion', [Object.DateObject1, Object.DateObject2]>

    /**
     * Union documentation.
     */
    export type FooBarUnion = $.Union<'FooBarUnion', [Object.Bar, Object.Foo]>

    export type Result = $.Union<'Result', [Object.ErrorOne, Object.ErrorTwo, Object.Object1]>

    export type lowerCaseUnion = $.Union<'lowerCaseUnion', [Object.lowerCaseObject, Object.lowerCaseObject2]>
  }
}
//
//
//
//
//
//
// ==================================================================================================
//                                               Schema
// ==================================================================================================
//
//
//
//
//
//

import type * as Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as Data from './Data.js'
import type * as MethodsRoot from './MethodsRoot.js'

export interface Schema extends Utilities.SchemaIndexBase {
  name: Data.Name
  RootTypesPresent: ['Mutation', 'Query']
  RootUnion: Schema.Root.Mutation | Schema.Root.Query
  Root: {
    Query: Schema.Root.Query
    Mutation: Schema.Root.Mutation
    Subscription: null
  }
  allTypes: {
    Mutation: Schema.Root.Mutation
    Query: Schema.Root.Query
    ABCEnum: Schema.Enum.ABCEnum
    Case: Schema.Enum.Case
    Bar: Schema.Object.Bar
    DateObject1: Schema.Object.DateObject1
    DateObject2: Schema.Object.DateObject2
    ErrorOne: Schema.Object.ErrorOne
    ErrorTwo: Schema.Object.ErrorTwo
    Foo: Schema.Object.Foo
    Object1: Schema.Object.Object1
    Object1ImplementingInterface: Schema.Object.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object.Object2ImplementingInterface
    ObjectNested: Schema.Object.ObjectNested
    ObjectUnion: Schema.Object.ObjectUnion
    lowerCaseObject: Schema.Object.lowerCaseObject
    lowerCaseObject2: Schema.Object.lowerCaseObject2
    DateUnion: Schema.Union.DateUnion
    FooBarUnion: Schema.Union.FooBarUnion
    Result: Schema.Union.Result
    lowerCaseUnion: Schema.Union.lowerCaseUnion
    DateInterface1: Schema.Interface.DateInterface1
    Error: Schema.Interface.Error
    Interface: Schema.Interface.Interface
  }
  objects: {
    Bar: Schema.Object.Bar
    DateObject1: Schema.Object.DateObject1
    DateObject2: Schema.Object.DateObject2
    ErrorOne: Schema.Object.ErrorOne
    ErrorTwo: Schema.Object.ErrorTwo
    Foo: Schema.Object.Foo
    Object1: Schema.Object.Object1
    Object1ImplementingInterface: Schema.Object.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object.Object2ImplementingInterface
    ObjectNested: Schema.Object.ObjectNested
    ObjectUnion: Schema.Object.ObjectUnion
    lowerCaseObject: Schema.Object.lowerCaseObject
    lowerCaseObject2: Schema.Object.lowerCaseObject2
  }
  unions: {
    DateUnion: Schema.Union.DateUnion
    FooBarUnion: Schema.Union.FooBarUnion
    Result: Schema.Union.Result
    lowerCaseUnion: Schema.Union.lowerCaseUnion
  }
  interfaces: {
    DateInterface1: Schema.Interface.DateInterface1
    Error: Schema.Interface.Error
    Interface: Schema.Interface.Interface
  }
  customScalars: Utilities.SchemaIndexBase['customScalars']
  extensions: Utilities.GlobalRegistry.TypeExtensions
}
"
`;

exports[`kitchen-sink generated modules > modules/SchemaDrivenDataMap.ts 1`] = `
"import type * as $Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $Scalar from './Scalar.js'
//
//
//
//
//
//
// ==================================================================================================
//                                     GraphQLScalarTypeStandard
// ==================================================================================================
//
//
//
//
//
//

const Boolean = $Scalar.Boolean

const Float = $Scalar.Float

const ID = $Scalar.ID

const Int = $Scalar.Int

const String = $Scalar.String

//
//
//
//
//
//
// ==================================================================================================
//                                      GraphQLScalarTypeCustom
// ==================================================================================================
//
//
//
//
//
//

const Date = $Scalar.Date

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLEnumType
// ==================================================================================================
//
//
//
//
//
//

const ABCEnum: $Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ABCEnum',
}

const Case: $Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'Case',
}

//
//
//
//
//
//
// ==================================================================================================
//                                       GraphQLInputObjectType
// ==================================================================================================
//
//
//
//
//
//

const InputObject: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObject',
  fcs: ['date', 'dateRequired'],
  f: {
    date: {
      nt: Date,
    },
    dateRequired: {
      nt: Date,
    },
    id: {},
    idRequired: {},
  },
}

const InputObjectCircular: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectCircular',
  fcs: ['circular', 'date'],
  f: {
    circular: {
      // nt: InputObjectCircular, <-- Assigned later to avoid potential circular dependency.
    },
    date: {
      nt: Date,
    },
  },
}

const InputObjectNested: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNested',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const InputObjectNestedNonNull: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNestedNonNull',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                         GraphQLObjectType
// ==================================================================================================
//
//
//
//
//
//

const Bar: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

const DateObject1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date1: {
      nt: Date,
    },
  },
}

const DateObject2: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date2: {
      nt: Date,
    },
  },
}

const ErrorOne: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    infoId: {},
    message: {},
  },
}

const ErrorTwo: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    infoInt: {},
    message: {},
  },
}

const Foo: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const Object1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    boolean: {},
    float: {},
    id: {},
    int: {},
    string: {},
  },
}

const Object1ImplementingInterface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    int: {},
  },
}

const Object2ImplementingInterface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    boolean: {},
    id: {},
  },
}

const ObjectNested: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ObjectUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    fooBarUnion: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const lowerCaseObject: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const lowerCaseObject2: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                        GraphQLInterfaceType
// ==================================================================================================
//
//
//
//
//
//

const DateInterface1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
  },
}

const Error: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Interface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLUnionType
// ==================================================================================================
//
//
//
//
//
//

const DateUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
    ...DateObject2.f,
  },
}

const FooBarUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Result: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const lowerCaseUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLRootType
// ==================================================================================================
//
//
//
//
//
//

const Mutation: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    idNonNull: {},
  },
}

const Query: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    InputObjectNested: {
      a: {
        input: {
          nt: InputObjectNested,
          it: [0],
        },
      },
    },
    InputObjectNestedNonNull: {
      a: {
        input: {
          nt: InputObjectNestedNonNull,
          it: [1],
        },
      },
    },
    abcEnum: {},
    argInputObjectCircular: {
      a: {
        input: {
          nt: InputObjectCircular,
          it: [0],
        },
      },
    },
    date: {
      nt: Date,
    },
    dateArg: {
      a: {
        date: {
          nt: Date,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgList: {
      a: {
        date: {
          nt: Date,
          it: [0, [1]],
        },
      },
      nt: Date,
    },
    dateArgNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1],
        },
      },
      nt: Date,
    },
    dateArgNonNullList: {
      a: {
        date: {
          nt: Date,
          it: [1, [0]],
        },
      },
      nt: Date,
    },
    dateArgNonNullListNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1, [1]],
        },
      },
      nt: Date,
    },
    dateInterface1: {
      // nt: DateInterface1, <-- Assigned later to avoid potential circular dependency.
    },
    dateList: {
      nt: Date,
    },
    dateListList: {
      nt: Date,
    },
    dateListNonNull: {
      nt: Date,
    },
    dateNonNull: {
      nt: Date,
    },
    dateObject1: {
      // nt: DateObject1, <-- Assigned later to avoid potential circular dependency.
    },
    dateUnion: {
      // nt: DateUnion, <-- Assigned later to avoid potential circular dependency.
    },
    error: {
      a: {
        case: {
          nt: String,
          it: [0],
        },
      },
    },
    id: {},
    idNonNull: {},
    interface: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceNonNull: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [1],
        },
      },
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    listInt: {},
    listIntNonNull: {},
    listListInt: {},
    listListIntNonNull: {},
    lowerCaseUnion: {
      // nt: lowerCaseUnion, <-- Assigned later to avoid potential circular dependency.
    },
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectList: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectListNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectNested: {
      // nt: ObjectNested, <-- Assigned later to avoid potential circular dependency.
    },
    objectNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    result: {
      a: {
        case: {
          nt: Case,
          it: [1],
        },
      },
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    resultNonNull: {
      a: {
        case: {
          nt: Case,
          it: [0],
        },
      },
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    string: {},
    stringWithArgEnum: {
      a: {
        ABCEnum: {
          nt: ABCEnum,
          it: [0],
        },
      },
    },
    stringWithArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
    },
    stringWithArgInputObjectRequired: {
      a: {
        input: {
          nt: InputObject,
          it: [1],
        },
      },
    },
    stringWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
    },
    stringWithListArg: {
      a: {
        ints: {
          nt: Int,
          it: [0, [0]],
        },
      },
    },
    stringWithListArgRequired: {
      a: {
        ints: {
          nt: Int,
          it: [1, [1]],
        },
      },
    },
    stringWithRequiredArg: {
      a: {
        string: {
          nt: String,
          it: [1],
        },
      },
    },
    unionFooBar: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarNonNull: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [0],
        },
      },
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObject: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObjectNonNull: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                       Reference Assignments
//                                (avoids circular assignment issues)
// ==================================================================================================
//
//
//
//
//
//

InputObjectCircular.f![\`circular\`]!.nt = InputObjectCircular
InputObjectNested.f![\`InputObject\`]!.nt = InputObject
InputObjectNestedNonNull.f![\`InputObject\`]!.nt = InputObject
ObjectNested.f[\`object\`]!.nt = Object1
ObjectUnion.f[\`fooBarUnion\`]!.nt = FooBarUnion
Query.f[\`dateInterface1\`]!.nt = DateInterface1
Query.f[\`dateObject1\`]!.nt = DateObject1
Query.f[\`dateUnion\`]!.nt = DateUnion
Query.f[\`interface\`]!.nt = Interface
Query.f[\`interfaceNonNull\`]!.nt = Interface
Query.f[\`interfaceWithArgs\`]!.nt = Interface
Query.f[\`lowerCaseUnion\`]!.nt = lowerCaseUnion
Query.f[\`object\`]!.nt = Object1
Query.f[\`objectList\`]!.nt = Object1
Query.f[\`objectListNonNull\`]!.nt = Object1
Query.f[\`objectNested\`]!.nt = ObjectNested
Query.f[\`objectNonNull\`]!.nt = Object1
Query.f[\`objectWithArgs\`]!.nt = Object1
Query.f[\`result\`]!.nt = Result
Query.f[\`resultNonNull\`]!.nt = Result
Query.f[\`unionFooBar\`]!.nt = FooBarUnion
Query.f[\`unionFooBarNonNull\`]!.nt = FooBarUnion
Query.f[\`unionFooBarWithArgs\`]!.nt = FooBarUnion
Query.f[\`unionObject\`]!.nt = ObjectUnion
Query.f[\`unionObjectNonNull\`]!.nt = ObjectUnion

//
//
//
//
//
//
// ==================================================================================================
//                                               Index
// ==================================================================================================
//
//
//
//
//
//

const $schemaDrivenDataMap: $Utilities.SchemaDrivenDataMap = {
  roots: {
    Mutation,
    Query,
  },
  directives: {},
  types: {
    Boolean,
    Float,
    ID,
    Int,
    String,
    Date,
    ABCEnum,
    Case,
    InputObject,
    InputObjectCircular,
    InputObjectNested,
    InputObjectNestedNonNull,
    Bar,
    DateObject1,
    DateObject2,
    ErrorOne,
    ErrorTwo,
    Foo,
    Object1,
    Object1ImplementingInterface,
    Object2ImplementingInterface,
    ObjectNested,
    ObjectUnion,
    lowerCaseObject,
    lowerCaseObject2,
    DateInterface1,
    Error,
    Interface,
    DateUnion,
    FooBarUnion,
    Result,
    lowerCaseUnion,
    Mutation,
    Query,
  },
}

export { $schemaDrivenDataMap as schemaDrivenDataMap }
"
`;

exports[`kitchen-sink generated modules > modules/Select.ts 1`] = `
"import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import * as Data from './Data.js'
import type { Schema } from './Schema.js'
import type * as SelectionSets from './SelectionSets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                              Runtime
// ==================================================================================================
//
//
//
//
//
//
import { createSelect } from '../../../../../../src/entrypoints/client.js'
export const Select = createSelect(Data.Name)

//
//
//
//
//
//
// ==================================================================================================
//                                             Buildtime
// ==================================================================================================
//
//
//
//
//
//

export namespace Select {
  // Root Types
  // ----------
  export type Mutation<$SelectionSet extends SelectionSets.Mutation> = InferResult.Root<
    $SelectionSet,
    Schema,
    'Mutation'
  >
  export type Query<$SelectionSet extends SelectionSets.Query> = InferResult.Root<$SelectionSet, Schema, 'Query'>
  // Object Types
  // ------------
  export type Bar<$SelectionSet extends SelectionSets.Bar> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Bar']
  >
  export type DateObject1<$SelectionSet extends SelectionSets.DateObject1> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['DateObject1']
  >
  export type DateObject2<$SelectionSet extends SelectionSets.DateObject2> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['DateObject2']
  >
  export type ErrorOne<$SelectionSet extends SelectionSets.ErrorOne> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['ErrorOne']
  >
  export type ErrorTwo<$SelectionSet extends SelectionSets.ErrorTwo> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['ErrorTwo']
  >
  export type Foo<$SelectionSet extends SelectionSets.Foo> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Foo']
  >
  export type Object1<$SelectionSet extends SelectionSets.Object1> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Object1']
  >
  export type Object1ImplementingInterface<$SelectionSet extends SelectionSets.Object1ImplementingInterface> =
    InferResult.Object<$SelectionSet, Schema, Schema['allTypes']['Object1ImplementingInterface']>
  export type Object2ImplementingInterface<$SelectionSet extends SelectionSets.Object2ImplementingInterface> =
    InferResult.Object<$SelectionSet, Schema, Schema['allTypes']['Object2ImplementingInterface']>
  export type ObjectNested<$SelectionSet extends SelectionSets.ObjectNested> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['ObjectNested']
  >
  export type ObjectUnion<$SelectionSet extends SelectionSets.ObjectUnion> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['ObjectUnion']
  >
  export type lowerCaseObject<$SelectionSet extends SelectionSets.lowerCaseObject> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['lowerCaseObject']
  >
  export type lowerCaseObject2<$SelectionSet extends SelectionSets.lowerCaseObject2> = InferResult.Object<
    $SelectionSet,
    Schema,
    Schema['allTypes']['lowerCaseObject2']
  >
  // Union Types
  // -----------
  export type DateUnion<$SelectionSet extends SelectionSets.DateUnion> = InferResult.Union<
    $SelectionSet,
    Schema,
    Schema['allTypes']['DateUnion']
  >
  export type FooBarUnion<$SelectionSet extends SelectionSets.FooBarUnion> = InferResult.Union<
    $SelectionSet,
    Schema,
    Schema['allTypes']['FooBarUnion']
  >
  export type Result<$SelectionSet extends SelectionSets.Result> = InferResult.Union<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Result']
  >
  export type lowerCaseUnion<$SelectionSet extends SelectionSets.lowerCaseUnion> = InferResult.Union<
    $SelectionSet,
    Schema,
    Schema['allTypes']['lowerCaseUnion']
  >
  // Interface Types
  // ---------------
  export type DateInterface1<$SelectionSet extends SelectionSets.DateInterface1> = InferResult.Interface<
    $SelectionSet,
    Schema,
    Schema['allTypes']['DateInterface1']
  >
  export type Error<$SelectionSet extends SelectionSets.Error> = InferResult.Interface<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Error']
  >
  export type Interface<$SelectionSet extends SelectionSets.Interface> = InferResult.Interface<
    $SelectionSet,
    Schema,
    Schema['allTypes']['Interface']
  >
}
"
`;

exports[`kitchen-sink generated modules > modules/SelectionSets.ts 1`] = `
"import type { Select as $Select } from '../../../../../../src/entrypoints/schema.js'
import type * as $Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as $Scalar from './Scalar.js'

//
//
//
//
//
//
// ==================================================================================================
//                                              Document
// ==================================================================================================
//
//
//
//
//
//

// Prefix with $ because this is not a schema type. A user could have a schema type named "Document" that this would conflict with.
export interface $Document {
  query?: Record<string, Query>
  mutation?: Record<string, Mutation>
}

//
//
//
//
//
//
// ==================================================================================================
//                                      GraphQLObjectType Types
// ==================================================================================================
//
//
//
//
//
//

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                              Mutation
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Mutation {
  /**
   * Select the \`id\` field on the \`Mutation\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Mutation.id$Expanded | $Select.SelectAlias.SelectAlias<Mutation.id>
  /**
   * Select the \`idNonNull\` field on the \`Mutation\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  idNonNull?: Mutation.idNonNull$Expanded | $Select.SelectAlias.SelectAlias<Mutation.idNonNull>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Mutation$FragmentInline | Mutation$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Mutation$FragmentInline extends Mutation, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace Mutation {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`idNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type idNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type idNonNull = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                               Query
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Query {
  /**
   * Select the \`InputObjectNested\` field on the \`Query\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  InputObjectNested?: Query.InputObjectNested$Expanded | $Select.SelectAlias.SelectAlias<Query.InputObjectNested>
  /**
   * Select the \`InputObjectNestedNonNull\` field on the \`Query\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  InputObjectNestedNonNull?:
    | Query.InputObjectNestedNonNull
    | $Select.SelectAlias.SelectAlias<Query.InputObjectNestedNonNull>
  /**
   * Select the \`abcEnum\` field on the \`Query\` object. Its type is Enum.
   */
  abcEnum?: Query.abcEnum$Expanded | $Select.SelectAlias.SelectAlias<Query.abcEnum>
  /**
   * Select the \`argInputObjectCircular\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  argInputObjectCircular?:
    | Query.argInputObjectCircular$Expanded
    | $Select.SelectAlias.SelectAlias<Query.argInputObjectCircular>
  /**
   * Select the \`date\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  date?: Query.date$Expanded | $Select.SelectAlias.SelectAlias<Query.date>
  /**
   * Select the \`dateArg\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArg?: Query.dateArg$Expanded | $Select.SelectAlias.SelectAlias<Query.dateArg>
  /**
   * Select the \`dateArgInputObject\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArgInputObject?: Query.dateArgInputObject$Expanded | $Select.SelectAlias.SelectAlias<Query.dateArgInputObject>
  /**
   * Select the \`dateArgList\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArgList?: Query.dateArgList$Expanded | $Select.SelectAlias.SelectAlias<Query.dateArgList>
  /**
   * Select the \`dateArgNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArgNonNull?: Query.dateArgNonNull | $Select.SelectAlias.SelectAlias<Query.dateArgNonNull>
  /**
   * Select the \`dateArgNonNullList\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArgNonNullList?: Query.dateArgNonNullList | $Select.SelectAlias.SelectAlias<Query.dateArgNonNullList>
  /**
   * Select the \`dateArgNonNullListNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateArgNonNullListNonNull?:
    | Query.dateArgNonNullListNonNull
    | $Select.SelectAlias.SelectAlias<Query.dateArgNonNullListNonNull>
  /**
   * Select the \`dateInterface1\` field on the \`Query\` object. Its type is Interface.
   */
  dateInterface1?: Query.dateInterface1$Expanded | $Select.SelectAlias.SelectAlias<Query.dateInterface1>
  /**
   * Select the \`dateList\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateList?: Query.dateList$Expanded | $Select.SelectAlias.SelectAlias<Query.dateList>
  /**
   * Select the \`dateListList\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateListList?: Query.dateListList$Expanded | $Select.SelectAlias.SelectAlias<Query.dateListList>
  /**
   * Select the \`dateListNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateListNonNull?: Query.dateListNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.dateListNonNull>
  /**
   * Select the \`dateNonNull\` field on the \`Query\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  dateNonNull?: Query.dateNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.dateNonNull>
  /**
   * Select the \`dateObject1\` field on the \`Query\` object. Its type is Object.
   */
  dateObject1?: Query.dateObject1$Expanded | $Select.SelectAlias.SelectAlias<Query.dateObject1>
  /**
   * Select the \`dateUnion\` field on the \`Query\` object. Its type is Union.
   */
  dateUnion?: Query.dateUnion$Expanded | $Select.SelectAlias.SelectAlias<Query.dateUnion>
  /**
   * Select the \`error\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  error?: Query.error$Expanded | $Select.SelectAlias.SelectAlias<Query.error>
  /**
   * Select the \`id\` field on the \`Query\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Query.id$Expanded | $Select.SelectAlias.SelectAlias<Query.id>
  /**
   * Select the \`idNonNull\` field on the \`Query\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  idNonNull?: Query.idNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.idNonNull>
  /**
   * Select the \`interface\` field on the \`Query\` object. Its type is Interface.
   */
  interface?: Query.$interface$Expanded | $Select.SelectAlias.SelectAlias<Query.$interface>
  /**
   * Select the \`interfaceNonNull\` field on the \`Query\` object. Its type is Interface.
   */
  interfaceNonNull?: Query.interfaceNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.interfaceNonNull>
  /**
   * Select the \`interfaceWithArgs\` field on the \`Query\` object. Its type is Interface.
   */
  interfaceWithArgs?: Query.interfaceWithArgs | $Select.SelectAlias.SelectAlias<Query.interfaceWithArgs>
  /**
   * Select the \`listInt\` field on the \`Query\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  listInt?: Query.listInt$Expanded | $Select.SelectAlias.SelectAlias<Query.listInt>
  /**
   * Select the \`listIntNonNull\` field on the \`Query\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  listIntNonNull?: Query.listIntNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.listIntNonNull>
  /**
   * Select the \`listListInt\` field on the \`Query\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  listListInt?: Query.listListInt$Expanded | $Select.SelectAlias.SelectAlias<Query.listListInt>
  /**
   * Select the \`listListIntNonNull\` field on the \`Query\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  listListIntNonNull?: Query.listListIntNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.listListIntNonNull>
  /**
   * Select the \`lowerCaseUnion\` field on the \`Query\` object. Its type is Union.
   */
  lowerCaseUnion?: Query.lowerCaseUnion$Expanded | $Select.SelectAlias.SelectAlias<Query.lowerCaseUnion>
  /**
   * Select the \`object\` field on the \`Query\` object. Its type is Object.
   */
  object?: Query.$object$Expanded | $Select.SelectAlias.SelectAlias<Query.$object>
  /**
   * Select the \`objectList\` field on the \`Query\` object. Its type is Object.
   */
  objectList?: Query.objectList$Expanded | $Select.SelectAlias.SelectAlias<Query.objectList>
  /**
   * Select the \`objectListNonNull\` field on the \`Query\` object. Its type is Object.
   */
  objectListNonNull?: Query.objectListNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.objectListNonNull>
  /**
   * Select the \`objectNested\` field on the \`Query\` object. Its type is Object.
   */
  objectNested?: Query.objectNested$Expanded | $Select.SelectAlias.SelectAlias<Query.objectNested>
  /**
   * Select the \`objectNonNull\` field on the \`Query\` object. Its type is Object.
   */
  objectNonNull?: Query.objectNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.objectNonNull>
  /**
   * Select the \`objectWithArgs\` field on the \`Query\` object. Its type is Object.
   */
  objectWithArgs?: Query.objectWithArgs$Expanded | $Select.SelectAlias.SelectAlias<Query.objectWithArgs>
  /**
   * Select the \`result\` field on the \`Query\` object. Its type is Union.
   */
  result?: Query.result | $Select.SelectAlias.SelectAlias<Query.result>
  /**
   * Select the \`resultNonNull\` field on the \`Query\` object. Its type is Union.
   */
  resultNonNull?: Query.resultNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.resultNonNull>
  /**
   * Select the \`string\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  string?: Query.$string$Expanded | $Select.SelectAlias.SelectAlias<Query.$string>
  /**
   * Select the \`stringWithArgEnum\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithArgEnum?: Query.stringWithArgEnum$Expanded | $Select.SelectAlias.SelectAlias<Query.stringWithArgEnum>
  /**
   * Select the \`stringWithArgInputObject\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithArgInputObject?:
    | Query.stringWithArgInputObject$Expanded
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgInputObject>
  /**
   * Select the \`stringWithArgInputObjectRequired\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithArgInputObjectRequired?:
    | Query.stringWithArgInputObjectRequired
    | $Select.SelectAlias.SelectAlias<Query.stringWithArgInputObjectRequired>
  /**
   * Select the \`stringWithArgs\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithArgs?: Query.stringWithArgs$Expanded | $Select.SelectAlias.SelectAlias<Query.stringWithArgs>
  /**
   * Select the \`stringWithListArg\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithListArg?: Query.stringWithListArg$Expanded | $Select.SelectAlias.SelectAlias<Query.stringWithListArg>
  /**
   * Select the \`stringWithListArgRequired\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithListArgRequired?:
    | Query.stringWithListArgRequired
    | $Select.SelectAlias.SelectAlias<Query.stringWithListArgRequired>
  /**
   * Select the \`stringWithRequiredArg\` field on the \`Query\` object. Its type is \`String\` (a \`Scalar\`).
   */
  stringWithRequiredArg?: Query.stringWithRequiredArg | $Select.SelectAlias.SelectAlias<Query.stringWithRequiredArg>
  /**
   * Select the \`unionFooBar\` field on the \`Query\` object. Its type is Union.
   */
  unionFooBar?: Query.unionFooBar$Expanded | $Select.SelectAlias.SelectAlias<Query.unionFooBar>
  /**
   * Select the \`unionFooBarNonNull\` field on the \`Query\` object. Its type is Union.
   */
  unionFooBarNonNull?: Query.unionFooBarNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.unionFooBarNonNull>
  /**
   * Select the \`unionFooBarWithArgs\` field on the \`Query\` object. Its type is Union.
   */
  unionFooBarWithArgs?: Query.unionFooBarWithArgs$Expanded | $Select.SelectAlias.SelectAlias<Query.unionFooBarWithArgs>
  /**
   * Select the \`unionObject\` field on the \`Query\` object. Its type is Object.
   */
  unionObject?: Query.unionObject$Expanded | $Select.SelectAlias.SelectAlias<Query.unionObject>
  /**
   * Select the \`unionObjectNonNull\` field on the \`Query\` object. Its type is Object.
   */
  unionObjectNonNull?: Query.unionObjectNonNull$Expanded | $Select.SelectAlias.SelectAlias<Query.unionObjectNonNull>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Query$FragmentInline | Query$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Query$FragmentInline extends Query, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace Query {
  export type InputObjectNested$SelectionSetArguments = {
    input?: _RefDefs._InputObjectNested | undefined | null
  }
  export type InputObjectNested$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`InputObjectNested\` field.
       * No arguments are required so you may omit this.
       */
      $?: InputObjectNested$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`InputObjectNested\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type InputObjectNested$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | InputObjectNested$SelectionSet
  >

  export type InputObjectNested = $Select.Indicator.Indicator | InputObjectNested$SelectionSet

  export type InputObjectNestedNonNull$SelectionSetArguments = {
    input: _RefDefs._InputObjectNestedNonNull
  }
  export interface InputObjectNestedNonNull extends $Select.Bases.Base {
    /**
     * Arguments for \`InputObjectNestedNonNull\` field.
     * All arguments are required so you must include this.
     */
    $: InputObjectNestedNonNull$SelectionSetArguments
  }

  /**
   * This is the "expanded" version of the \`abcEnum\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type abcEnum$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type abcEnum = $Select.Indicator.NoArgsIndicator

  export type argInputObjectCircular$SelectionSetArguments = {
    input?: _RefDefs._InputObjectCircular | undefined | null
  }
  export type argInputObjectCircular$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`argInputObjectCircular\` field.
       * No arguments are required so you may omit this.
       */
      $?: argInputObjectCircular$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`argInputObjectCircular\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type argInputObjectCircular$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | argInputObjectCircular$SelectionSet
  >

  export type argInputObjectCircular = $Select.Indicator.Indicator | argInputObjectCircular$SelectionSet

  /**
   * This is the "expanded" version of the \`date\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type date = $Select.Indicator.NoArgsIndicator

  export type dateArg$SelectionSetArguments = {
    date?: $Scalar.DateDecoded | undefined | null
  }
  export type dateArg$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`dateArg\` field.
       * No arguments are required so you may omit this.
       */
      $?: dateArg$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`dateArg\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArg$Expanded = $Utilities.UnionExpanded<$Select.Indicator.Indicator | dateArg$SelectionSet>

  export type dateArg = $Select.Indicator.Indicator | dateArg$SelectionSet

  export type dateArgInputObject$SelectionSetArguments = {
    input?: _RefDefs._InputObject | undefined | null
  }
  export type dateArgInputObject$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`dateArgInputObject\` field.
       * No arguments are required so you may omit this.
       */
      $?: dateArgInputObject$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`dateArgInputObject\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgInputObject$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | dateArgInputObject$SelectionSet
  >

  export type dateArgInputObject = $Select.Indicator.Indicator | dateArgInputObject$SelectionSet

  export type dateArgList$SelectionSetArguments = {
    date?: Array<$Scalar.DateDecoded | undefined | null> | undefined | null
  }
  export type dateArgList$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`dateArgList\` field.
       * No arguments are required so you may omit this.
       */
      $?: dateArgList$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`dateArgList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateArgList$Expanded = $Utilities.UnionExpanded<$Select.Indicator.Indicator | dateArgList$SelectionSet>

  export type dateArgList = $Select.Indicator.Indicator | dateArgList$SelectionSet

  export type dateArgNonNull$SelectionSetArguments = {
    date: $Scalar.DateDecoded
  }
  export interface dateArgNonNull extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNull\` field.
     * All arguments are required so you must include this.
     */
    $: dateArgNonNull$SelectionSetArguments
  }

  export type dateArgNonNullList$SelectionSetArguments = {
    date: Array<$Scalar.DateDecoded | undefined | null>
  }
  export interface dateArgNonNullList extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNullList\` field.
     * All arguments are required so you must include this.
     */
    $: dateArgNonNullList$SelectionSetArguments
  }

  export type dateArgNonNullListNonNull$SelectionSetArguments = {
    date: Array<$Scalar.DateDecoded | undefined | null>
  }
  export interface dateArgNonNullListNonNull extends $Select.Bases.Base {
    /**
     * Arguments for \`dateArgNonNullListNonNull\` field.
     * All arguments are required so you must include this.
     */
    $: dateArgNonNullListNonNull$SelectionSetArguments
  }

  export interface dateInterface1 extends _RefDefs._DateInterface1 {}
  export type dateInterface1$Expanded = dateInterface1
  /**
   * This is the "expanded" version of the \`dateList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateList$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type dateList = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`dateListList\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateListList$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type dateListList = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`dateListNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateListNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type dateListNonNull = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`dateNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type dateNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type dateNonNull = $Select.Indicator.NoArgsIndicator

  export interface dateObject1 extends _RefDefs._DateObject1 {}
  export type dateObject1$Expanded = dateObject1
  export interface dateUnion extends _RefDefs._DateUnion {}
  export type dateUnion$Expanded = dateUnion
  export type error$SelectionSetArguments = {
    case?: string | undefined | null
  }
  export type error$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`error\` field.
       * No arguments are required so you may omit this.
       */
      $?: error$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`error\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type error$Expanded = $Utilities.UnionExpanded<$Select.Indicator.Indicator | error$SelectionSet>

  export type error = $Select.Indicator.Indicator | error$SelectionSet

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`idNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type idNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type idNonNull = $Select.Indicator.NoArgsIndicator

  export interface $interface extends _RefDefs._Interface {}
  export type $interface$Expanded = $interface
  export interface interfaceNonNull extends _RefDefs._Interface {}
  export type interfaceNonNull$Expanded = interfaceNonNull
  export interface interfaceWithArgs extends _RefDefs._Interface {
    /**
     * Arguments for \`interfaceWithArgs\` field.
     * All arguments are required so you must include this.
     */
    $: {
      id: string
    }
  }
  export type interfaceWithArgs$Expanded = interfaceWithArgs
  /**
   * This is the "expanded" version of the \`listInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listInt$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type listInt = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`listIntNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listIntNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type listIntNonNull = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`listListInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listListInt$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type listListInt = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`listListIntNonNull\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type listListIntNonNull$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type listListIntNonNull = $Select.Indicator.NoArgsIndicator

  export interface lowerCaseUnion extends _RefDefs._lowerCaseUnion {}
  export type lowerCaseUnion$Expanded = lowerCaseUnion
  export interface $object extends _RefDefs._Object1 {}
  export type $object$Expanded = $object
  export interface objectList extends _RefDefs._Object1 {}
  export type objectList$Expanded = objectList
  export interface objectListNonNull extends _RefDefs._Object1 {}
  export type objectListNonNull$Expanded = objectListNonNull
  export interface objectNested extends _RefDefs._ObjectNested {}
  export type objectNested$Expanded = objectNested
  export interface objectNonNull extends _RefDefs._Object1 {}
  export type objectNonNull$Expanded = objectNonNull
  export interface objectWithArgs extends _RefDefs._Object1 {
    /**
     * Arguments for \`objectWithArgs\` field.
     * No arguments are required so you may omit this.
     */
    $?: {
      boolean?: boolean | undefined | null
      float?: number | undefined | null
      id?: string | undefined | null
      int?: number | undefined | null
      string?: string | undefined | null
    }
  }
  export type objectWithArgs$Expanded = objectWithArgs
  export interface result extends _RefDefs._Result {
    /**
     * Arguments for \`result\` field.
     * All arguments are required so you must include this.
     */
    $: {
      $case: _RefDefs._Case
    }
  }
  export type result$Expanded = result
  export interface resultNonNull extends _RefDefs._Result {
    /**
     * Arguments for \`resultNonNull\` field.
     * No arguments are required so you may omit this.
     */
    $?: {
      $case?: _RefDefs._Case | undefined | null
    }
  }
  export type resultNonNull$Expanded = resultNonNull
  /**
   * This is the "expanded" version of the \`$string\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $string$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type $string = $Select.Indicator.NoArgsIndicator

  export type stringWithArgEnum$SelectionSetArguments = {
    $ABCEnum?: _RefDefs._ABCEnum | undefined | null
  }
  export type stringWithArgEnum$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`stringWithArgEnum\` field.
       * No arguments are required so you may omit this.
       */
      $?: stringWithArgEnum$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`stringWithArgEnum\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgEnum$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | stringWithArgEnum$SelectionSet
  >

  export type stringWithArgEnum = $Select.Indicator.Indicator | stringWithArgEnum$SelectionSet

  export type stringWithArgInputObject$SelectionSetArguments = {
    input?: _RefDefs._InputObject | undefined | null
  }
  export type stringWithArgInputObject$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`stringWithArgInputObject\` field.
       * No arguments are required so you may omit this.
       */
      $?: stringWithArgInputObject$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`stringWithArgInputObject\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgInputObject$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | stringWithArgInputObject$SelectionSet
  >

  export type stringWithArgInputObject = $Select.Indicator.Indicator | stringWithArgInputObject$SelectionSet

  export type stringWithArgInputObjectRequired$SelectionSetArguments = {
    input: _RefDefs._InputObject
  }
  export interface stringWithArgInputObjectRequired extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithArgInputObjectRequired\` field.
     * All arguments are required so you must include this.
     */
    $: stringWithArgInputObjectRequired$SelectionSetArguments
  }

  export type stringWithArgs$SelectionSetArguments = {
    boolean?: boolean | undefined | null
    float?: number | undefined | null
    id?: string | undefined | null
    int?: number | undefined | null
    string?: string | undefined | null
  }
  export type stringWithArgs$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`stringWithArgs\` field.
       * No arguments are required so you may omit this.
       */
      $?: stringWithArgs$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`stringWithArgs\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithArgs$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | stringWithArgs$SelectionSet
  >

  export type stringWithArgs = $Select.Indicator.Indicator | stringWithArgs$SelectionSet

  export type stringWithListArg$SelectionSetArguments = {
    ints?: Array<number | undefined | null> | undefined | null
  }
  export type stringWithListArg$SelectionSet = $Utilities.Simplify<
    $Select.Bases.Base & {
      /**
       * Arguments for \`stringWithListArg\` field.
       * No arguments are required so you may omit this.
       */
      $?: stringWithListArg$SelectionSetArguments
    }
  >

  /**
   * This is the "expanded" version of the \`stringWithListArg\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type stringWithListArg$Expanded = $Utilities.UnionExpanded<
    $Select.Indicator.Indicator | stringWithListArg$SelectionSet
  >

  export type stringWithListArg = $Select.Indicator.Indicator | stringWithListArg$SelectionSet

  export type stringWithListArgRequired$SelectionSetArguments = {
    ints: Array<number | undefined | null>
  }
  export interface stringWithListArgRequired extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithListArgRequired\` field.
     * All arguments are required so you must include this.
     */
    $: stringWithListArgRequired$SelectionSetArguments
  }

  export type stringWithRequiredArg$SelectionSetArguments = {
    string: string
  }
  export interface stringWithRequiredArg extends $Select.Bases.Base {
    /**
     * Arguments for \`stringWithRequiredArg\` field.
     * All arguments are required so you must include this.
     */
    $: stringWithRequiredArg$SelectionSetArguments
  }

  export interface unionFooBar extends _RefDefs._FooBarUnion {}
  export type unionFooBar$Expanded = unionFooBar
  export interface unionFooBarNonNull extends _RefDefs._FooBarUnion {}
  export type unionFooBarNonNull$Expanded = unionFooBarNonNull
  export interface unionFooBarWithArgs extends _RefDefs._FooBarUnion {
    /**
     * Arguments for \`unionFooBarWithArgs\` field.
     * No arguments are required so you may omit this.
     */
    $?: {
      id?: string | undefined | null
    }
  }
  export type unionFooBarWithArgs$Expanded = unionFooBarWithArgs
  export interface unionObject extends _RefDefs._ObjectUnion {}
  export type unionObject$Expanded = unionObject
  export interface unionObjectNonNull extends _RefDefs._ObjectUnion {}
  export type unionObjectNonNull$Expanded = unionObjectNonNull
}

//
//
//
//
//
//
// ==================================================================================================
//                                       GraphQLEnumType Types
// ==================================================================================================
//
//
//
//
//
//

/**
 * Enum documentation.
 *
 * Members
 * "A" - (DEPRECATED: Enum value A is deprecated.)
 * "B" - Enum B member documentation.
 * "C" - (DEPRECATED: Enum value C is deprecated.)
 */
export type ABCEnum = 'A' | 'B' | 'C'

export type Case = 'ErrorOne' | 'ErrorTwo' | 'Object1'

//
//
//
//
//
//
// ==================================================================================================
//                                    GraphQLInputObjectType Types
// ==================================================================================================
//
//
//
//
//
//

export interface InputObject {
  date?: $Scalar.DateDecoded | undefined | null
  dateRequired: $Scalar.DateDecoded
  id?: string | undefined | null
  idRequired: string
}

export interface InputObjectCircular {
  circular?: _RefDefs._InputObjectCircular | undefined | null
  date?: $Scalar.DateDecoded | undefined | null
}

export interface InputObjectNested {
  InputObject?: _RefDefs._InputObject | undefined | null
}

export interface InputObjectNestedNonNull {
  InputObject: _RefDefs._InputObject
}

//
//
//
//
//
//
// ==================================================================================================
//                                     GraphQLInterfaceType Types
// ==================================================================================================
//
//
//
//
//
//

// --------------
// Interface Type DateInterface1
// --------------

export interface DateInterface1 extends $Select.Bases.ObjectLike {
  date1?: DateInterface1.date1
  ___on_DateObject1?: DateObject1

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: DateInterface1$FragmentInline | DateInterface1$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateInterface1$FragmentInline
  extends DateInterface1, $Select.Directive.$Groups.InlineFragment.Fields
{}

export namespace DateInterface1 {
  /**
   * This is the "expanded" version of the \`date1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date1$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type date1 = $Select.Indicator.NoArgsIndicator
}

// --------------
// Interface Type Error
// --------------

export interface Error extends $Select.Bases.ObjectLike {
  message?: Error.message
  ___on_ErrorOne?: ErrorOne
  ___on_ErrorTwo?: ErrorTwo

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Error$FragmentInline | Error$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Error$FragmentInline extends Error, $Select.Directive.$Groups.InlineFragment.Fields {}

export namespace Error {
  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type message = $Select.Indicator.NoArgsIndicator
}

// --------------
// Interface Type Interface
// --------------

export interface Interface extends $Select.Bases.ObjectLike {
  id?: Interface.id
  ___on_Object1ImplementingInterface?: Object1ImplementingInterface
  ___on_Object2ImplementingInterface?: Object2ImplementingInterface

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Interface$FragmentInline | Interface$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a interface type and thus polymorphic,
   * the name is one of the implementor type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Interface$FragmentInline extends Interface, $Select.Directive.$Groups.InlineFragment.Fields {}

export namespace Interface {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
//
//
// ==================================================================================================
//                                      GraphQLObjectType Types
// ==================================================================================================
//
//
//
//
//
//

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                                Bar
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Bar extends $Select.Bases.ObjectLike {
  /**
   * Select the \`int\` field on the \`Bar\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  int?: Bar.int$Expanded | $Select.SelectAlias.SelectAlias<Bar.int>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Bar$FragmentInline | Bar$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Bar$FragmentInline extends Bar, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace Bar {
  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type int = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                            DateObject1
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface DateObject1 extends $Select.Bases.ObjectLike {
  /**
   * Select the \`date1\` field on the \`DateObject1\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  date1?: DateObject1.date1$Expanded | $Select.SelectAlias.SelectAlias<DateObject1.date1>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: DateObject1$FragmentInline | DateObject1$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateObject1$FragmentInline extends DateObject1, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace DateObject1 {
  /**
   * This is the "expanded" version of the \`date1\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date1$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type date1 = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                            DateObject2
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface DateObject2 extends $Select.Bases.ObjectLike {
  /**
   * Select the \`date2\` field on the \`DateObject2\` object. Its type is \`Date\` (a \`Scalar\`).
   */
  date2?: DateObject2.date2$Expanded | $Select.SelectAlias.SelectAlias<DateObject2.date2>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: DateObject2$FragmentInline | DateObject2$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface DateObject2$FragmentInline extends DateObject2, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace DateObject2 {
  /**
   * This is the "expanded" version of the \`date2\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type date2$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type date2 = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                              ErrorOne
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface ErrorOne extends $Select.Bases.ObjectLike {
  /**
   * Select the \`infoId\` field on the \`ErrorOne\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  infoId?: ErrorOne.infoId$Expanded | $Select.SelectAlias.SelectAlias<ErrorOne.infoId>
  /**
   * Select the \`message\` field on the \`ErrorOne\` object. Its type is \`String\` (a \`Scalar\`).
   */
  message?: ErrorOne.message$Expanded | $Select.SelectAlias.SelectAlias<ErrorOne.message>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: ErrorOne$FragmentInline | ErrorOne$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ErrorOne$FragmentInline extends ErrorOne, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace ErrorOne {
  /**
   * This is the "expanded" version of the \`infoId\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type infoId$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type infoId = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type message = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                              ErrorTwo
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface ErrorTwo extends $Select.Bases.ObjectLike {
  /**
   * Select the \`infoInt\` field on the \`ErrorTwo\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  infoInt?: ErrorTwo.infoInt$Expanded | $Select.SelectAlias.SelectAlias<ErrorTwo.infoInt>
  /**
   * Select the \`message\` field on the \`ErrorTwo\` object. Its type is \`String\` (a \`Scalar\`).
   */
  message?: ErrorTwo.message$Expanded | $Select.SelectAlias.SelectAlias<ErrorTwo.message>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: ErrorTwo$FragmentInline | ErrorTwo$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ErrorTwo$FragmentInline extends ErrorTwo, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace ErrorTwo {
  /**
   * This is the "expanded" version of the \`infoInt\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type infoInt$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type infoInt = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`message\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type message$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type message = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                                Foo
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

/**
 * Object documentation.
 */
export interface Foo extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`Foo\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Foo.id$Expanded | $Select.SelectAlias.SelectAlias<Foo.id>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Foo$FragmentInline | Foo$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Foo$FragmentInline extends Foo, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace Foo {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                              Object1
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Object1 extends $Select.Bases.ObjectLike {
  /**
   * Select the \`boolean\` field on the \`Object1\` object. Its type is \`Boolean\` (a \`Scalar\`).
   */
  boolean?: Object1.$boolean$Expanded | $Select.SelectAlias.SelectAlias<Object1.$boolean>
  /**
   * Select the \`float\` field on the \`Object1\` object. Its type is \`Float\` (a \`Scalar\`).
   */
  float?: Object1.float$Expanded | $Select.SelectAlias.SelectAlias<Object1.float>
  /**
   * Select the \`id\` field on the \`Object1\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Object1.id$Expanded | $Select.SelectAlias.SelectAlias<Object1.id>
  /**
   * Select the \`int\` field on the \`Object1\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  int?: Object1.int$Expanded | $Select.SelectAlias.SelectAlias<Object1.int>
  /**
   * Select the \`string\` field on the \`Object1\` object. Its type is \`String\` (a \`Scalar\`).
   */
  string?: Object1.$string$Expanded | $Select.SelectAlias.SelectAlias<Object1.$string>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Object1$FragmentInline | Object1$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object1$FragmentInline extends Object1, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace Object1 {
  /**
   * This is the "expanded" version of the \`$boolean\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $boolean$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type $boolean = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`float\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type float$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type float = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type int = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`$string\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $string$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type $string = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                    Object1ImplementingInterface
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Object1ImplementingInterface extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`Object1ImplementingInterface\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Object1ImplementingInterface.id$Expanded | $Select.SelectAlias.SelectAlias<Object1ImplementingInterface.id>
  /**
   * Select the \`int\` field on the \`Object1ImplementingInterface\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  int?: Object1ImplementingInterface.int$Expanded | $Select.SelectAlias.SelectAlias<Object1ImplementingInterface.int>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Object1ImplementingInterface$FragmentInline | Object1ImplementingInterface$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object1ImplementingInterface$FragmentInline
  extends Object1ImplementingInterface, $Select.Directive.$Groups.InlineFragment.Fields
{}

// ----------------------------------------| Fields Interfaces |

export namespace Object1ImplementingInterface {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type int = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                    Object2ImplementingInterface
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface Object2ImplementingInterface extends $Select.Bases.ObjectLike {
  /**
   * Select the \`boolean\` field on the \`Object2ImplementingInterface\` object. Its type is \`Boolean\` (a \`Scalar\`).
   */
  boolean?:
    | Object2ImplementingInterface.$boolean$Expanded
    | $Select.SelectAlias.SelectAlias<Object2ImplementingInterface.$boolean>
  /**
   * Select the \`id\` field on the \`Object2ImplementingInterface\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: Object2ImplementingInterface.id$Expanded | $Select.SelectAlias.SelectAlias<Object2ImplementingInterface.id>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Object2ImplementingInterface$FragmentInline | Object2ImplementingInterface$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface Object2ImplementingInterface$FragmentInline
  extends Object2ImplementingInterface, $Select.Directive.$Groups.InlineFragment.Fields
{}

// ----------------------------------------| Fields Interfaces |

export namespace Object2ImplementingInterface {
  /**
   * This is the "expanded" version of the \`$boolean\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type $boolean$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type $boolean = $Select.Indicator.NoArgsIndicator

  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                            ObjectNested
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectNested extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`ObjectNested\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: ObjectNested.id$Expanded | $Select.SelectAlias.SelectAlias<ObjectNested.id>
  /**
   * Select the \`object\` field on the \`ObjectNested\` object. Its type is Object.
   */
  object?: ObjectNested.$object$Expanded | $Select.SelectAlias.SelectAlias<ObjectNested.$object>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: ObjectNested$FragmentInline | ObjectNested$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectNested$FragmentInline extends ObjectNested, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace ObjectNested {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator

  export interface $object extends _RefDefs._Object1 {}
  export type $object$Expanded = $object
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                            ObjectUnion
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface ObjectUnion extends $Select.Bases.ObjectLike {
  /**
   * Select the \`fooBarUnion\` field on the \`ObjectUnion\` object. Its type is Union.
   */
  fooBarUnion?: ObjectUnion.fooBarUnion$Expanded | $Select.SelectAlias.SelectAlias<ObjectUnion.fooBarUnion>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: ObjectUnion$FragmentInline | ObjectUnion$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface ObjectUnion$FragmentInline extends ObjectUnion, $Select.Directive.$Groups.InlineFragment.Fields {}

// ----------------------------------------| Fields Interfaces |

export namespace ObjectUnion {
  export interface fooBarUnion extends _RefDefs._FooBarUnion {}
  export type fooBarUnion$Expanded = fooBarUnion
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                          lowerCaseObject
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface lowerCaseObject extends $Select.Bases.ObjectLike {
  /**
   * Select the \`id\` field on the \`lowerCaseObject\` object. Its type is \`ID\` (a \`Scalar\`).
   */
  id?: lowerCaseObject.id$Expanded | $Select.SelectAlias.SelectAlias<lowerCaseObject.id>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: lowerCaseObject$FragmentInline | lowerCaseObject$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface lowerCaseObject$FragmentInline
  extends lowerCaseObject, $Select.Directive.$Groups.InlineFragment.Fields
{}

// ----------------------------------------| Fields Interfaces |

export namespace lowerCaseObject {
  /**
   * This is the "expanded" version of the \`id\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type id$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type id = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
// GRAPHQL SELECTION SET
// OBJECT
// --------------------------------------------------------------------------------------------------
//                                          lowerCaseObject2
// --------------------------------------------------------------------------------------------------
//
//

// ----------------------------------------| Entrypoint Interface |

export interface lowerCaseObject2 extends $Select.Bases.ObjectLike {
  /**
   * Select the \`int\` field on the \`lowerCaseObject2\` object. Its type is \`Int\` (a \`Scalar\`).
   */
  int?: lowerCaseObject2.int$Expanded | $Select.SelectAlias.SelectAlias<lowerCaseObject2.int>

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: lowerCaseObject2$FragmentInline | lowerCaseObject2$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}

export interface lowerCaseObject2$FragmentInline
  extends lowerCaseObject2, $Select.Directive.$Groups.InlineFragment.Fields
{}

// ----------------------------------------| Fields Interfaces |

export namespace lowerCaseObject2 {
  /**
   * This is the "expanded" version of the \`int\` type. It is identical except for the fact
   * that IDEs will display its contents (a union type) directly, rather than the name of this type.
   * In some cases, this is a preferable DX, making the types easier to read for users.
   */
  export type int$Expanded = $Select.Indicator.NoArgsIndicator$Expanded

  export type int = $Select.Indicator.NoArgsIndicator
}

//
//
//
//
//
//
// ==================================================================================================
//                                       GraphQLUnionType Types
// ==================================================================================================
//
//
//
//
//
//

export interface DateUnion {
  ___on_DateObject1?: DateObject1
  ___on_DateObject2?: DateObject2

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: DateUnion$FragmentInline | DateUnion$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}
export interface DateUnion$FragmentInline extends DateUnion, $Select.Directive.$Groups.InlineFragment.Fields {}

/**
 * Union documentation.
 */
export interface FooBarUnion {
  ___on_Bar?: Bar
  ___on_Foo?: Foo

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: FooBarUnion$FragmentInline | FooBarUnion$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}
export interface FooBarUnion$FragmentInline extends FooBarUnion, $Select.Directive.$Groups.InlineFragment.Fields {}

export interface Result {
  ___on_ErrorOne?: ErrorOne
  ___on_ErrorTwo?: ErrorTwo
  ___on_Object1?: Object1

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: Result$FragmentInline | Result$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}
export interface Result$FragmentInline extends Result, $Select.Directive.$Groups.InlineFragment.Fields {}

export interface lowerCaseUnion {
  ___on_lowerCaseObject?: lowerCaseObject
  ___on_lowerCaseObject2?: lowerCaseObject2

  /**
   * Inline fragments for field groups.
   *
   * Generally a niche feature. This can be useful for example to apply an \`@include\` directive to a subset of the
   * selection set in turn allowing you to pass a variable to opt in/out of that selection during execution on the server.
   *
   * @see https://spec.graphql.org/draft/#sec-Inline-Fragments
   */
  ___?: lowerCaseUnion$FragmentInline | lowerCaseUnion$FragmentInline[]

  /**
   * A meta field. Is the name of the type being selected. Since this is a union type and thus polymorphic,
   * the name is one of the member type names, whichever is ultimately returned at runtime.
   *
   * @see https://graphql.org/learn/queries/#meta-fields
   */
  __typename?:
    | $Select.Indicator.NoArgsIndicator$Expanded
    | $Select.SelectAlias.SelectAlias<$Select.Indicator.NoArgsIndicator>
}
export interface lowerCaseUnion$FragmentInline
  extends lowerCaseUnion, $Select.Directive.$Groups.InlineFragment.Fields
{}

/**
 * [1] These definitions serve to allow field selection interfaces to extend their respective object type without
 *     name clashing between the field name and the object name.
 *
 *     For example imagine \`Query.Foo\` field with type also called \`Foo\`. Our generated interfaces for each field
 *     would end up with an error of \`export interface Foo extends Foo ...\`
 */
export namespace _RefDefs {
  export type _Mutation = Mutation
  export type _Query = Query
  export type _ABCEnum = ABCEnum
  export type _Case = Case
  export type _InputObject = InputObject
  export type _InputObjectCircular = InputObjectCircular
  export type _InputObjectNested = InputObjectNested
  export type _InputObjectNestedNonNull = InputObjectNestedNonNull
  export type _DateInterface1 = DateInterface1
  export type _Error = Error
  export type _Interface = Interface
  export type _Bar = Bar
  export type _DateObject1 = DateObject1
  export type _DateObject2 = DateObject2
  export type _ErrorOne = ErrorOne
  export type _ErrorTwo = ErrorTwo
  export type _Foo = Foo
  export type _Object1 = Object1
  export type _Object1ImplementingInterface = Object1ImplementingInterface
  export type _Object2ImplementingInterface = Object2ImplementingInterface
  export type _ObjectNested = ObjectNested
  export type _ObjectUnion = ObjectUnion
  export type _lowerCaseObject = lowerCaseObject
  export type _lowerCaseObject2 = lowerCaseObject2
  export type _DateUnion = DateUnion
  export type _FooBarUnion = FooBarUnion
  export type _Result = Result
  export type _lowerCaseUnion = lowerCaseUnion
}
"
`;
