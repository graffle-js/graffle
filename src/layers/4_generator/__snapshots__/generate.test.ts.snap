// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`schema2 1`] = `
"import { createPrefilled } from '../../../../../../src/entrypoints/client.js'
import { defaultSchemaUrl } from './Data.js'
import { schemaDrivenDataMap } from './SchemaDrivenDataMap.js'

export const create = createPrefilled(\`default\`, schemaDrivenDataMap, defaultSchemaUrl)
"
`;

exports[`schema2 2`] = `
"export * as Graffle from './_.js'
"
`;

exports[`schema2 3`] = `
"// We import the global module for good measure although it is not clear it is always needed.
// It at least helps with Twoslash wherein without this import here Twoslash will not include the global module.
// In real TypeScript projects it seems the global module is included automatically. But there could be certain tsconfig
// setups where this still indeed does help.
import './modules/Global.js'

export { create } from './modules/Client.js'
export { isError } from './modules/Error.js'
export { Select } from './modules/Select.js'
export * as SelectionSets from './modules/SelectionSets.js'
"
`;

exports[`schema2 4`] = `
"type Include<T, U> = Exclude<T, Exclude<T, U>>
type ObjectWithTypeName = { __typename: string }
const ErrorObjectsTypeNameSelectedEnum = {
  ErrorOne: { __typename: 'ErrorOne' },
  ErrorTwo: { __typename: 'ErrorTwo' },
} as const

const ErrorObjectsTypeNameSelected = Object.values(ErrorObjectsTypeNameSelectedEnum)

type ErrorObjectsTypeNameSelected = (typeof ErrorObjectsTypeNameSelected)[number]
export const isError = <$Value>(value: $Value): value is Include<$Value, ErrorObjectsTypeNameSelected> => {
  return typeof value === \`object\` && value !== null && \`__typename\` in value
    && ErrorObjectsTypeNameSelected.some(_ => _.__typename === value.__typename)
}
"
`;

exports[`schema2 5`] = `
"import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import * as Data from './Data.js'
import type { Index } from './SchemaIndex.js'
import type * as SelectionSets from './SelectionSets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                              Runtime
// ==================================================================================================
//
//
//
//
//
//
import { createSelect } from '../../../../../../src/entrypoints/client.js'
export const Select = createSelect(Data.Name)

//
//
//
//
//
//
// ==================================================================================================
//                                             Buildtime
// ==================================================================================================
//
//
//
//
//
//

export namespace Select {
  // Root Types
  // ----------
  export type Mutation<$SelectionSet extends SelectionSets.Mutation> = InferResult.Root<
    $SelectionSet,
    Index,
    'Mutation'
  >
  export type Query<$SelectionSet extends SelectionSets.Query> = InferResult.Root<$SelectionSet, Index, 'Query'>
  // Object Types
  // ------------
  export type Bar<$SelectionSet extends SelectionSets.Bar> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['Bar']
  >
  export type DateObject1<$SelectionSet extends SelectionSets.DateObject1> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['DateObject1']
  >
  export type DateObject2<$SelectionSet extends SelectionSets.DateObject2> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['DateObject2']
  >
  export type ErrorOne<$SelectionSet extends SelectionSets.ErrorOne> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['ErrorOne']
  >
  export type ErrorTwo<$SelectionSet extends SelectionSets.ErrorTwo> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['ErrorTwo']
  >
  export type Foo<$SelectionSet extends SelectionSets.Foo> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['Foo']
  >
  export type Object1<$SelectionSet extends SelectionSets.Object1> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['Object1']
  >
  export type Object1ImplementingInterface<$SelectionSet extends SelectionSets.Object1ImplementingInterface> =
    InferResult.Object<$SelectionSet, Index, Index['allTypes']['Object1ImplementingInterface']>
  export type Object2ImplementingInterface<$SelectionSet extends SelectionSets.Object2ImplementingInterface> =
    InferResult.Object<$SelectionSet, Index, Index['allTypes']['Object2ImplementingInterface']>
  export type ObjectNested<$SelectionSet extends SelectionSets.ObjectNested> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['ObjectNested']
  >
  export type ObjectUnion<$SelectionSet extends SelectionSets.ObjectUnion> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['ObjectUnion']
  >
  export type lowerCaseObject<$SelectionSet extends SelectionSets.lowerCaseObject> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['lowerCaseObject']
  >
  export type lowerCaseObject2<$SelectionSet extends SelectionSets.lowerCaseObject2> = InferResult.Object<
    $SelectionSet,
    Index,
    Index['allTypes']['lowerCaseObject2']
  >
  // Union Types
  // -----------
  export type DateUnion<$SelectionSet extends SelectionSets.DateUnion> = InferResult.Union<
    $SelectionSet,
    Index,
    Index['allTypes']['DateUnion']
  >
  export type FooBarUnion<$SelectionSet extends SelectionSets.FooBarUnion> = InferResult.Union<
    $SelectionSet,
    Index,
    Index['allTypes']['FooBarUnion']
  >
  export type Result<$SelectionSet extends SelectionSets.Result> = InferResult.Union<
    $SelectionSet,
    Index,
    Index['allTypes']['Result']
  >
  export type lowerCaseUnion<$SelectionSet extends SelectionSets.lowerCaseUnion> = InferResult.Union<
    $SelectionSet,
    Index,
    Index['allTypes']['lowerCaseUnion']
  >
  // Interface Types
  // ---------------
  export type DateInterface1<$SelectionSet extends SelectionSets.DateInterface1> = InferResult.Interface<
    $SelectionSet,
    Index,
    Index['allTypes']['DateInterface1']
  >
  export type Error<$SelectionSet extends SelectionSets.Error> = InferResult.Interface<
    $SelectionSet,
    Index,
    Index['allTypes']['Error']
  >
  export type Interface<$SelectionSet extends SelectionSets.Interface> = InferResult.Interface<
    $SelectionSet,
    Index,
    Index['allTypes']['Interface']
  >
}
"
`;

exports[`schema2 6`] = `
"/* eslint-disable */
import type * as Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as Data from './Data.js'
import type * as MethodsRoot from './MethodsRoot.js'
import type * as Schema from './SchemaBuildtime.js'

export interface Index {
  name: Data.Name
  RootTypesPresent: ['Mutation', 'Query']
  RootUnion: Schema.Root.Mutation | Schema.Root.Query
  Root: {
    Query: Schema.Root.Query
    Mutation: Schema.Root.Mutation
    Subscription: null
  }
  allTypes: {
    Mutation: Schema.Root.Mutation
    Query: Schema.Root.Query
    ABCEnum: Schema.Enum.ABCEnum
    Case: Schema.Enum.Case
    Bar: Schema.Object.Bar
    DateObject1: Schema.Object.DateObject1
    DateObject2: Schema.Object.DateObject2
    ErrorOne: Schema.Object.ErrorOne
    ErrorTwo: Schema.Object.ErrorTwo
    Foo: Schema.Object.Foo
    Object1: Schema.Object.Object1
    Object1ImplementingInterface: Schema.Object.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object.Object2ImplementingInterface
    ObjectNested: Schema.Object.ObjectNested
    ObjectUnion: Schema.Object.ObjectUnion
    lowerCaseObject: Schema.Object.lowerCaseObject
    lowerCaseObject2: Schema.Object.lowerCaseObject2
    DateUnion: Schema.Union.DateUnion
    FooBarUnion: Schema.Union.FooBarUnion
    Result: Schema.Union.Result
    lowerCaseUnion: Schema.Union.lowerCaseUnion
    DateInterface1: Schema.Interface.DateInterface1
    Error: Schema.Interface.Error
    Interface: Schema.Interface.Interface
  }
  objects: {
    Bar: Schema.Object.Bar
    DateObject1: Schema.Object.DateObject1
    DateObject2: Schema.Object.DateObject2
    ErrorOne: Schema.Object.ErrorOne
    ErrorTwo: Schema.Object.ErrorTwo
    Foo: Schema.Object.Foo
    Object1: Schema.Object.Object1
    Object1ImplementingInterface: Schema.Object.Object1ImplementingInterface
    Object2ImplementingInterface: Schema.Object.Object2ImplementingInterface
    ObjectNested: Schema.Object.ObjectNested
    ObjectUnion: Schema.Object.ObjectUnion
    lowerCaseObject: Schema.Object.lowerCaseObject
    lowerCaseObject2: Schema.Object.lowerCaseObject2
  }
  unions: {
    DateUnion: Schema.Union.DateUnion
    FooBarUnion: Schema.Union.FooBarUnion
    Result: Schema.Union.Result
    lowerCaseUnion: Schema.Union.lowerCaseUnion
  }
  interfaces: {
    DateInterface1: Schema.Interface.DateInterface1
    Error: Schema.Interface.Error
    Interface: Schema.Interface.Interface
  }
  customScalars: Utilities.SchemaIndexBase['customScalars']
  error: {
    objects: {
      ErrorOne: Schema.Object.ErrorOne
      ErrorTwo: Schema.Object.ErrorTwo
    }
    objectsTypename: {
      ErrorOne: { __typename: 'ErrorOne' }
      ErrorTwo: { __typename: 'ErrorTwo' }
    }
    rootResultFields: {
      Subscription: {}
      Mutation: {}
      Query: {
        result: 'result'
        resultNonNull: 'resultNonNull'
      }
    }
  }
}
"
`;

exports[`schema2 7`] = `
"import type * as $ from '../../../../../../src/entrypoints/schema.js'
import type * as $Scalar from './Scalar.js'

// ------------------------------------------------------------ //
//                             Root                             //
// ------------------------------------------------------------ //
export namespace Root {
  export type Mutation = $.Output.ObjectMutation<{
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    idNonNull: $.Field<'idNonNull', $Scalar.ID, null>
  }>

  export type Query = $.Output.ObjectQuery<{
    InputObjectNested: $.Field<
      'InputObjectNested',
      $.Output.Nullable<$Scalar.ID>,
      $.Args<{
        input: $.Input.Field<$.Input.Nullable<InputObject.InputObjectNested>>
      }, true>
    >
    InputObjectNestedNonNull: $.Field<
      'InputObjectNestedNonNull',
      $.Output.Nullable<$Scalar.ID>,
      $.Args<{
        input: $.Input.Field<InputObject.InputObjectNestedNonNull>
      }, false>
    >
    /**
     * Query enum field documentation.
     */
    abcEnum: $.Field<'abcEnum', $.Output.Nullable<Enum.ABCEnum>, null>
    argInputObjectCircular: $.Field<
      'argInputObjectCircular',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        input: $.Input.Field<$.Input.Nullable<InputObject.InputObjectCircular>>
      }, true>
    >
    date: $.Field<'date', $.Output.Nullable<$Scalar.Date>, null>
    dateArg: $.Field<
      'dateArg',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
      }, true>
    >
    dateArgInputObject: $.Field<
      'dateArgInputObject',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        input: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
      }, true>
    >
    dateArgList: $.Field<
      'dateArgList',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        date: $.Input.Field<$.Input.Nullable<$.Input.List<$Scalar.Date>>>
      }, true>
    >
    dateArgNonNull: $.Field<
      'dateArgNonNull',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        date: $.Input.Field<$Scalar.Date>
      }, false>
    >
    dateArgNonNullList: $.Field<
      'dateArgNonNullList',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        date: $.Input.Field<$.Input.List<$.Input.Nullable<$Scalar.Date>>>
      }, false>
    >
    dateArgNonNullListNonNull: $.Field<
      'dateArgNonNullListNonNull',
      $.Output.Nullable<$Scalar.Date>,
      $.Args<{
        date: $.Input.Field<$.Input.List<$Scalar.Date>>
      }, false>
    >
    dateInterface1: $.Field<'dateInterface1', $.Output.Nullable<Interface.DateInterface1>, null>
    dateList: $.Field<'dateList', $.Output.Nullable<$.Output.List<$Scalar.Date>>, null>
    dateListList: $.Field<'dateListList', $.Output.Nullable<$.Output.List<$.Output.List<$Scalar.Date>>>, null>
    dateListNonNull: $.Field<'dateListNonNull', $.Output.List<$Scalar.Date>, null>
    dateNonNull: $.Field<'dateNonNull', $Scalar.Date, null>
    dateObject1: $.Field<'dateObject1', $.Output.Nullable<Object.DateObject1>, null>
    dateUnion: $.Field<'dateUnion', $.Output.Nullable<Union.DateUnion>, null>
    error: $.Field<
      'error',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        case: $.Input.Field<$.Input.Nullable<$Scalar.String>>
      }, true>
    >
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    idNonNull: $.Field<'idNonNull', $Scalar.ID, null>
    interface: $.Field<'interface', $.Output.Nullable<Interface.Interface>, null>
    interfaceNonNull: $.Field<'interfaceNonNull', Interface.Interface, null>
    interfaceWithArgs: $.Field<
      'interfaceWithArgs',
      $.Output.Nullable<Interface.Interface>,
      $.Args<{
        id: $.Input.Field<$Scalar.ID>
      }, false>
    >
    listInt: $.Field<'listInt', $.Output.Nullable<$.Output.List<$.Output.Nullable<$Scalar.Int>>>, null>
    listIntNonNull: $.Field<'listIntNonNull', $.Output.List<$Scalar.Int>, null>
    listListInt: $.Field<
      'listListInt',
      $.Output.Nullable<$.Output.List<$.Output.Nullable<$.Output.List<$.Output.Nullable<$Scalar.Int>>>>>,
      null
    >
    listListIntNonNull: $.Field<'listListIntNonNull', $.Output.List<$.Output.List<$Scalar.Int>>, null>
    lowerCaseUnion: $.Field<'lowerCaseUnion', $.Output.Nullable<Union.lowerCaseUnion>, null>
    object: $.Field<'object', $.Output.Nullable<Object.Object1>, null>
    objectList: $.Field<'objectList', $.Output.Nullable<$.Output.List<Object.Object1>>, null>
    objectListNonNull: $.Field<'objectListNonNull', $.Output.List<Object.Object1>, null>
    objectNested: $.Field<'objectNested', $.Output.Nullable<Object.ObjectNested>, null>
    objectNonNull: $.Field<'objectNonNull', Object.Object1, null>
    objectWithArgs: $.Field<
      'objectWithArgs',
      $.Output.Nullable<Object.Object1>,
      $.Args<{
        boolean: $.Input.Field<$.Input.Nullable<$Scalar.Boolean>>
        float: $.Input.Field<$.Input.Nullable<$Scalar.Float>>
        id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
        int: $.Input.Field<$.Input.Nullable<$Scalar.Int>>
        string: $.Input.Field<$.Input.Nullable<$Scalar.String>>
      }, true>
    >
    result: $.Field<
      'result',
      $.Output.Nullable<Union.Result>,
      $.Args<{
        case: $.Input.Field<Enum.Case>
      }, false>
    >
    resultNonNull: $.Field<
      'resultNonNull',
      Union.Result,
      $.Args<{
        case: $.Input.Field<$.Input.Nullable<Enum.Case>>
      }, true>
    >
    string: $.Field<'string', $.Output.Nullable<$Scalar.String>, null>
    stringWithArgEnum: $.Field<
      'stringWithArgEnum',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        ABCEnum: $.Input.Field<$.Input.Nullable<Enum.ABCEnum>>
      }, true>
    >
    stringWithArgInputObject: $.Field<
      'stringWithArgInputObject',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        input: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
      }, true>
    >
    stringWithArgInputObjectRequired: $.Field<
      'stringWithArgInputObjectRequired',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        input: $.Input.Field<InputObject.InputObject>
      }, false>
    >
    /**
     * The given arguments are reflected back as a JSON string.
     */
    stringWithArgs: $.Field<
      'stringWithArgs',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        boolean: $.Input.Field<$.Input.Nullable<$Scalar.Boolean>>
        float: $.Input.Field<$.Input.Nullable<$Scalar.Float>>
        id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
        int: $.Input.Field<$.Input.Nullable<$Scalar.Int>>
        string: $.Input.Field<$.Input.Nullable<$Scalar.String>>
      }, true>
    >
    stringWithListArg: $.Field<
      'stringWithListArg',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        ints: $.Input.Field<$.Input.Nullable<$.Input.List<$.Input.Nullable<$Scalar.Int>>>>
      }, true>
    >
    stringWithListArgRequired: $.Field<
      'stringWithListArgRequired',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        ints: $.Input.Field<$.Input.List<$Scalar.Int>>
      }, false>
    >
    stringWithRequiredArg: $.Field<
      'stringWithRequiredArg',
      $.Output.Nullable<$Scalar.String>,
      $.Args<{
        string: $.Input.Field<$Scalar.String>
      }, false>
    >
    unionFooBar: $.Field<'unionFooBar', $.Output.Nullable<Union.FooBarUnion>, null>
    unionFooBarNonNull: $.Field<'unionFooBarNonNull', Union.FooBarUnion, null>
    unionFooBarWithArgs: $.Field<
      'unionFooBarWithArgs',
      $.Output.Nullable<Union.FooBarUnion>,
      $.Args<{
        id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
      }, true>
    >
    unionObject: $.Field<'unionObject', $.Output.Nullable<Object.ObjectUnion>, null>
    unionObjectNonNull: $.Field<'unionObjectNonNull', Object.ObjectUnion, null>
  }>
}
// ------------------------------------------------------------ //
//                             Enum                             //
// ------------------------------------------------------------ //
export namespace Enum {
  /**
   * Enum documentation.
   *
   * Members
   * "A" - (DEPRECATED: Enum value A is deprecated.)
   * "B" - Enum B member documentation.
   * "C" - (DEPRECATED: Enum value C is deprecated.)
   */
  export type ABCEnum = $.Enum<'ABCEnum', ['A', 'B', 'C']>

  export type Case = $.Enum<'Case', ['ErrorOne', 'ErrorTwo', 'Object1']>
}
// ------------------------------------------------------------ //
//                         InputObject                          //
// ------------------------------------------------------------ //
export namespace InputObject {
  export type InputObject = $.InputObject<'InputObject', {
    date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
    dateRequired: $.Input.Field<$Scalar.Date>
    id: $.Input.Field<$.Input.Nullable<$Scalar.ID>>
    idRequired: $.Input.Field<$Scalar.ID>
  }, true>

  export type InputObjectCircular = $.InputObject<'InputObjectCircular', {
    circular: $.Input.Field<$.Input.Nullable<InputObject.InputObjectCircular>>
    date: $.Input.Field<$.Input.Nullable<$Scalar.Date>>
  }, true>

  export type InputObjectNested = $.InputObject<'InputObjectNested', {
    InputObject: $.Input.Field<$.Input.Nullable<InputObject.InputObject>>
  }, true>

  export type InputObjectNestedNonNull = $.InputObject<'InputObjectNestedNonNull', {
    InputObject: $.Input.Field<InputObject.InputObject>
  }, false>
}
// ------------------------------------------------------------ //
//                          Interface                           //
// ------------------------------------------------------------ //
export namespace Interface {
  export type DateInterface1 = $.Interface<'DateInterface1', {
    date1: $.Field<'date1', $.Output.Nullable<$Scalar.Date>, null>
  }, [Object.DateObject1]>

  export type Error = $.Interface<'Error', {
    message: $.Field<'message', $Scalar.String, null>
  }, [Object.ErrorOne, Object.ErrorTwo]>

  export type Interface = $.Interface<'Interface', {
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
  }, [Object.Object1ImplementingInterface, Object.Object2ImplementingInterface]>
}
// ------------------------------------------------------------ //
//                            Object                            //
// ------------------------------------------------------------ //
export namespace Object {
  export type Bar = $.Object$2<'Bar', {
    int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
  }>

  export type DateObject1 = $.Object$2<'DateObject1', {
    date1: $.Field<'date1', $.Output.Nullable<$Scalar.Date>, null>
  }>

  export type DateObject2 = $.Object$2<'DateObject2', {
    date2: $.Field<'date2', $.Output.Nullable<$Scalar.Date>, null>
  }>

  export type ErrorOne = $.Object$2<'ErrorOne', {
    infoId: $.Field<'infoId', $.Output.Nullable<$Scalar.ID>, null>
    message: $.Field<'message', $Scalar.String, null>
  }>

  export type ErrorTwo = $.Object$2<'ErrorTwo', {
    infoInt: $.Field<'infoInt', $.Output.Nullable<$Scalar.Int>, null>
    message: $.Field<'message', $Scalar.String, null>
  }>

  /**
   * Object documentation.
   */
  export type Foo = $.Object$2<'Foo', {
    /**
     * Field documentation.
     *
     * @deprecated Field a is deprecated.
     */
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
  }>

  export type Object1 = $.Object$2<'Object1', {
    boolean: $.Field<'boolean', $.Output.Nullable<$Scalar.Boolean>, null>
    float: $.Field<'float', $.Output.Nullable<$Scalar.Float>, null>
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
    string: $.Field<'string', $.Output.Nullable<$Scalar.String>, null>
  }>

  export type Object1ImplementingInterface = $.Object$2<'Object1ImplementingInterface', {
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
  }>

  export type Object2ImplementingInterface = $.Object$2<'Object2ImplementingInterface', {
    boolean: $.Field<'boolean', $.Output.Nullable<$Scalar.Boolean>, null>
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
  }>

  export type ObjectNested = $.Object$2<'ObjectNested', {
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
    object: $.Field<'object', $.Output.Nullable<Object.Object1>, null>
  }>

  export type ObjectUnion = $.Object$2<'ObjectUnion', {
    fooBarUnion: $.Field<'fooBarUnion', $.Output.Nullable<Union.FooBarUnion>, null>
  }>

  export type lowerCaseObject = $.Object$2<'lowerCaseObject', {
    id: $.Field<'id', $.Output.Nullable<$Scalar.ID>, null>
  }>

  export type lowerCaseObject2 = $.Object$2<'lowerCaseObject2', {
    int: $.Field<'int', $.Output.Nullable<$Scalar.Int>, null>
  }>
}
// ------------------------------------------------------------ //
//                            Union                             //
// ------------------------------------------------------------ //
export namespace Union {
  export type DateUnion = $.Union<'DateUnion', [Object.DateObject1, Object.DateObject2]>

  /**
   * Union documentation.
   */
  export type FooBarUnion = $.Union<'FooBarUnion', [Object.Bar, Object.Foo]>

  export type Result = $.Union<'Result', [Object.ErrorOne, Object.ErrorTwo, Object.Object1]>

  export type lowerCaseUnion = $.Union<'lowerCaseUnion', [Object.lowerCaseObject, Object.lowerCaseObject2]>
}
"
`;

exports[`schema2 8`] = `
"import type { Schema } from '../../../../../../src/entrypoints/schema.js'
import * as CustomScalars from '../../../../customScalarCodecs.js'

export * from '../../../../../../src/layers/1_Schema/Hybrid/types/Scalar/Scalar.js'
export * from '../../../../customScalarCodecs.js'
export { Date } from '../../../../customScalarCodecs.js'

//
//
//
//
// CUSTOM SCALAR TYPE
// DATE
// --------------------------------------------------------------------------------------------------
//                                                Date
// --------------------------------------------------------------------------------------------------
//
//

export type Date = typeof CustomScalars.Date
// Without this we get error:
// "Exported type alias 'DateDecoded' has or is using private name 'Date'."
type Date_ = typeof CustomScalars.Date
export type DateDecoded = Schema.Scalar.GetDecoded<Date_>
export type DateEncoded = Schema.Scalar.GetEncoded<Date_>
"
`;

exports[`schema2 9`] = `
"import type * as $Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import * as $Scalar from './Scalar.js'
//
//
//
//
//
//
// ==================================================================================================
//                                         GraphQLScalarType
// ==================================================================================================
//
//
//
//
//
//

const Int = $Scalar.Int

const String = $Scalar.String

const ID = $Scalar.ID

const Boolean = $Scalar.Boolean

const Float = $Scalar.Float

//
//
//
//
//
//
// ==================================================================================================
//                                      GraphQLScalarTypeCustom
// ==================================================================================================
//
//
//
//
//
//

const Date = $Scalar.Date

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLEnumType
// ==================================================================================================
//
//
//
//
//
//

const ABCEnum: $Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ABCEnum',
}

const Case: $Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'Case',
}

//
//
//
//
//
//
// ==================================================================================================
//                                       GraphQLInputObjectType
// ==================================================================================================
//
//
//
//
//
//

const InputObject: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObject',
  fcs: ['date', 'dateRequired'],
  f: {
    date: {
      nt: Date,
    },
    dateRequired: {
      nt: Date,
    },
    id: {},
    idRequired: {},
  },
}

const InputObjectCircular: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectCircular',
  fcs: ['circular', 'date'],
  f: {
    circular: {
      // nt: InputObjectCircular, <-- Assigned later to avoid potential circular dependency.
    },
    date: {
      nt: Date,
    },
  },
}

const InputObjectNested: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNested',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const InputObjectNestedNonNull: $Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InputObjectNestedNonNull',
  fcs: ['InputObject'],
  f: {
    InputObject: {
      // nt: InputObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                         GraphQLObjectType
// ==================================================================================================
//
//
//
//
//
//

const Bar: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

const DateObject1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date1: {
      nt: Date,
    },
  },
}

const DateObject2: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    date2: {
      nt: Date,
    },
  },
}

const ErrorOne: $Utilities.SchemaDrivenDataMap.OutputObject = {
  e: 1,
  f: {
    infoId: {},
    message: {},
  },
}

const ErrorTwo: $Utilities.SchemaDrivenDataMap.OutputObject = {
  e: 1,
  f: {
    infoInt: {},
    message: {},
  },
}

const Foo: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const Object1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    boolean: {},
    float: {},
    id: {},
    int: {},
    string: {},
  },
}

const Object1ImplementingInterface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    int: {},
  },
}

const Object2ImplementingInterface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    boolean: {},
    id: {},
  },
}

const ObjectNested: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ObjectUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    fooBarUnion: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const lowerCaseObject: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
  },
}

const lowerCaseObject2: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    int: {},
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                        GraphQLInterfaceType
// ==================================================================================================
//
//
//
//
//
//

const DateInterface1: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
  },
}

const Error: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Interface: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLUnionType
// ==================================================================================================
//
//
//
//
//
//

const DateUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DateObject1.f,
    ...DateObject2.f,
  },
}

const FooBarUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const Result: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const lowerCaseUnion: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

//
//
//
//
//
//
// ==================================================================================================
//                                          GraphQLRootType
// ==================================================================================================
//
//
//
//
//
//

const Mutation: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    idNonNull: {},
  },
}

const Query: $Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    InputObjectNested: {
      a: {
        input: {
          nt: InputObjectNested,
          it: [0],
        },
      },
    },
    InputObjectNestedNonNull: {
      a: {
        input: {
          nt: InputObjectNestedNonNull,
          it: [1],
        },
      },
    },
    abcEnum: {},
    argInputObjectCircular: {
      a: {
        input: {
          nt: InputObjectCircular,
          it: [0],
        },
      },
    },
    date: {
      nt: Date,
    },
    dateArg: {
      a: {
        date: {
          nt: Date,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
      nt: Date,
    },
    dateArgList: {
      a: {
        date: {
          nt: Date,
          it: [0, [1]],
        },
      },
      nt: Date,
    },
    dateArgNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1],
        },
      },
      nt: Date,
    },
    dateArgNonNullList: {
      a: {
        date: {
          nt: Date,
          it: [1, [0]],
        },
      },
      nt: Date,
    },
    dateArgNonNullListNonNull: {
      a: {
        date: {
          nt: Date,
          it: [1, [1]],
        },
      },
      nt: Date,
    },
    dateInterface1: {
      // nt: DateInterface1, <-- Assigned later to avoid potential circular dependency.
    },
    dateList: {
      nt: Date,
    },
    dateListList: {
      nt: Date,
    },
    dateListNonNull: {
      nt: Date,
    },
    dateNonNull: {
      nt: Date,
    },
    dateObject1: {
      // nt: DateObject1, <-- Assigned later to avoid potential circular dependency.
    },
    dateUnion: {
      // nt: DateUnion, <-- Assigned later to avoid potential circular dependency.
    },
    error: {
      a: {
        case: {
          nt: String,
          it: [0],
        },
      },
    },
    id: {},
    idNonNull: {},
    interface: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceNonNull: {
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    interfaceWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [1],
        },
      },
      // nt: Interface, <-- Assigned later to avoid potential circular dependency.
    },
    listInt: {},
    listIntNonNull: {},
    listListInt: {},
    listListIntNonNull: {},
    lowerCaseUnion: {
      // nt: lowerCaseUnion, <-- Assigned later to avoid potential circular dependency.
    },
    object: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectList: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectListNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectNested: {
      // nt: ObjectNested, <-- Assigned later to avoid potential circular dependency.
    },
    objectNonNull: {
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    objectWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
      // nt: Object1, <-- Assigned later to avoid potential circular dependency.
    },
    result: {
      a: {
        case: {
          nt: Case,
          it: [1],
        },
      },
      r: 1,
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    resultNonNull: {
      a: {
        case: {
          nt: Case,
          it: [0],
        },
      },
      r: 1,
      // nt: Result, <-- Assigned later to avoid potential circular dependency.
    },
    string: {},
    stringWithArgEnum: {
      a: {
        ABCEnum: {
          nt: ABCEnum,
          it: [0],
        },
      },
    },
    stringWithArgInputObject: {
      a: {
        input: {
          nt: InputObject,
          it: [0],
        },
      },
    },
    stringWithArgInputObjectRequired: {
      a: {
        input: {
          nt: InputObject,
          it: [1],
        },
      },
    },
    stringWithArgs: {
      a: {
        boolean: {
          nt: Boolean,
          it: [0],
        },
        float: {
          nt: Float,
          it: [0],
        },
        id: {
          nt: ID,
          it: [0],
        },
        int: {
          nt: Int,
          it: [0],
        },
        string: {
          nt: String,
          it: [0],
        },
      },
    },
    stringWithListArg: {
      a: {
        ints: {
          nt: Int,
          it: [0, [0]],
        },
      },
    },
    stringWithListArgRequired: {
      a: {
        ints: {
          nt: Int,
          it: [1, [1]],
        },
      },
    },
    stringWithRequiredArg: {
      a: {
        string: {
          nt: String,
          it: [1],
        },
      },
    },
    unionFooBar: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarNonNull: {
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionFooBarWithArgs: {
      a: {
        id: {
          nt: ID,
          it: [0],
        },
      },
      // nt: FooBarUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObject: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
    unionObjectNonNull: {
      // nt: ObjectUnion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                       Reference Assignments
//                                (avoids circular assignment issues)
// ==================================================================================================
//
//
//
//
//
//

InputObjectCircular.f!['circular']!.nt = InputObjectCircular
InputObjectNested.f!['InputObject']!.nt = InputObject
InputObjectNestedNonNull.f!['InputObject']!.nt = InputObject
ObjectNested.f['object']!.nt = Object1
ObjectUnion.f['fooBarUnion']!.nt = FooBarUnion
Query.f['dateInterface1']!.nt = DateInterface1
Query.f['dateObject1']!.nt = DateObject1
Query.f['dateUnion']!.nt = DateUnion
Query.f['interface']!.nt = Interface
Query.f['interfaceNonNull']!.nt = Interface
Query.f['interfaceWithArgs']!.nt = Interface
Query.f['lowerCaseUnion']!.nt = lowerCaseUnion
Query.f['object']!.nt = Object1
Query.f['objectList']!.nt = Object1
Query.f['objectListNonNull']!.nt = Object1
Query.f['objectNested']!.nt = ObjectNested
Query.f['objectNonNull']!.nt = Object1
Query.f['objectWithArgs']!.nt = Object1
Query.f['result']!.nt = Result
Query.f['resultNonNull']!.nt = Result
Query.f['unionFooBar']!.nt = FooBarUnion
Query.f['unionFooBarNonNull']!.nt = FooBarUnion
Query.f['unionFooBarWithArgs']!.nt = FooBarUnion
Query.f['unionObject']!.nt = ObjectUnion
Query.f['unionObjectNonNull']!.nt = ObjectUnion

//
//
//
//
//
//
// ==================================================================================================
//                                               Index
// ==================================================================================================
//
//
//
//
//
//

const $schemaDrivenDataMap: $Utilities.SchemaDrivenDataMap = {
  roots: {
    Mutation,
    Query,
  },
  directives: {},
  types: {
    Int,
    String,
    ID,
    Boolean,
    Float,
    Date,
    ABCEnum,
    Case,
    InputObject,
    InputObjectCircular,
    InputObjectNested,
    InputObjectNestedNonNull,
    Bar,
    DateObject1,
    DateObject2,
    ErrorOne,
    ErrorTwo,
    Foo,
    Object1,
    Object1ImplementingInterface,
    Object2ImplementingInterface,
    ObjectNested,
    ObjectUnion,
    lowerCaseObject,
    lowerCaseObject2,
    DateInterface1,
    Error,
    Interface,
    DateUnion,
    FooBarUnion,
    Result,
    lowerCaseUnion,
    Mutation,
    Query,
  },
}

export { $schemaDrivenDataMap as schemaDrivenDataMap }
"
`;

exports[`schema2 10`] = `
"import type * as Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type { Index } from './SchemaIndex.js'
import type * as SelectionSets from './SelectionSets.js'

export interface Document<$Config extends Utilities.Config> {
  <$Document>(document: Utilities.ExactNonEmpty<$Document, SelectionSets.$Document>): Utilities.DocumentRunner<
    $Config,
    Index,
    // @ts-expect-error We use Exact instead of constraint on this function. TypeScript does not see that as
    // Satisfying the constraint on the DocumentRunner type.
    $Document
  >
}

export interface BuilderMethodsDocumentFn extends Utilities.HKT.Fn {
  // @ts-expect-error parameter is Untyped.
  return: Document<this['params']['config']>
}
"
`;

exports[`schema2 11`] = `
"import type { InferResult } from '../../../../../../src/entrypoints/schema.js'
import type * as Utils from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type { Index } from './SchemaIndex.js'
import type * as SelectionSet from './SelectionSets.js'

export interface MutationMethods<$Config extends Utils.Config> {
  // todo Use a static type here?
  $batch: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Mutation>) => Promise<
    Utils.ResolveOutputReturnRootType<
      $Config,
      Index,
      InferResult.Mutation<
        Utils.AddTypenameToSelectedRootTypeResultFields<$Config, Index, 'Mutation', $SelectionSet>,
        Index
      >
    >
  >
  // todo Use a static type here?
  __typename: () => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      '__typename',
      'Mutation'
    >
  >
  id: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Mutation.id>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'id',
      InferResult.Field<$SelectionSet, Index['Root']['Mutation']['fields']['id'], Index>
    >
  >
  idNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Mutation.idNonNull>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'idNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Mutation']['fields']['idNonNull'], Index>
    >
  >
}

export interface QueryMethods<$Config extends Utils.Config> {
  // todo Use a static type here?
  $batch: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query>) => Promise<
    Utils.ResolveOutputReturnRootType<
      $Config,
      Index,
      InferResult.Query<
        Utils.AddTypenameToSelectedRootTypeResultFields<$Config, Index, 'Query', $SelectionSet>,
        Index
      >
    >
  >
  // todo Use a static type here?
  __typename: () => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      '__typename',
      'Query'
    >
  >
  InputObjectNested: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.InputObjectNested>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'InputObjectNested',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['InputObjectNested'], Index>
    >
  >
  InputObjectNestedNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.InputObjectNestedNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'InputObjectNestedNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['InputObjectNestedNonNull'], Index>
    >
  >
  /**
   * Query enum field documentation.
   */
  abcEnum: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.abcEnum>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'abcEnum',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['abcEnum'], Index>
    >
  >
  argInputObjectCircular: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.argInputObjectCircular>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'argInputObjectCircular',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['argInputObjectCircular'], Index>
    >
  >
  date: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.date>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'date',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['date'], Index>
    >
  >
  dateArg: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArg>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArg',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArg'], Index>
    >
  >
  dateArgInputObject: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgInputObject>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArgInputObject',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArgInputObject'], Index>
    >
  >
  dateArgList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgList>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArgList',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArgList'], Index>
    >
  >
  dateArgNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArgNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArgNonNull'], Index>
    >
  >
  dateArgNonNullList: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNullList>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArgNonNullList',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArgNonNullList'], Index>
    >
  >
  dateArgNonNullListNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateArgNonNullListNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateArgNonNullListNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateArgNonNullListNonNull'], Index>
    >
  >
  dateInterface1: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateInterface1>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateInterface1',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateInterface1'], Index>
    >
  >
  dateList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateList>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateList',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateList'], Index>
    >
  >
  dateListList: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateListList>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateListList',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateListList'], Index>
    >
  >
  dateListNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateListNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateListNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateListNonNull'], Index>
    >
  >
  dateNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.dateNonNull>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateNonNull'], Index>
    >
  >
  dateObject1: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateObject1>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateObject1',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateObject1'], Index>
    >
  >
  dateUnion: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.dateUnion>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'dateUnion',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['dateUnion'], Index>
    >
  >
  error: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.error>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'error',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['error'], Index>
    >
  >
  id: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.id>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'id',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['id'], Index>
    >
  >
  idNonNull: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.idNonNull>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'idNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['idNonNull'], Index>
    >
  >
  interface: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.$interface>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'interface',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['interface'], Index>
    >
  >
  interfaceNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.interfaceNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'interfaceNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['interfaceNonNull'], Index>
    >
  >
  interfaceWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.interfaceWithArgs>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'interfaceWithArgs',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['interfaceWithArgs'], Index>
    >
  >
  listInt: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listInt>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'listInt',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['listInt'], Index>
    >
  >
  listIntNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listIntNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'listIntNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['listIntNonNull'], Index>
    >
  >
  listListInt: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listListInt>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'listListInt',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['listListInt'], Index>
    >
  >
  listListIntNonNull: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.listListIntNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'listListIntNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['listListIntNonNull'], Index>
    >
  >
  lowerCaseUnion: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.lowerCaseUnion>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'lowerCaseUnion',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['lowerCaseUnion'], Index>
    >
  >
  object: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.$object>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'object',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['object'], Index>
    >
  >
  objectList: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectList>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'objectList',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['objectList'], Index>
    >
  >
  objectListNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectListNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'objectListNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['objectListNonNull'], Index>
    >
  >
  objectNested: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectNested>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'objectNested',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['objectNested'], Index>
    >
  >
  objectNonNull: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectNonNull>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'objectNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['objectNonNull'], Index>
    >
  >
  objectWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.objectWithArgs>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'objectWithArgs',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['objectWithArgs'], Index>
    >
  >
  result: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.result>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'result',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['result'], Index>
    >
  >
  resultNonNull: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.resultNonNull>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'resultNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['resultNonNull'], Index>
    >
  >
  string: <$SelectionSet>(selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.$string>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'string',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['string'], Index>
    >
  >
  stringWithArgEnum: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgEnum>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithArgEnum',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithArgEnum'], Index>
    >
  >
  stringWithArgInputObject: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgInputObject>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithArgInputObject',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithArgInputObject'], Index>
    >
  >
  stringWithArgInputObjectRequired: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgInputObjectRequired>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithArgInputObjectRequired',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithArgInputObjectRequired'], Index>
    >
  >
  /**
   * The given arguments are reflected back as a JSON string.
   */
  stringWithArgs: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithArgs>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithArgs',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithArgs'], Index>
    >
  >
  stringWithListArg: <$SelectionSet>(
    selectionSet?: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithListArg>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithListArg',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithListArg'], Index>
    >
  >
  stringWithListArgRequired: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithListArgRequired>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithListArgRequired',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithListArgRequired'], Index>
    >
  >
  stringWithRequiredArg: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.stringWithRequiredArg>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'stringWithRequiredArg',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['stringWithRequiredArg'], Index>
    >
  >
  unionFooBar: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBar>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'unionFooBar',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['unionFooBar'], Index>
    >
  >
  unionFooBarNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBarNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'unionFooBarNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['unionFooBarNonNull'], Index>
    >
  >
  unionFooBarWithArgs: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionFooBarWithArgs>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'unionFooBarWithArgs',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['unionFooBarWithArgs'], Index>
    >
  >
  unionObject: <$SelectionSet>(selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionObject>) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'unionObject',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['unionObject'], Index>
    >
  >
  unionObjectNonNull: <$SelectionSet>(
    selectionSet: Utils.Exact<$SelectionSet, SelectionSet.Query.unionObjectNonNull>,
  ) => Promise<
    Utils.ResolveOutputReturnRootField<
      $Config,
      Index,
      'unionObjectNonNull',
      InferResult.Field<$SelectionSet, Index['Root']['Query']['fields']['unionObjectNonNull'], Index>
    >
  >
}

export interface BuilderMethodsRoot<$Config extends Utils.Config> {
  mutation: MutationMethods<$Config>
  query: QueryMethods<$Config>
}

export interface BuilderMethodsRootFn extends Utils.HKT.Fn {
  // @ts-expect-error parameter is Untyped.
  return: BuilderMethodsRoot<this['params']['config']>
}
"
`;

exports[`schema2 12`] = `
"import type * as $Utilities from '../../../../../../src/entrypoints/utilities-for-generated.js'
import type * as $SelectionSets from './SelectionSets.js'

//
//
//
//
//
//
// ==================================================================================================
//                                      Select Methods Interface
// ==================================================================================================
//
//
//
//
//
//

export interface $MethodsSelect {
  Mutation: Mutation
  Query: Query
  Bar: Bar
  DateObject1: DateObject1
  DateObject2: DateObject2
  ErrorOne: ErrorOne
  ErrorTwo: ErrorTwo
  Foo: Foo
  Object1: Object1
  Object1ImplementingInterface: Object1ImplementingInterface
  Object2ImplementingInterface: Object2ImplementingInterface
  ObjectNested: ObjectNested
  ObjectUnion: ObjectUnion
  lowerCaseObject: lowerCaseObject
  lowerCaseObject2: lowerCaseObject2
  DateUnion: DateUnion
  FooBarUnion: FooBarUnion
  Result: Result
  lowerCaseUnion: lowerCaseUnion
  DateInterface1: DateInterface1
  Error: Error
  Interface: Interface
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

export interface Mutation {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Mutation>): $SelectionSet
}

export interface Query {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Query>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Object
// ==================================================================================================
//
//
//
//
//
//

export interface Bar {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Bar>): $SelectionSet
}

export interface DateObject1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateObject1>): $SelectionSet
}

export interface DateObject2 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateObject2>): $SelectionSet
}

export interface ErrorOne {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ErrorOne>): $SelectionSet
}

export interface ErrorTwo {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ErrorTwo>): $SelectionSet
}

export interface Foo {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Foo>): $SelectionSet
}

export interface Object1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object1>): $SelectionSet
}

export interface Object1ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object1ImplementingInterface>,
  ): $SelectionSet
}

export interface Object2ImplementingInterface {
  <$SelectionSet>(
    selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Object2ImplementingInterface>,
  ): $SelectionSet
}

export interface ObjectNested {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ObjectNested>): $SelectionSet
}

export interface ObjectUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.ObjectUnion>): $SelectionSet
}

export interface lowerCaseObject {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseObject>): $SelectionSet
}

export interface lowerCaseObject2 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseObject2>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

export interface DateUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateUnion>): $SelectionSet
}

export interface FooBarUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.FooBarUnion>): $SelectionSet
}

export interface Result {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Result>): $SelectionSet
}

export interface lowerCaseUnion {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.lowerCaseUnion>): $SelectionSet
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

export interface DateInterface1 {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.DateInterface1>): $SelectionSet
}

export interface Error {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Error>): $SelectionSet
}

export interface Interface {
  <$SelectionSet>(selectionSet: $Utilities.Exact<$SelectionSet, $SelectionSets.Interface>): $SelectionSet
}
"
`;
