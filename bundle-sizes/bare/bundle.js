const e=(e,t)=>"default"===e.errors[t]?e.defaults.errorChannel:e.errors[t],t={defaults:{errorChannel:"throw"},envelope:{enabled:!1,errors:{execution:!0,other:!1}},errors:{execution:"default",other:"default"}},r=e=>{const t={discriminant:e.discriminant,inputDefaults:e.inputDefaults,steps:{}},r={type:t,config:()=>r,defaults:e=>(t.inputDefaults=e,r),configInit:()=>r,stepWithExtendedInput:()=>r.step,step:(e,n)=>(t.steps[e]={name:e,...n},r)};return r};var n;!function(e){e.create=e=>{let t=e.steps;e.overloads.length>0&&(t=t.map((t=>{const r=e.overloads.map((e=>{const r=e.steps[t.name];return r?{...r,discriminant:e.discriminant}:null})).filter((e=>null!==e));return{name:t.name,run:(...e)=>{const n=e[0],o=r.find((e=>n[e.discriminant[0]]===e.discriminant[1]));return o?o.run(...e):t.run(...e)},slots:{...t.slots,...r.reduce(((e,t)=>({...e,...t.slots})),{})}}})));const r=(e=>new Map(e.map((e=>[e.name,e]))))(t);return{...e,steps:t,stepsIndex:r}}}(n||(n={}));const o=e=>e instanceof Error?e:Error(e+""),s=e=>{throw Error("Unhandled case: "+e)},i=e=>{let t,r,n=!1;return{promise:new Promise(((e,n)=>{t=e,r=n})),isResolved:()=>n,resolve:r=>{if(n=!0,e?.strict&&n)throw Error("Deferred is already resolved. Attempted to resolve with: "+JSON.stringify(r));t(r)},reject:e=>r(e)}},a=(...e)=>{globalThis.process?.env?.DEBUG&&console.log(...e)},u=(...e)=>(...t)=>{a(...e,...t)};new Proxy({},{get:()=>e=>e});const c=e=>"string"==typeof e,l=e=>e;class p extends Error{context;cause;name="ContextualError";constructor(e,t={},r=void 0){super(e,r),this.context=t,this.cause=r}}class d extends p{errors;name="ContextualAggregateError";constructor(e,t,r){super(e,t,void 0),this.errors=r}}const m=/^(?:(?<async>async)\s+)?(?:function\s+)?(?:(?<name>[A-z_0-9]+)\s*)?\((?<parameters>[^)]*)\)\s*(?:=>\s*(?<bodyExpression>[^\s{].*)|(?:=>\s*)?{(?<bodyStatement>.*)})$/s,f=/(?<destructured>\{[^}]+\})|(?<name>[A-z_][A-z_0-9]*)/gs,h=/(?<name>[A-z_][A-z_0-9]*)(?::[^},]+)?/gs;class v extends p{constructor(e){super("Interceptor must destructure the first parameter passed to it and select exactly one step.",e)}}const y="multipleParameters",E="noParameters",g="notDestructured",N="destructuredWithoutEntryHook",I="multipleDestructuredHookNames",k="invalidDestructuredHookNames",T=Symbol("resultEnvelope"),x=e=>({[T]:T,result:e});var w;!function(e){e.create=(e,t)=>(t.input=e,t)}(w||(w={}));const S=e=>({...e,currentChunk:i()}),b=async({pipeline:e,name:t,done:r,inputOriginalOrFromExtension:n,previousStepsCompleted:a,interceptorsStack:c,nextInterceptorsStack:l,asyncErrorDeferred:d,customSlots:m})=>{const f=u(`step ${t}:`);f("advance to next interceptor");const[h,...v]=c;if(!(0===v.length)&&h?.retrying&&r({type:"error",source:"user",extensionName:h.name,hookName:t,error:new p("Only the last extension can retry hooks.",{extensionsAfter:v.map((e=>({name:e.name})))})}),h){const c=u(`hook ${t}: extension ${h.name}:`),y=i();c("start");let E=!1;const g=w.create(n,(o=>{c("extension calls this hook",o);const s=o?.input??n,u={...m,...o?.using};if(y.isResolved()){if(h.retrying){if(E){c("execute branch: retry");const s=S(h);return b({pipeline:e,name:t,done:r,previousStepsCompleted:a,inputOriginalOrFromExtension:n,asyncErrorDeferred:d,interceptorsStack:[s],nextInterceptorsStack:l,customSlots:u}),s.currentChunk.promise.then((async e=>{const r=e[t];if(!r)throw Error("Hook not found in envelope: "+t);return await r({...o,input:o?.input??n})}))}return d.resolve({type:"error",source:"extension",interceptorName:h.name,hookName:t,error:new p("Only after failure can a hook be called again by a retrying extension.",{hookName:t,extensionName:h.name})}),i().promise}return d.resolve({type:"error",source:"extension",interceptorName:h.name,hookName:t,error:new p("Only a retrying extension can retry hooks.",{hookName:t,extensionsAfter:v.map((e=>({name:e.name})))})}),i().promise}{const n=S(h),o=[...l,n];return y.resolve(!0),b({pipeline:e,name:t,done:r,previousStepsCompleted:a,asyncErrorDeferred:d,inputOriginalOrFromExtension:s,interceptorsStack:v,nextInterceptorsStack:o,customSlots:u}),n.currentChunk.promise.then((e=>(e instanceof Error&&(c("received hook error"),E=!0),e)))}}));c("advance with envelope");const N={[t]:g};h.currentChunk.resolve(N),f("start race between extension returning or invoking next hook");const{branch:I,result:k}=await Promise.race([y.promise.then((e=>({branch:"hookInvoked",result:e}))).catch((e=>({branch:"hookInvokedButThrew",result:e}))),h.body.promise.then((e=>({branch:"extensionReturned",result:e}))).catch((e=>({branch:"extensionThrew",result:e})))]);switch(I){case"hookInvoked":return void c("invoked next hook (or retrying extension got error pushed through)");case"extensionReturned":return c("extension returned"),void(k===N?b({pipeline:e,name:t,done:r,previousStepsCompleted:a,inputOriginalOrFromExtension:n,asyncErrorDeferred:d,interceptorsStack:v,nextInterceptorsStack:l,customSlots:m}):r({type:"shortCircuited",result:k}));case"extensionThrew":return c("extension threw"),void r({type:"error",hookName:t,source:"extension",error:o(k),interceptorName:h.name});case"hookInvokedButThrew":return c("hook error"),void r({type:"error",hookName:t,source:"implementation",error:o(k)});default:throw s(I)}}else{f("no more interceptors to advance, run implementation");const s=e.stepsIndex.get(t);if(!s)throw new p("Implementation not found for step name "+t,{hookName:t});let i;try{const e={...s.slots,...m};i=await s.run(n,e,a)}catch(e){f("implementation error");const n=l[l.length-1];return void(n&&n.retrying?n.currentChunk.resolve(o(e)):r({type:"error",hookName:t,source:"implementation",error:o(e)}))}f("completed"),r({type:"completed",result:i,effectiveInput:n,nextExtensionsStack:l})}},C=async({pipeline:e,stepsToProcess:t,originalInputOrResult:r,interceptorsStack:n,asyncErrorDeferred:o,previousStepsCompleted:u})=>{const[c,...l]=t;if(!c){a("pipeline: ending");const e=await O({interceptorsStack:n,result:r});return a("pipeline: returning"),x(e)}a(`hook ${c.name}: start`);const d=i({strict:!1});b({pipeline:e,name:c.name,done:d.resolve,inputOriginalOrFromExtension:r,previousStepsCompleted:u,interceptorsStack:n,asyncErrorDeferred:o,customSlots:{},nextInterceptorsStack:[]});const m=await Promise.race([d.promise,o.promise]);switch(m.type){case"completed":{const{result:t,effectiveInput:r,nextExtensionsStack:n}=m,s={...u,[c.name]:{input:r}};return await C({pipeline:e,stepsToProcess:l,originalInputOrResult:t,interceptorsStack:n,previousStepsCompleted:s,asyncErrorDeferred:o})}case"shortCircuited":{a("signal: shortCircuited");const{result:e}=m;return x(e)}case"error":{if(a("signal: error"),e.config.passthroughErrorWith?.(m))return m.error;if(e.config.passthroughErrorInstanceOf.some((e=>m.error instanceof e)))return m.error;const t=o.isResolved();switch(m.source){case"extension":{const e="anonymous"===m.interceptorName?" (use named functions to improve this error message)":"";return new p(t?`There was an error in the interceptor "${m.interceptorName}"${e}.`:`There was an error in the interceptor "${m.interceptorName}"${e} while running hook "${m.hookName}".`,{hookName:m.hookName,source:m.source,interceptorName:m.interceptorName},m.error)}case"implementation":return new p(`There was an error in the core implementation of hook "${m.hookName}".`,{hookName:m.hookName,source:m.source},m.error);case"user":return m.error;default:throw s(m)}}default:throw s(m)}},O=async({interceptorsStack:e,result:t})=>{const[r,...n]=e;if(!r)return t;a(`interceptor ${r.name}: end`),r.currentChunk.resolve(t);const o=await r.body.promise;return await O({interceptorsStack:n,result:o})},D=(e,t)=>{const r=i(),n=i(),o="function"==typeof t?t:t.run,a="function"!=typeof t&&t.retrying,u=async e=>{try{const t=await o(e);n.resolve(t)}catch(e){n.reject(e)}},c=o.name||"anonymous";switch(e.config.entrypointSelectionMode){case"off":return r.promise.then(u),{name:c,entrypoint:e.steps[0]?.name,body:n,currentChunk:r};case"optional":case"required":{const t=((e,t)=>{const r=e.stepsIndex,n=(e=>{const t=(""+e).match(m)?.groups;if(!t)throw Error("Could not extract groups from function.");const r=t.bodyStatement??t.bodyExpression;if(void 0===r)throw Error("Could not extract body from function.");const n=[];if(t.parameters){const e=[...t.parameters.matchAll(f)].map((e=>{const t=e.groups?.destructured?"destructured":e.groups?.name?"name":null;switch(t){case"destructured":return{type:t,names:[...e.groups.destructured.matchAll(h)].map((e=>{const t=e.groups.name;if(void 0===t)throw Error("Could not extract name from destructured parameter.");return t}))};case"name":return{type:t,value:e.groups.name};case null:throw Error("Could not determine type of parameter.");default:throw s(t)}}));n.push(...e)}return{body:r,parameters:n}})(t);if(n.parameters.length>1)return new v({issue:y});const o=n.parameters[0];if(o){if("name"===o.type)return new v({issue:g});{if(0===o.names.length)return new v({issue:N});const e=o.names.filter((e=>r.has(e)));if(e.length>1)return new v({issue:I});const t=e[0];return t?r.get(t)||new v({issue:N}):new v({issue:k})}}return new v({issue:E})})(e,o);if(t instanceof Error)return"required"===e.config.entrypointSelectionMode?t:(r.promise.then(u),{name:c,entrypoint:e.steps[0]?.name,body:n,currentChunk:r});const i=[];for(const r of e.steps){if(r===t)break;i.push(r.name)}const l=i.map((e=>A(e)));let p=r.promise;for(const e of l)p=p.then(e);return p.then(u),{retrying:a,name:c,entryStep:t,body:n,currentChunk:r}}default:throw s(e.config.entrypointSelectionMode)}},A=e=>async t=>{const r=t[e];if(!r)throw new p("Hook not found in hook envelope",{hookName:e});return await r({input:r.input})},_=async(e,t)=>{const r=(e=>async t=>{const{initialInput:r,interceptors:n=[],retryingInterceptor:o}=t??{};var s;const a=(o?[...n,(s=o,{retrying:!0,run:s})]:n).map((t=>D(e,t))),[u,c]=(e=>{const[t,r]=(e=>{const t=[],r=[];for(const n of e)n instanceof Error?t.push(n):r.push(n);return[r,t]})(e);return[t,r.length>0?new d("One or more extensions are invalid.",{},r):null]})(a);if(c)return c;const l=i({strict:!1}),p=await C({pipeline:e,stepsToProcess:e.steps,originalInputOrResult:r,interceptorsStack:u,asyncErrorDeferred:l,previousStepsCompleted:{}});return p instanceof Error?p:(e=>({value:e}))(p.result)})(e);return await r(t)},F=e=>{const t={type:e,input:()=>t,done:()=>n.create(e),stepWithRunnerType:()=>t.step,step:(...t)=>{const r="string"==typeof t[0]?{name:t[0],run:q,...t[1]}:{run:q,...t[0]};return F({...e,steps:[...e.steps,r]})},use:t=>F({...e,overloads:[...e.overloads,...t.type.overloads]}),overload:t=>{const n=t({create:r});return e.overloads.push(n.type),F(e)}};return t},q=e=>e.input;class R extends Error{constructor(e,t,r,n,o,s,i){super(e),this.name="GraphQLError",this.message=e,o&&(this.path=o),t&&(this.nodes=Array.isArray(t)?t:[t]),r&&(this.source=r),n&&(this.positions=n),s&&(this.originalError=s);var a=i;if(!a&&s){var u=s.extensions;u&&"object"==typeof u&&(a=u)}this.extensions=a||{}}toJSON(){return{...this,message:this.message}}toString(){return this.message}get[Symbol.toStringTag](){return"GraphQLError"}}var P,V;function j(e){return new R(`Syntax Error: Unexpected token at ${V} in ${e}`)}function M(e){if(e.lastIndex=V,e.test(P))return P.slice(V,V=e.lastIndex)}var L=/ +(?=[^\s])/y;function U(e){for(var t=e.split("\n"),r="",n=0,o=0,s=t.length-1,i=0;t.length>i;i++)L.lastIndex=0,L.test(t[i])&&(!i||n&&L.lastIndex>=n||(n=L.lastIndex),o=o||i,s=i);for(var a=o;s>=a;a++)a!==o&&(r+="\n"),r+=t[a].slice(n).replace(/\\"""/g,'"""');return r}function $(){for(var e=0|P.charCodeAt(V++);9===e||10===e||13===e||32===e||35===e||44===e||65279===e;e=0|P.charCodeAt(V++))if(35===e)for(;10!==(e=P.charCodeAt(V++))&&13!==e;);V--}var B,Y=/[_A-Za-z]\w*/y,G=RegExp("(?:(null|true|false)|\\$("+Y.source+')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|('+Y.source+"))","y"),H=((B=H||{})[B.Const=1]="Const",B[B.Var=2]="Var",B[B.Int=3]="Int",B[B.Float=4]="Float",B[B.BlockString=5]="BlockString",B[B.String=6]="String",B[B.Enum=7]="Enum",B),J=/\\/;function z(e){var t,r;if(G.lastIndex=V,91===P.charCodeAt(V)){V++,$();for(var n=[];93!==P.charCodeAt(V);)n.push(z(e));return V++,$(),{kind:"ListValue",values:n}}if(123===P.charCodeAt(V)){V++,$();for(var o=[];125!==P.charCodeAt(V);){if(null==(t=M(Y)))throw j("ObjectField");if($(),58!==P.charCodeAt(V++))throw j("ObjectField");$(),o.push({kind:"ObjectField",name:{kind:"Name",value:t},value:z(e)})}return V++,$(),{kind:"ObjectValue",fields:o}}if(null!=(r=G.exec(P))){if(V=G.lastIndex,$(),null!=(t=r[H.Const]))return"null"===t?{kind:"NullValue"}:{kind:"BooleanValue",value:"true"===t};if(null!=(t=r[H.Var])){if(e)throw j("Variable");return{kind:"Variable",name:{kind:"Name",value:t}}}var s;if(null!=(t=r[H.Int]))return null!=(s=r[H.Float])?{kind:"FloatValue",value:t+s}:{kind:"IntValue",value:t};if(null!=(t=r[H.BlockString]))return{kind:"StringValue",value:U(t.slice(3,-3)),block:!0};if(null!=(t=r[H.String]))return{kind:"StringValue",value:J.test(t)?JSON.parse(t):t.slice(1,-1),block:!1};if(null!=(t=r[H.Enum]))return{kind:"EnumValue",value:t}}throw j("Value")}function W(e){if(40===P.charCodeAt(V)){var t,r=[];V++,$();do{if(null==(t=M(Y)))throw j("Argument");if($(),58!==P.charCodeAt(V++))throw j("Argument");$(),r.push({kind:"Argument",name:{kind:"Name",value:t},value:z(e)})}while(41!==P.charCodeAt(V));return V++,$(),r}}function X(e){if(64===P.charCodeAt(V)){var t,r=[];do{if(V++,null==(t=M(Y)))throw j("Directive");$(),r.push({kind:"Directive",name:{kind:"Name",value:t},arguments:W(e)})}while(64===P.charCodeAt(V));return r}}function Q(){for(var e,t=0;91===P.charCodeAt(V);)t++,V++,$();if(null==(e=M(Y)))throw j("NamedType");$();var r={kind:"NamedType",name:{kind:"Name",value:e}};do{if(33===P.charCodeAt(V)&&(V++,$(),r={kind:"NonNullType",type:r}),t){if(93!==P.charCodeAt(V++))throw j("NamedType");$(),r={kind:"ListType",type:r}}}while(t--);return r}var Z=RegExp("(?:(\\.{3})|("+Y.source+"))","y"),K=function(e){return e[e.Spread=1]="Spread",e[e.Name=2]="Name",e}(K||{});function ee(){var e,t,r=[];do{if(Z.lastIndex=V,null==(t=Z.exec(P)))throw j("SelectionSet");if(V=Z.lastIndex,null!=t[K.Spread]){$();var n=M(Y);if(null!=n&&"on"!==n)$(),r.push({kind:"FragmentSpread",name:{kind:"Name",value:n},directives:X(!1)});else{if($(),"on"===n){if(null==(n=M(Y)))throw j("NamedType");$()}var o=X(!1);if(123!==P.charCodeAt(V++))throw j("InlineFragment");$(),r.push({kind:"InlineFragment",typeCondition:n?{kind:"NamedType",name:{kind:"Name",value:n}}:void 0,directives:o,selectionSet:ee()})}}else if(null!=(e=t[K.Name])){var s=void 0;if($(),58===P.charCodeAt(V)){if(V++,$(),s=e,null==(e=M(Y)))throw j("Field");$()}var i=W(!1);$();var a=X(!1),u=void 0;123===P.charCodeAt(V)&&(V++,$(),u=ee()),r.push({kind:"Field",alias:s?{kind:"Name",value:s}:void 0,name:{kind:"Name",value:e},arguments:i,directives:a,selectionSet:u})}}while(125!==P.charCodeAt(V));return V++,$(),{kind:"SelectionSet",selections:r}}function te(){var e,t;if(null==(e=M(Y)))throw j("FragmentDefinition");if($(),"on"!==M(Y))throw j("FragmentDefinition");if($(),null==(t=M(Y)))throw j("FragmentDefinition");$();var r=X(!1);if(123!==P.charCodeAt(V++))throw j("FragmentDefinition");return $(),{kind:"FragmentDefinition",name:{kind:"Name",value:e},typeCondition:{kind:"NamedType",name:{kind:"Name",value:t}},directives:r,selectionSet:ee()}}var re,ne=/(?:query|mutation|subscription|fragment)/y;function oe(e){var t,r,n;if(e&&($(),t=M(Y),r=function(){if($(),40===P.charCodeAt(V)){var e,t=[];V++,$();do{if(36!==P.charCodeAt(V++))throw j("Variable");if(null==(e=M(Y)))throw j("Variable");if($(),58!==P.charCodeAt(V++))throw j("VariableDefinition");$();var r=Q(),n=void 0;61===P.charCodeAt(V)&&(V++,$(),n=z(!0)),$(),t.push({kind:"VariableDefinition",variable:{kind:"Variable",name:{kind:"Name",value:e}},type:r,defaultValue:n,directives:X(!0)})}while(41!==P.charCodeAt(V));return V++,$(),t}}(),n=X(!1)),123===P.charCodeAt(V))return V++,$(),{kind:"OperationDefinition",operation:e||"query",name:t?{kind:"Name",value:t}:void 0,variableDefinitions:r,directives:n,selectionSet:ee()}}!function(e){e.NAME="Name",e.DOCUMENT="Document",e.OPERATION_DEFINITION="OperationDefinition",e.VARIABLE_DEFINITION="VariableDefinition",e.SELECTION_SET="SelectionSet",e.FIELD="Field",e.ARGUMENT="Argument",e.FRAGMENT_SPREAD="FragmentSpread",e.INLINE_FRAGMENT="InlineFragment",e.FRAGMENT_DEFINITION="FragmentDefinition",e.VARIABLE="Variable",e.INT="IntValue",e.FLOAT="FloatValue",e.STRING="StringValue",e.BOOLEAN="BooleanValue",e.NULL="NullValue",e.ENUM="EnumValue",e.LIST="ListValue",e.OBJECT="ObjectValue",e.OBJECT_FIELD="ObjectField",e.DIRECTIVE="Directive",e.NAMED_TYPE="NamedType",e.LIST_TYPE="ListType",e.NON_NULL_TYPE="NonNullType",e.SCHEMA_DEFINITION="SchemaDefinition",e.OPERATION_TYPE_DEFINITION="OperationTypeDefinition",e.SCALAR_TYPE_DEFINITION="ScalarTypeDefinition",e.OBJECT_TYPE_DEFINITION="ObjectTypeDefinition",e.FIELD_DEFINITION="FieldDefinition",e.INPUT_VALUE_DEFINITION="InputValueDefinition",e.INTERFACE_TYPE_DEFINITION="InterfaceTypeDefinition",e.UNION_TYPE_DEFINITION="UnionTypeDefinition",e.ENUM_TYPE_DEFINITION="EnumTypeDefinition",e.ENUM_VALUE_DEFINITION="EnumValueDefinition",e.INPUT_OBJECT_TYPE_DEFINITION="InputObjectTypeDefinition",e.DIRECTIVE_DEFINITION="DirectiveDefinition",e.SCHEMA_EXTENSION="SchemaExtension",e.SCALAR_TYPE_EXTENSION="ScalarTypeExtension",e.OBJECT_TYPE_EXTENSION="ObjectTypeExtension",e.INTERFACE_TYPE_EXTENSION="InterfaceTypeExtension",e.UNION_TYPE_EXTENSION="UnionTypeExtension",e.ENUM_TYPE_EXTENSION="EnumTypeExtension",e.INPUT_OBJECT_TYPE_EXTENSION="InputObjectTypeExtension"}(re||(re={}));const se="query",ie=e=>"object"==typeof e&&null!==e&&"kind"in e&&"OperationDefinition"===e.kind,ae=e=>"NamedType"===e.kind?e:ae(e.type),ue=e=>{for(const t of e.query.definitions){const r=ie(t)?t:null;if(!e.operationName)return r;if(r?.name?.value===e.operationName)return r}return null},ce=RegExp(`^\\b(${Object.values(Object.freeze({__proto__:null,MUTATION:"mutation",QUERY:se,SUBSCRIPTION:"subscription"})).join("|")})\\b`),le=e=>{const t=e;return c(t)?function(e){return V=0,function(e){var t,r;$();var n,o=[];do{if("fragment"===(t=M(ne)))$(),o.push(te());else{if(null==(r=oe(t)))throw j("Document");o.push(r)}}while(e.length>V);return{kind:"Document",definitions:o,set loc(e){n=e},get loc(){return n||(n={start:0,end:e.length,startToken:void 0,endToken:void 0,source:{body:e,name:"graphql.web",locationOffset:{line:1,column:1}}}),n}}}(P="string"==typeof e.body?e.body:e)}(t):t},pe=e=>{const t=le(e.query);if("operation"in e){const r=ue({...e,query:le(e.query)});return{...e,operation:r,query:t}}return{...e,query:t}},de=(e,t)=>({kind:"Scalar",name:e,codec:t}),me=de("String",{encode:e=>e,decode:e=>e});var fe;!function(e){e.empty={map:{}}}(fe||(fe={}));const he=(e,t)=>e[t]||me,ve=(e,t)=>null===t?null:Array.isArray(t)?t.map((t=>ve(e,t))):e(t),ye=e=>"object"==typeof e&&null!==e&&"codec"in e&&"object"==typeof e.codec,Ee=e=>c(e),ge=ye,Ne=e=>{const{parentContext:t,value:r,sddmNode:n,documentPart:o,scalars:s}=e;var i;if(null!==r)if(Array.isArray(r))r.forEach(((e,t)=>{Ne({parentContext:{type:"list",object:r,index:t},value:e,sddmNode:n,documentPart:o,scalars:s})}));else if("object"==typeof r){if(!(i=n)||c(i)||!("f"in i))return;const e=r;for(const[t,r]of Object.entries(e)){const i=Ie(o,t),a=n.f[i?.name.value??t];a?.nt&&Ne({parentContext:{type:"object",object:e,fieldName:t},value:r,sddmNode:a.nt,documentPart:i?.selectionSet??null,scalars:s})}}else{if(!t)return;if(ge(n)){const e=ve(n.codec.decode,r);"object"===t.type?t.object[t.fieldName]=e:t.object[t.index]=e}else if(Ee(n)){const e=he(s,n),o=ve(e.codec.decode,r);"object"===t.type?t.object[t.fieldName]=o:t.object[t.index]=o}}},Ie=(e,t)=>{if(!e)return null;for(const r of e.selections){if(r.kind===re.FIELD&&(r.alias?.value??r.name.value)===t)return r;if(r.kind===re.INLINE_FRAGMENT){const e=Ie(r.selectionSet,t);if(null!==e)return e}}return null},ke=(e,t,r,n,o)=>{if(Ee(n)){const s=he(o,n);e[t]=ve(s.codec.encode,r)}else{var s;if(ge(n))e[t]=ve(n.codec.encode,r);else if((s=n)&&!c(s)&&"f"in s)for(const e of n.fcs??[]){if("object"!=typeof r||null===r)continue;const t=r[e];if(void 0===t)continue;const s=n.f?.[e];s?.nt&&ke(r,e,t,s.nt,o)}}},Te=(e=>{const t=(e=>({passthroughErrorInstanceOf:e?.passthroughErrorInstanceOf??[],passthroughErrorWith:e?.passthroughErrorWith,entrypointSelectionMode:e?.entrypointSelectionMode??"required"}))(e);return F({steps:[],config:t,overloads:[]})})({passthroughErrorWith:e=>"exchange"===e.hookName&&(e=>e instanceof DOMException&&"AbortError"===e.name||e instanceof Error&&e.message.startsWith("AbortError:"))(e.error)}).input().step("encode",{run:e=>{const t=e.state.schemaMap,r=e.state.scalars.map;if(t){const n=pe(e.request);e.request.query=n.query,(({sddm:e,request:t,scalars:r})=>{const n=t.operation.variableDefinitions;if(!n)return;const o=new Map(n.map((e=>[e.variable.name.value,e]))),s=t.variables??{};for(const t in s){const n=o.get(t);if(!n)continue;const i=s[t];if(void 0===i)continue;const a=ae(n.type),u=e.types[a.name.value];u&&ke(s,t,i,u,r)}})({sddm:t,scalars:r,request:n})}return e}}).step("pack").step("exchange").step("unpack").step("decode",{run:(e,t,r)=>(e.state.schemaMap&&!(!e.result.data&&(e.result.errors?.length??0)>0)&&(({request:e,data:t,sddm:r,scalars:n})=>{const o=r.operations[e.operation.operation];o&&t&&Ne({parentContext:null,value:t,sddmNode:o,documentPart:e.operation.selectionSet,scalars:n})})({sddm:e.state.schemaMap,request:pe(r.pack.input.request),data:e.result.data,scalars:e.state.scalars.map}),"http"===e.transportType?{...e.result,response:e.response}:e.result)}).type;var xe;!function(e){(e.States||(e.States={})).empty={registry:{},configurations:{},current:null}}(xe||(xe={}));const we="default";var Se,be;!function(e){e.updateContextConfigInit=(t,r)=>{const n="object"==typeof r.output?.envelope?{enabled:!0,...r.output.envelope}:"boolean"==typeof r.output?.envelope?{enabled:r.output.envelope}:void 0,o={name:r.name??t?.name??we,schemaMap:r.schemaMap??t.schemaMap,output:{defaults:{errorChannel:r.output?.defaults?.errorChannel??t.output.defaults.errorChannel},envelope:{enabled:n?.enabled??t.output.envelope.enabled,errors:{execution:n?.errors?.execution??t.output.envelope.errors.execution,other:n?.errors?.other??t.output.envelope.errors.other,schema:n?.errors?.schema??t.output.envelope.errors.schema}},errors:{execution:r.output?.errors?.execution??t.output.errors.execution,other:r.output?.errors?.other??t.output.errors.other,schema:r.output?.errors?.schema??t.output.errors.schema}}};return e.withTypeLevel({...t,...o})},e.withTypeLevel=e=>e,(e.States||(e.States={})).empty={name:we,requestPipelineDefinition:Te,transports:xe.States.empty,checkPreflight:!0,input:{},output:t,schemaMap:null,extensions:[],scalars:fe.empty}}(Se||(Se={})),function(e){e.createCallback=l}(be||(be={}));const Ce={requestResultDataTypes:()=>Ce,onRequestResult:()=>Ce,onRequestDocumentRootType:()=>Ce,type:null},Oe=e=>{const t=t=>{const n=e.normalizeConfig?.(t)??{},o=e.create({config:n,builder:be.createCallback,typeHooks:Ce}),s=o.builder,i=o.transport?.((e=>r({discriminant:["transportType",e]})))?.type;return{name:e.name,config:n,onRequest:o.onRequest,builder:s,transport:i?{name:i.discriminant[1],config:i.input,configInit:void 0,configDefaults:i.inputDefaults,requestPipelineOverload:i}:void 0,typeHooks:{requestResultDataTypes:null,onRequestDocumentRootType:[],onRequestResult:[]}}};return t.info={name:e.name},t},De=(e,t)=>({anyware:r=>e({...t,extensions:[...t.extensions,Oe({name:"InlineAnyware",create:()=>({onRequest:r})})()]})}),Ae=e=>({document:(e=>{return Array.isArray(t=e[0])&&"raw"in t&&void 0!==t.raw;var t})(e)?(e=>{const[t,...r]=e;return t.reduce(((e,t,n)=>`${e}${t}${n in r?r[n]+"":""}`),"")})(e):e[0]}),_e=(t,r)=>({gql:(...t)=>{const{document:o}=Ae(t);return{send:async(...t)=>{if(!r.transports.current)throw Error("No transport selected");const{operationName:s,variables:i}=(e=>({operationName:c(e[0])?e[0]:void 0,variables:c(e[0])?e[1]:e[0]}))(t),a=(e=>{const{operationName:t,query:r}=e,n=r;if(!c(n)){const e=ue({query:n,operationName:t});if(e)return e.operation;throw Error("Could not parse operation type from document.")}const o=n.split(/[{}\n]+/).map((e=>e.trim())).map((e=>{const t=e.match(ce);return t?{line:e,operationType:t[0]}:null})).filter((e=>null!==e));if(o.length>1&&!e.operationName)return null;if(0===o.length&&e.operationName)return null;if(0===o.length)return se;const s=t?o.find((e=>e.line.includes(t))):o[0];return s?s.operationType:null})({query:o,variables:i,operationName:s});if(!a)throw Error("Could not get operation type");const u={transportType:r.transports.current,...r.transports.configurations[r.transports.current],state:r,request:{operation:a,query:o,variables:i,operationName:s}},l=n.create(r.requestPipelineDefinition),m=await _(l,{initialInput:u,interceptors:r.extensions.filter((e=>void 0!==e.onRequest)).map((e=>e.onRequest))});return((t,r)=>{if((n=t.output).envelope.enabled&&n.envelope.errors.execution&&!n.envelope.errors.other){if(r instanceof Error)throw r;return r.value}var n;const o=t.output,s=o.envelope.enabled,i=!("throw"!==e(o,"other")||o.envelope.enabled&&o.envelope.errors.other),a=!("return"!==e(o,"other")||o.envelope.enabled&&o.envelope.errors.other),u=!("throw"!==e(o,"execution")||o.envelope.enabled&&o.envelope.errors.execution),c=!("return"!==e(o,"execution")||o.envelope.enabled&&o.envelope.errors.execution);if(r instanceof Error){if(i)throw r;return a?r:s?{errors:[r]}:r}if(r.value.errors&&r.value.errors.length>0){const e=new d("One or more errors in the execution result.",{},r.value.errors.map((e=>{if(e instanceof Error)return e;const{message:t,...r}=e;return new p(t,r)})));if(u)throw e;return c?e:s?{...r.value,errors:[...r.value.errors??[],e]}:e}return s?r.value:r.value.data})(r,m)}}}}),Fe=(e,t)=>({scalar:(...r)=>{const n=ye(r[0])?r[0]:de(r[0],r[1]);return e({...t,scalars:{...t.scalars,map:{...t.scalars.map,[n.name]:n}}})}}),qe=(e,t)=>({transport:(...r)=>{const n="string"==typeof r[0]?r[0]:t.transports.current,o=("string"==typeof r[0]?r[1]:r[0])??{};if(!n)throw Error("No transport is currently set.");const s=Re(t,n,o);return e(s)}}),Re=(e,t,r)=>{const n={...e.transports.configurations[t]??{},...r};return"http"===t&&r.headers&&(n.headers={...e.transports.configurations[t]?.headers,...r.headers}),{...e,transports:{...e.transports,current:t,configurations:{...e.transports.configurations,[t]:n}}}},Pe=(e,t)=>({use:r=>e(((e,t)=>{const r={...e,extensions:[...e.extensions,t]};if(t.transport){if(r.requestPipelineDefinition={...e.requestPipelineDefinition,overloads:[...e.requestPipelineDefinition.overloads,t.transport.requestPipelineOverload]},r.transports={current:e.transports.current,registry:{...e.transports.registry},configurations:{...e.transports.configurations}},void 0!==r.transports.registry[t.transport.name])throw Error(`Transport "${t.transport.name}" is already registered.`);null===r.transports.current&&(r.transports.current=t.transport.name),r.transports.registry[t.transport.name]=t.transport,r.transports.configurations[t.transport.name]={...t.transport.configDefaults,...t.transport.config}}return r})(t,r))}),Ve=e=>{const t={_:e,...(r=Ve,n=e,{with:e=>r(Se.updateContextConfigInit(n,e))}),...qe(Ve,e),..._e(0,e),...Pe(Ve,e),...De(Ve,e),...Fe(Ve,e)};var r,n;return e.extensions.forEach((r=>{Object.assign(t,r.builder?.({client:t,context:e})??{})})),t},je=(()=>{const e=Se.updateContextConfigInit(Se.States.empty,{});return Ve(e)})();console.log(je);
