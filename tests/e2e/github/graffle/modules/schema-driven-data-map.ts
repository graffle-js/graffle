import type * as $$Utilities from '#graffle/utilities-for-generated'
import * as $$Scalar from './scalar.js'
//
//
//
//
//
//
// ==================================================================================================
//                                           ScalarStandard
// ==================================================================================================
//
//
//
//
//
//

const String = $$Scalar.String

const ID = $$Scalar.ID

const Boolean = $$Scalar.Boolean

const Int = $$Scalar.Int

const Float = $$Scalar.Float

//
//
//
//
//
//
// ==================================================================================================
//                                            ScalarCustom
// ==================================================================================================
//
//
//
//
//
//

const Base64String = 'Base64String'

const BigInt = 'BigInt'

const Date = 'Date'

const DateTime = 'DateTime'

const GitObjectID = 'GitObjectID'

const GitRefname = 'GitRefname'

const GitSSHRemote = 'GitSSHRemote'

const GitTimestamp = 'GitTimestamp'

const HTML = 'HTML'

const PreciseDateTime = 'PreciseDateTime'

const URI = 'URI'

const X509Certificate = 'X509Certificate'

//
//
//
//
//
//
// ==================================================================================================
//                                                Enum
// ==================================================================================================
//
//
//
//
//
//

const ActorType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ActorType',
}

const AuditLogOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'AuditLogOrderField',
}

const CheckAnnotationLevel: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CheckAnnotationLevel',
}

const CheckConclusionState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CheckConclusionState',
}

const CheckRunState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CheckRunState',
}

const CheckRunType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CheckRunType',
}

const CheckStatusState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CheckStatusState',
}

const CollaboratorAffiliation: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CollaboratorAffiliation',
}

const CommentAuthorAssociation: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CommentAuthorAssociation',
}

const CommentCannotUpdateReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CommentCannotUpdateReason',
}

const CommitContributionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'CommitContributionOrderField',
}

const ComparisonStatus: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ComparisonStatus',
}

const ContributionLevel: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ContributionLevel',
}

const DefaultRepositoryPermissionField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DefaultRepositoryPermissionField',
}

const DependencyGraphEcosystem: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DependencyGraphEcosystem',
}

const DeploymentOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DeploymentOrderField',
}

const DeploymentProtectionRuleType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DeploymentProtectionRuleType',
}

const DeploymentReviewState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DeploymentReviewState',
}

const DeploymentState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DeploymentState',
}

const DeploymentStatusState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DeploymentStatusState',
}

const DiffSide: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiffSide',
}

const DiscussionCloseReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiscussionCloseReason',
}

const DiscussionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiscussionOrderField',
}

const DiscussionPollOptionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiscussionPollOptionOrderField',
}

const DiscussionState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiscussionState',
}

const DiscussionStateReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DiscussionStateReason',
}

const DismissReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'DismissReason',
}

const EnterpriseAdministratorInvitationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseAdministratorInvitationOrderField',
}

const EnterpriseAdministratorRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseAdministratorRole',
}

const EnterpriseAllowPrivateRepositoryForkingPolicyValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseAllowPrivateRepositoryForkingPolicyValue',
}

const EnterpriseDefaultRepositoryPermissionSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseDefaultRepositoryPermissionSettingValue',
}

const EnterpriseDisallowedMethodsSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseDisallowedMethodsSettingValue',
}

const EnterpriseEnabledDisabledSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseEnabledDisabledSettingValue',
}

const EnterpriseEnabledSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseEnabledSettingValue',
}

const EnterpriseMemberInvitationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseMemberInvitationOrderField',
}

const EnterpriseMemberOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseMemberOrderField',
}

const EnterpriseMembersCanCreateRepositoriesSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseMembersCanCreateRepositoriesSettingValue',
}

const EnterpriseMembersCanMakePurchasesSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseMembersCanMakePurchasesSettingValue',
}

const EnterpriseMembershipType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseMembershipType',
}

const EnterpriseOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseOrderField',
}

const EnterpriseServerInstallationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseServerInstallationOrderField',
}

const EnterpriseServerUserAccountEmailOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseServerUserAccountEmailOrderField',
}

const EnterpriseServerUserAccountOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseServerUserAccountOrderField',
}

const EnterpriseServerUserAccountsUploadOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseServerUserAccountsUploadOrderField',
}

const EnterpriseServerUserAccountsUploadSyncState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseServerUserAccountsUploadSyncState',
}

const EnterpriseUserAccountMembershipRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseUserAccountMembershipRole',
}

const EnterpriseUserDeployment: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnterpriseUserDeployment',
}

const EnvironmentOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnvironmentOrderField',
}

const EnvironmentPinnedFilterField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'EnvironmentPinnedFilterField',
}

const FileViewedState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'FileViewedState',
}

const FundingPlatform: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'FundingPlatform',
}

const GistOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'GistOrderField',
}

const GistPrivacy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'GistPrivacy',
}

const GitSignatureState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'GitSignatureState',
}

const IdentityProviderConfigurationState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IdentityProviderConfigurationState',
}

const IpAllowListEnabledSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IpAllowListEnabledSettingValue',
}

const IpAllowListEntryOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IpAllowListEntryOrderField',
}

const IpAllowListForInstalledAppsEnabledSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IpAllowListForInstalledAppsEnabledSettingValue',
}

const IssueClosedStateReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueClosedStateReason',
}

const IssueCommentOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueCommentOrderField',
}

const IssueOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueOrderField',
}

const IssueState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueState',
}

const IssueStateReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueStateReason',
}

const IssueTimelineItemsItemType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'IssueTimelineItemsItemType',
}

const LabelOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'LabelOrderField',
}

const LanguageOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'LanguageOrderField',
}

const LockReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'LockReason',
}

const MannequinOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MannequinOrderField',
}

const MergeCommitMessage: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeCommitMessage',
}

const MergeCommitTitle: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeCommitTitle',
}

const MergeQueueEntryState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeQueueEntryState',
}

const MergeQueueGroupingStrategy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeQueueGroupingStrategy',
}

const MergeQueueMergeMethod: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeQueueMergeMethod',
}

const MergeQueueMergingStrategy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeQueueMergingStrategy',
}

const MergeStateStatus: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeStateStatus',
}

const MergeableState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MergeableState',
}

const MigrationSourceType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MigrationSourceType',
}

const MigrationState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MigrationState',
}

const MilestoneOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MilestoneOrderField',
}

const MilestoneState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'MilestoneState',
}

const NotificationRestrictionSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'NotificationRestrictionSettingValue',
}

const OIDCProviderType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OIDCProviderType',
}

const OauthApplicationCreateAuditEntryState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OauthApplicationCreateAuditEntryState',
}

const OperationType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OperationType',
}

const OrderDirection: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrderDirection',
}

const OrgAddMemberAuditEntryPermission: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgAddMemberAuditEntryPermission',
}

const OrgCreateAuditEntryBillingPlan: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgCreateAuditEntryBillingPlan',
}

const OrgEnterpriseOwnerOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgEnterpriseOwnerOrderField',
}

const OrgRemoveBillingManagerAuditEntryReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgRemoveBillingManagerAuditEntryReason',
}

const OrgRemoveMemberAuditEntryMembershipType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgRemoveMemberAuditEntryMembershipType',
}

const OrgRemoveMemberAuditEntryReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgRemoveMemberAuditEntryReason',
}

const OrgRemoveOutsideCollaboratorAuditEntryMembershipType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgRemoveOutsideCollaboratorAuditEntryMembershipType',
}

const OrgRemoveOutsideCollaboratorAuditEntryReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgRemoveOutsideCollaboratorAuditEntryReason',
}

const OrgUpdateDefaultRepositoryPermissionAuditEntryPermission: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgUpdateDefaultRepositoryPermissionAuditEntryPermission',
}

const OrgUpdateMemberAuditEntryPermission: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgUpdateMemberAuditEntryPermission',
}

const OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility',
}

const OrganizationInvitationRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationInvitationRole',
}

const OrganizationInvitationSource: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationInvitationSource',
}

const OrganizationInvitationType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationInvitationType',
}

const OrganizationMemberRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationMemberRole',
}

const OrganizationMembersCanCreateRepositoriesSettingValue: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationMembersCanCreateRepositoriesSettingValue',
}

const OrganizationMigrationState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationMigrationState',
}

const OrganizationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'OrganizationOrderField',
}

const PackageFileOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PackageFileOrderField',
}

const PackageOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PackageOrderField',
}

const PackageType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PackageType',
}

const PackageVersionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PackageVersionOrderField',
}

const PatchStatus: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PatchStatus',
}

const PinnableItemType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PinnableItemType',
}

const PinnedDiscussionGradient: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PinnedDiscussionGradient',
}

const PinnedDiscussionPattern: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PinnedDiscussionPattern',
}

const PinnedEnvironmentOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PinnedEnvironmentOrderField',
}

const ProjectCardArchivedState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectCardArchivedState',
}

const ProjectCardState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectCardState',
}

const ProjectColumnPurpose: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectColumnPurpose',
}

const ProjectOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectOrderField',
}

const ProjectState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectState',
}

const ProjectTemplate: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectTemplate',
}

const ProjectV2CustomFieldType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2CustomFieldType',
}

const ProjectV2FieldOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2FieldOrderField',
}

const ProjectV2FieldType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2FieldType',
}

const ProjectV2ItemFieldValueOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2ItemFieldValueOrderField',
}

const ProjectV2ItemOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2ItemOrderField',
}

const ProjectV2ItemType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2ItemType',
}

const ProjectV2OrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2OrderField',
}

const ProjectV2PermissionLevel: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2PermissionLevel',
}

const ProjectV2Roles: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2Roles',
}

const ProjectV2SingleSelectFieldOptionColor: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2SingleSelectFieldOptionColor',
}

const ProjectV2State: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2State',
}

const ProjectV2StatusUpdateOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2StatusUpdateOrderField',
}

const ProjectV2StatusUpdateStatus: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2StatusUpdateStatus',
}

const ProjectV2ViewLayout: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2ViewLayout',
}

const ProjectV2ViewOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2ViewOrderField',
}

const ProjectV2WorkflowsOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ProjectV2WorkflowsOrderField',
}

const PullRequestBranchUpdateMethod: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestBranchUpdateMethod',
}

const PullRequestMergeMethod: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestMergeMethod',
}

const PullRequestOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestOrderField',
}

const PullRequestReviewCommentState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestReviewCommentState',
}

const PullRequestReviewDecision: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestReviewDecision',
}

const PullRequestReviewEvent: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestReviewEvent',
}

const PullRequestReviewState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestReviewState',
}

const PullRequestReviewThreadSubjectType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestReviewThreadSubjectType',
}

const PullRequestState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestState',
}

const PullRequestTimelineItemsItemType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestTimelineItemsItemType',
}

const PullRequestUpdateState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'PullRequestUpdateState',
}

const ReactionContent: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ReactionContent',
}

const ReactionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ReactionOrderField',
}

const RefOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RefOrderField',
}

const ReleaseOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ReleaseOrderField',
}

const RepoAccessAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoAccessAuditEntryVisibility',
}

const RepoAddMemberAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoAddMemberAuditEntryVisibility',
}

const RepoArchivedAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoArchivedAuditEntryVisibility',
}

const RepoChangeMergeSettingAuditEntryMergeType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoChangeMergeSettingAuditEntryMergeType',
}

const RepoCreateAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoCreateAuditEntryVisibility',
}

const RepoDestroyAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoDestroyAuditEntryVisibility',
}

const RepoRemoveMemberAuditEntryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepoRemoveMemberAuditEntryVisibility',
}

const ReportedContentClassifiers: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ReportedContentClassifiers',
}

const RepositoryAffiliation: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryAffiliation',
}

const RepositoryContributionType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryContributionType',
}

const RepositoryInteractionLimit: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryInteractionLimit',
}

const RepositoryInteractionLimitExpiry: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryInteractionLimitExpiry',
}

const RepositoryInteractionLimitOrigin: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryInteractionLimitOrigin',
}

const RepositoryInvitationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryInvitationOrderField',
}

const RepositoryLockReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryLockReason',
}

const RepositoryMigrationOrderDirection: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryMigrationOrderDirection',
}

const RepositoryMigrationOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryMigrationOrderField',
}

const RepositoryOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryOrderField',
}

const RepositoryPermission: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryPermission',
}

const RepositoryPrivacy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryPrivacy',
}

const RepositoryRuleOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryRuleOrderField',
}

const RepositoryRuleType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryRuleType',
}

const RepositoryRulesetBypassActorBypassMode: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryRulesetBypassActorBypassMode',
}

const RepositoryRulesetTarget: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryRulesetTarget',
}

const RepositoryVisibility: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryVisibility',
}

const RepositoryVulnerabilityAlertDependencyScope: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryVulnerabilityAlertDependencyScope',
}

const RepositoryVulnerabilityAlertState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RepositoryVulnerabilityAlertState',
}

const RequestableCheckStatusState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RequestableCheckStatusState',
}

const RoleInOrganization: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RoleInOrganization',
}

const RuleEnforcement: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'RuleEnforcement',
}

const SamlDigestAlgorithm: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SamlDigestAlgorithm',
}

const SamlSignatureAlgorithm: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SamlSignatureAlgorithm',
}

const SavedReplyOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SavedReplyOrderField',
}

const SearchType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SearchType',
}

const SecurityAdvisoryClassification: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityAdvisoryClassification',
}

const SecurityAdvisoryEcosystem: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityAdvisoryEcosystem',
}

const SecurityAdvisoryIdentifierType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityAdvisoryIdentifierType',
}

const SecurityAdvisoryOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityAdvisoryOrderField',
}

const SecurityAdvisorySeverity: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityAdvisorySeverity',
}

const SecurityVulnerabilityOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SecurityVulnerabilityOrderField',
}

const SocialAccountProvider: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SocialAccountProvider',
}

const SponsorAndLifetimeValueOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorAndLifetimeValueOrderField',
}

const SponsorOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorOrderField',
}

const SponsorableOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorableOrderField',
}

const SponsorsActivityAction: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsActivityAction',
}

const SponsorsActivityOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsActivityOrderField',
}

const SponsorsActivityPeriod: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsActivityPeriod',
}

const SponsorsCountryOrRegionCode: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsCountryOrRegionCode',
}

const SponsorsGoalKind: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsGoalKind',
}

const SponsorsListingFeaturedItemFeatureableType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsListingFeaturedItemFeatureableType',
}

const SponsorsTierOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorsTierOrderField',
}

const SponsorshipNewsletterOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorshipNewsletterOrderField',
}

const SponsorshipOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorshipOrderField',
}

const SponsorshipPaymentSource: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorshipPaymentSource',
}

const SponsorshipPrivacy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SponsorshipPrivacy',
}

const SquashMergeCommitMessage: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SquashMergeCommitMessage',
}

const SquashMergeCommitTitle: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SquashMergeCommitTitle',
}

const StarOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'StarOrderField',
}

const StatusState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'StatusState',
}

const SubscriptionState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'SubscriptionState',
}

const TeamDiscussionCommentOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamDiscussionCommentOrderField',
}

const TeamDiscussionOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamDiscussionOrderField',
}

const TeamMemberOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamMemberOrderField',
}

const TeamMemberRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamMemberRole',
}

const TeamMembershipType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamMembershipType',
}

const TeamNotificationSetting: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamNotificationSetting',
}

const TeamOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamOrderField',
}

const TeamPrivacy: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamPrivacy',
}

const TeamRepositoryOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamRepositoryOrderField',
}

const TeamReviewAssignmentAlgorithm: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamReviewAssignmentAlgorithm',
}

const TeamRole: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TeamRole',
}

const ThreadSubscriptionFormAction: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ThreadSubscriptionFormAction',
}

const ThreadSubscriptionState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'ThreadSubscriptionState',
}

const TopicSuggestionDeclineReason: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TopicSuggestionDeclineReason',
}

const TrackedIssueStates: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TrackedIssueStates',
}

const TwoFactorCredentialSecurityType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'TwoFactorCredentialSecurityType',
}

const UserBlockDuration: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'UserBlockDuration',
}

const UserStatusOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'UserStatusOrderField',
}

const UserViewType: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'UserViewType',
}

const VerifiableDomainOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'VerifiableDomainOrderField',
}

const WorkflowRunOrderField: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'WorkflowRunOrderField',
}

const WorkflowState: $$Utilities.SchemaDrivenDataMap.Enum = {
  k: 'enum',
  n: 'WorkflowState',
}

//
//
//
//
//
//
// ==================================================================================================
//                                            InputObject
// ==================================================================================================
//
//
//
//
//
//

const AbortQueuedMigrationsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AbortQueuedMigrationsInput',
  f: {
    clientMutationId: {},
    ownerId: {},
  },
}

const AbortRepositoryMigrationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AbortRepositoryMigrationInput',
  f: {
    clientMutationId: {},
    migrationId: {},
  },
}

const AcceptEnterpriseAdministratorInvitationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AcceptEnterpriseAdministratorInvitationInput',
  f: {
    clientMutationId: {},
    invitationId: {},
  },
}

const AcceptEnterpriseMemberInvitationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AcceptEnterpriseMemberInvitationInput',
  f: {
    clientMutationId: {},
    invitationId: {},
  },
}

const AcceptTopicSuggestionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AcceptTopicSuggestionInput',
  f: {
    clientMutationId: {},
    name: {},
    repositoryId: {},
  },
}

const AccessUserNamespaceRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AccessUserNamespaceRepositoryInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    repositoryId: {},
  },
}

const AddAssigneesToAssignableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddAssigneesToAssignableInput',
  f: {
    assignableId: {},
    assigneeIds: {},
    clientMutationId: {},
  },
}

const AddCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    subjectId: {},
  },
}

const AddDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddDiscussionCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    discussionId: {},
    replyToId: {},
  },
}

const AddDiscussionPollVoteInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddDiscussionPollVoteInput',
  f: {
    clientMutationId: {},
    pollOptionId: {},
  },
}

const AddEnterpriseOrganizationMemberInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddEnterpriseOrganizationMemberInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    organizationId: {},
    role: {},
    userIds: {},
  },
}

const AddEnterpriseSupportEntitlementInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddEnterpriseSupportEntitlementInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
  },
}

const AddLabelsToLabelableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddLabelsToLabelableInput',
  f: {
    clientMutationId: {},
    labelIds: {},
    labelableId: {},
  },
}

const AddProjectCardInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddProjectCardInput',
  f: {
    clientMutationId: {},
    contentId: {},
    note: {},
    projectColumnId: {},
  },
}

const AddProjectColumnInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddProjectColumnInput',
  f: {
    clientMutationId: {},
    name: {},
    projectId: {},
  },
}

const AddProjectV2DraftIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddProjectV2DraftIssueInput',
  f: {
    assigneeIds: {},
    body: {},
    clientMutationId: {},
    projectId: {},
    title: {},
  },
}

const AddProjectV2ItemByIdInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddProjectV2ItemByIdInput',
  f: {
    clientMutationId: {},
    contentId: {},
    projectId: {},
  },
}

const AddPullRequestReviewCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddPullRequestReviewCommentInput',
  fcs: ['commitOID'],
  f: {
    body: {},
    clientMutationId: {},
    commitOID: {
      nt: GitObjectID,
    },
    inReplyTo: {},
    path: {},
    position: {},
    pullRequestId: {},
    pullRequestReviewId: {},
  },
}

const AddPullRequestReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddPullRequestReviewInput',
  fcs: ['commitOID'],
  f: {
    body: {},
    clientMutationId: {},
    comments: {},
    commitOID: {
      nt: GitObjectID,
    },
    event: {},
    pullRequestId: {},
    threads: {},
  },
}

const AddPullRequestReviewThreadInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddPullRequestReviewThreadInput',
  f: {
    body: {},
    clientMutationId: {},
    line: {},
    path: {},
    pullRequestId: {},
    pullRequestReviewId: {},
    side: {},
    startLine: {},
    startSide: {},
    subjectType: {},
  },
}

const AddPullRequestReviewThreadReplyInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddPullRequestReviewThreadReplyInput',
  f: {
    body: {},
    clientMutationId: {},
    pullRequestReviewId: {},
    pullRequestReviewThreadId: {},
  },
}

const AddReactionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddReactionInput',
  f: {
    clientMutationId: {},
    content: {},
    subjectId: {},
  },
}

const AddStarInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddStarInput',
  f: {
    clientMutationId: {},
    starrableId: {},
  },
}

const AddSubIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddSubIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
    replaceParent: {},
    subIssueId: {},
    subIssueUrl: {},
  },
}

const AddUpvoteInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddUpvoteInput',
  f: {
    clientMutationId: {},
    subjectId: {},
  },
}

const AddVerifiableDomainInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AddVerifiableDomainInput',
  fcs: ['domain'],
  f: {
    clientMutationId: {},
    domain: {
      nt: URI,
    },
    ownerId: {},
  },
}

const ApproveDeploymentsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ApproveDeploymentsInput',
  f: {
    clientMutationId: {},
    comment: {},
    environmentIds: {},
    workflowRunId: {},
  },
}

const ApproveVerifiableDomainInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ApproveVerifiableDomainInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const ArchiveProjectV2ItemInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ArchiveProjectV2ItemInput',
  f: {
    clientMutationId: {},
    itemId: {},
    projectId: {},
  },
}

const ArchiveRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ArchiveRepositoryInput',
  f: {
    clientMutationId: {},
    repositoryId: {},
  },
}

const AuditLogOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'AuditLogOrder',
  f: {
    direction: {},
    field: {},
  },
}

const BranchNamePatternParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'BranchNamePatternParametersInput',
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const BulkSponsorship: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'BulkSponsorship',
  f: {
    amount: {},
    sponsorableId: {},
    sponsorableLogin: {},
  },
}

const CancelEnterpriseAdminInvitationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CancelEnterpriseAdminInvitationInput',
  f: {
    clientMutationId: {},
    invitationId: {},
  },
}

const CancelEnterpriseMemberInvitationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CancelEnterpriseMemberInvitationInput',
  f: {
    clientMutationId: {},
    invitationId: {},
  },
}

const CancelSponsorshipInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CancelSponsorshipInput',
  f: {
    clientMutationId: {},
    sponsorId: {},
    sponsorLogin: {},
    sponsorableId: {},
    sponsorableLogin: {},
  },
}

const ChangeUserStatusInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ChangeUserStatusInput',
  fcs: ['expiresAt'],
  f: {
    clientMutationId: {},
    emoji: {},
    expiresAt: {
      nt: DateTime,
    },
    limitedAvailability: {},
    message: {},
    organizationId: {},
  },
}

const CheckAnnotationData: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckAnnotationData',
  f: {
    annotationLevel: {},
    location: {},
    message: {},
    path: {},
    rawDetails: {},
    title: {},
  },
}

const CheckAnnotationRange: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckAnnotationRange',
  f: {
    endColumn: {},
    endLine: {},
    startColumn: {},
    startLine: {},
  },
}

const CheckRunAction: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckRunAction',
  f: {
    description: {},
    identifier: {},
    label: {},
  },
}

const CheckRunFilter: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckRunFilter',
  f: {
    appId: {},
    checkName: {},
    checkType: {},
    conclusions: {},
    status: {},
    statuses: {},
  },
}

const CheckRunOutput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckRunOutput',
  fcs: ['images'],
  f: {
    annotations: {},
    images: {
      // nt: CheckRunOutputImage, <-- Assigned later to avoid potential circular dependency.
    },
    summary: {},
    text: {},
    title: {},
  },
}

const CheckRunOutputImage: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckRunOutputImage',
  fcs: ['imageUrl'],
  f: {
    alt: {},
    caption: {},
    imageUrl: {
      nt: URI,
    },
  },
}

const CheckSuiteAutoTriggerPreference: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckSuiteAutoTriggerPreference',
  f: {
    appId: {},
    setting: {},
  },
}

const CheckSuiteFilter: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CheckSuiteFilter',
  f: {
    appId: {},
    checkName: {},
  },
}

const ClearLabelsFromLabelableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ClearLabelsFromLabelableInput',
  f: {
    clientMutationId: {},
    labelableId: {},
  },
}

const ClearProjectV2ItemFieldValueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ClearProjectV2ItemFieldValueInput',
  f: {
    clientMutationId: {},
    fieldId: {},
    itemId: {},
    projectId: {},
  },
}

const CloneProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CloneProjectInput',
  f: {
    body: {},
    clientMutationId: {},
    includeWorkflows: {},
    name: {},
    public: {},
    sourceId: {},
    targetOwnerId: {},
  },
}

const CloneTemplateRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CloneTemplateRepositoryInput',
  f: {
    clientMutationId: {},
    description: {},
    includeAllBranches: {},
    name: {},
    ownerId: {},
    repositoryId: {},
    visibility: {},
  },
}

const CloseDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CloseDiscussionInput',
  f: {
    clientMutationId: {},
    discussionId: {},
    reason: {},
  },
}

const CloseIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CloseIssueInput',
  f: {
    clientMutationId: {},
    duplicateIssueId: {},
    issueId: {},
    stateReason: {},
  },
}

const ClosePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ClosePullRequestInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
  },
}

const CodeScanningParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CodeScanningParametersInput',
  f: {
    codeScanningTools: {},
  },
}

const CodeScanningToolInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CodeScanningToolInput',
  f: {
    alertsThreshold: {},
    securityAlertsThreshold: {},
    tool: {},
  },
}

const CommitAuthor: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitAuthor',
  f: {
    emails: {},
    id: {},
  },
}

const CommitAuthorEmailPatternParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitAuthorEmailPatternParametersInput',
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const CommitContributionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitContributionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const CommitMessage: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitMessage',
  f: {
    body: {},
    headline: {},
  },
}

const CommitMessagePatternParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitMessagePatternParametersInput',
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const CommittableBranch: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommittableBranch',
  f: {
    branchName: {},
    id: {},
    repositoryNameWithOwner: {},
  },
}

const CommitterEmailPatternParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CommitterEmailPatternParametersInput',
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const ContributionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ContributionOrder',
  f: {
    direction: {},
  },
}

const ConvertProjectCardNoteToIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ConvertProjectCardNoteToIssueInput',
  f: {
    body: {},
    clientMutationId: {},
    projectCardId: {},
    repositoryId: {},
    title: {},
  },
}

const ConvertProjectV2DraftIssueItemToIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ConvertProjectV2DraftIssueItemToIssueInput',
  f: {
    clientMutationId: {},
    itemId: {},
    repositoryId: {},
  },
}

const ConvertPullRequestToDraftInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ConvertPullRequestToDraftInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
  },
}

const CopyProjectV2Input: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CopyProjectV2Input',
  f: {
    clientMutationId: {},
    includeDraftIssues: {},
    ownerId: {},
    projectId: {},
    title: {},
  },
}

const CreateAttributionInvitationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateAttributionInvitationInput',
  f: {
    clientMutationId: {},
    ownerId: {},
    sourceId: {},
    targetId: {},
  },
}

const CreateBranchProtectionRuleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateBranchProtectionRuleInput',
  f: {
    allowsDeletions: {},
    allowsForcePushes: {},
    blocksCreations: {},
    bypassForcePushActorIds: {},
    bypassPullRequestActorIds: {},
    clientMutationId: {},
    dismissesStaleReviews: {},
    isAdminEnforced: {},
    lockAllowsFetchAndMerge: {},
    lockBranch: {},
    pattern: {},
    pushActorIds: {},
    repositoryId: {},
    requireLastPushApproval: {},
    requiredApprovingReviewCount: {},
    requiredDeploymentEnvironments: {},
    requiredStatusCheckContexts: {},
    requiredStatusChecks: {},
    requiresApprovingReviews: {},
    requiresCodeOwnerReviews: {},
    requiresCommitSignatures: {},
    requiresConversationResolution: {},
    requiresDeployments: {},
    requiresLinearHistory: {},
    requiresStatusChecks: {},
    requiresStrictStatusChecks: {},
    restrictsPushes: {},
    restrictsReviewDismissals: {},
    reviewDismissalActorIds: {},
  },
}

const CreateCheckRunInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateCheckRunInput',
  fcs: ['completedAt', 'detailsUrl', 'headSha', 'output', 'startedAt'],
  f: {
    actions: {},
    clientMutationId: {},
    completedAt: {
      nt: DateTime,
    },
    conclusion: {},
    detailsUrl: {
      nt: URI,
    },
    externalId: {},
    headSha: {
      nt: GitObjectID,
    },
    name: {},
    output: {
      // nt: CheckRunOutput, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryId: {},
    startedAt: {
      nt: DateTime,
    },
    status: {},
  },
}

const CreateCheckSuiteInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateCheckSuiteInput',
  fcs: ['headSha'],
  f: {
    clientMutationId: {},
    headSha: {
      nt: GitObjectID,
    },
    repositoryId: {},
  },
}

const CreateCommitOnBranchInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateCommitOnBranchInput',
  fcs: ['expectedHeadOid', 'fileChanges'],
  f: {
    branch: {},
    clientMutationId: {},
    expectedHeadOid: {
      nt: GitObjectID,
    },
    fileChanges: {
      // nt: FileChanges, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const CreateDeploymentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateDeploymentInput',
  f: {
    autoMerge: {},
    clientMutationId: {},
    description: {},
    environment: {},
    payload: {},
    refId: {},
    repositoryId: {},
    requiredContexts: {},
    task: {},
  },
}

const CreateDeploymentStatusInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateDeploymentStatusInput',
  f: {
    autoInactive: {},
    clientMutationId: {},
    deploymentId: {},
    description: {},
    environment: {},
    environmentUrl: {},
    logUrl: {},
    state: {},
  },
}

const CreateDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateDiscussionInput',
  f: {
    body: {},
    categoryId: {},
    clientMutationId: {},
    repositoryId: {},
    title: {},
  },
}

const CreateEnterpriseOrganizationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateEnterpriseOrganizationInput',
  f: {
    adminLogins: {},
    billingEmail: {},
    clientMutationId: {},
    enterpriseId: {},
    login: {},
    profileName: {},
  },
}

const CreateEnvironmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateEnvironmentInput',
  f: {
    clientMutationId: {},
    name: {},
    repositoryId: {},
  },
}

const CreateIpAllowListEntryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateIpAllowListEntryInput',
  f: {
    allowListValue: {},
    clientMutationId: {},
    isActive: {},
    name: {},
    ownerId: {},
  },
}

const CreateIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateIssueInput',
  f: {
    assigneeIds: {},
    body: {},
    clientMutationId: {},
    issueTemplate: {},
    labelIds: {},
    milestoneId: {},
    parentIssueId: {},
    projectIds: {},
    repositoryId: {},
    title: {},
  },
}

const CreateLabelInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateLabelInput',
  f: {
    clientMutationId: {},
    color: {},
    description: {},
    name: {},
    repositoryId: {},
  },
}

const CreateLinkedBranchInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateLinkedBranchInput',
  fcs: ['oid'],
  f: {
    clientMutationId: {},
    issueId: {},
    name: {},
    oid: {
      nt: GitObjectID,
    },
    repositoryId: {},
  },
}

const CreateMigrationSourceInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateMigrationSourceInput',
  f: {
    accessToken: {},
    clientMutationId: {},
    githubPat: {},
    name: {},
    ownerId: {},
    type: {},
    url: {},
  },
}

const CreateProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateProjectInput',
  f: {
    body: {},
    clientMutationId: {},
    name: {},
    ownerId: {},
    repositoryIds: {},
    template: {},
  },
}

const CreateProjectV2FieldInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateProjectV2FieldInput',
  f: {
    clientMutationId: {},
    dataType: {},
    name: {},
    projectId: {},
    singleSelectOptions: {},
  },
}

const CreateProjectV2Input: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateProjectV2Input',
  f: {
    clientMutationId: {},
    ownerId: {},
    repositoryId: {},
    teamId: {},
    title: {},
  },
}

const CreateProjectV2StatusUpdateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateProjectV2StatusUpdateInput',
  fcs: ['startDate', 'targetDate'],
  f: {
    body: {},
    clientMutationId: {},
    projectId: {},
    startDate: {
      nt: Date,
    },
    status: {},
    targetDate: {
      nt: Date,
    },
  },
}

const CreatePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreatePullRequestInput',
  f: {
    baseRefName: {},
    body: {},
    clientMutationId: {},
    draft: {},
    headRefName: {},
    headRepositoryId: {},
    maintainerCanModify: {},
    repositoryId: {},
    title: {},
  },
}

const CreateRefInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateRefInput',
  fcs: ['oid'],
  f: {
    clientMutationId: {},
    name: {},
    oid: {
      nt: GitObjectID,
    },
    repositoryId: {},
  },
}

const CreateRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateRepositoryInput',
  fcs: ['homepageUrl'],
  f: {
    clientMutationId: {},
    description: {},
    hasIssuesEnabled: {},
    hasWikiEnabled: {},
    homepageUrl: {
      nt: URI,
    },
    name: {},
    ownerId: {},
    teamId: {},
    template: {},
    visibility: {},
  },
}

const CreateRepositoryRulesetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateRepositoryRulesetInput',
  f: {
    bypassActors: {},
    clientMutationId: {},
    conditions: {},
    enforcement: {},
    name: {},
    rules: {},
    sourceId: {},
    target: {},
  },
}

const CreateSponsorsListingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateSponsorsListingInput',
  f: {
    billingCountryOrRegionCode: {},
    clientMutationId: {},
    contactEmail: {},
    fiscalHostLogin: {},
    fiscallyHostedProjectProfileUrl: {},
    fullDescription: {},
    residenceCountryOrRegionCode: {},
    sponsorableLogin: {},
  },
}

const CreateSponsorsTierInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateSponsorsTierInput',
  f: {
    amount: {},
    clientMutationId: {},
    description: {},
    isRecurring: {},
    publish: {},
    repositoryId: {},
    repositoryName: {},
    repositoryOwnerLogin: {},
    sponsorableId: {},
    sponsorableLogin: {},
    welcomeMessage: {},
  },
}

const CreateSponsorshipInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateSponsorshipInput',
  f: {
    amount: {},
    clientMutationId: {},
    isRecurring: {},
    privacyLevel: {},
    receiveEmails: {},
    sponsorId: {},
    sponsorLogin: {},
    sponsorableId: {},
    sponsorableLogin: {},
    tierId: {},
  },
}

const CreateSponsorshipsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateSponsorshipsInput',
  f: {
    clientMutationId: {},
    privacyLevel: {},
    receiveEmails: {},
    recurring: {},
    sponsorLogin: {},
    sponsorships: {},
  },
}

const CreateTeamDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateTeamDiscussionCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    discussionId: {},
  },
}

const CreateTeamDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateTeamDiscussionInput',
  f: {
    body: {},
    clientMutationId: {},
    private: {},
    teamId: {},
    title: {},
  },
}

const CreateUserListInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'CreateUserListInput',
  f: {
    clientMutationId: {},
    description: {},
    isPrivate: {},
    name: {},
  },
}

const DeclineTopicSuggestionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeclineTopicSuggestionInput',
  f: {
    clientMutationId: {},
    name: {},
    reason: {},
    repositoryId: {},
  },
}

const DeleteBranchProtectionRuleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteBranchProtectionRuleInput',
  f: {
    branchProtectionRuleId: {},
    clientMutationId: {},
  },
}

const DeleteDeploymentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteDeploymentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteDiscussionCommentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteDiscussionInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteEnvironmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteEnvironmentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteIpAllowListEntryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteIpAllowListEntryInput',
  f: {
    clientMutationId: {},
    ipAllowListEntryId: {},
  },
}

const DeleteIssueCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteIssueCommentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
  },
}

const DeleteLabelInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteLabelInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteLinkedBranchInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteLinkedBranchInput',
  f: {
    clientMutationId: {},
    linkedBranchId: {},
  },
}

const DeletePackageVersionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeletePackageVersionInput',
  f: {
    clientMutationId: {},
    packageVersionId: {},
  },
}

const DeleteProjectCardInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectCardInput',
  f: {
    cardId: {},
    clientMutationId: {},
  },
}

const DeleteProjectColumnInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectColumnInput',
  f: {
    clientMutationId: {},
    columnId: {},
  },
}

const DeleteProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectInput',
  f: {
    clientMutationId: {},
    projectId: {},
  },
}

const DeleteProjectV2FieldInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectV2FieldInput',
  f: {
    clientMutationId: {},
    fieldId: {},
  },
}

const DeleteProjectV2Input: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectV2Input',
  f: {
    clientMutationId: {},
    projectId: {},
  },
}

const DeleteProjectV2ItemInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectV2ItemInput',
  f: {
    clientMutationId: {},
    itemId: {},
    projectId: {},
  },
}

const DeleteProjectV2StatusUpdateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectV2StatusUpdateInput',
  f: {
    clientMutationId: {},
    statusUpdateId: {},
  },
}

const DeleteProjectV2WorkflowInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteProjectV2WorkflowInput',
  f: {
    clientMutationId: {},
    workflowId: {},
  },
}

const DeletePullRequestReviewCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeletePullRequestReviewCommentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeletePullRequestReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeletePullRequestReviewInput',
  f: {
    clientMutationId: {},
    pullRequestReviewId: {},
  },
}

const DeleteRefInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteRefInput',
  f: {
    clientMutationId: {},
    refId: {},
  },
}

const DeleteRepositoryRulesetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteRepositoryRulesetInput',
  f: {
    clientMutationId: {},
    repositoryRulesetId: {},
  },
}

const DeleteTeamDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteTeamDiscussionCommentInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteTeamDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteTeamDiscussionInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeleteUserListInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteUserListInput',
  f: {
    clientMutationId: {},
    listId: {},
  },
}

const DeleteVerifiableDomainInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeleteVerifiableDomainInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DeploymentOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DeploymentOrder',
  f: {
    direction: {},
    field: {},
  },
}

const DequeuePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DequeuePullRequestInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const DisablePullRequestAutoMergeInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DisablePullRequestAutoMergeInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
  },
}

const DiscussionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DiscussionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const DiscussionPollOptionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DiscussionPollOptionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const DismissPullRequestReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DismissPullRequestReviewInput',
  f: {
    clientMutationId: {},
    message: {},
    pullRequestReviewId: {},
  },
}

const DismissRepositoryVulnerabilityAlertInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DismissRepositoryVulnerabilityAlertInput',
  f: {
    clientMutationId: {},
    dismissReason: {},
    repositoryVulnerabilityAlertId: {},
  },
}

const DraftPullRequestReviewComment: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DraftPullRequestReviewComment',
  f: {
    body: {},
    path: {},
    position: {},
  },
}

const DraftPullRequestReviewThread: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'DraftPullRequestReviewThread',
  f: {
    body: {},
    line: {},
    path: {},
    side: {},
    startLine: {},
    startSide: {},
  },
}

const EnablePullRequestAutoMergeInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnablePullRequestAutoMergeInput',
  fcs: ['expectedHeadOid'],
  f: {
    authorEmail: {},
    clientMutationId: {},
    commitBody: {},
    commitHeadline: {},
    expectedHeadOid: {
      nt: GitObjectID,
    },
    mergeMethod: {},
    pullRequestId: {},
  },
}

const EnqueuePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnqueuePullRequestInput',
  fcs: ['expectedHeadOid'],
  f: {
    clientMutationId: {},
    expectedHeadOid: {
      nt: GitObjectID,
    },
    jump: {},
    pullRequestId: {},
  },
}

const EnterpriseAdministratorInvitationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseAdministratorInvitationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseMemberInvitationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseMemberInvitationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseMemberOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseMemberOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseServerInstallationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseServerInstallationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseServerUserAccountEmailOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseServerUserAccountEmailOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseServerUserAccountOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseServerUserAccountOrder',
  f: {
    direction: {},
    field: {},
  },
}

const EnterpriseServerUserAccountsUploadOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'EnterpriseServerUserAccountsUploadOrder',
  f: {
    direction: {},
    field: {},
  },
}

const Environments: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'Environments',
  f: {
    direction: {},
    field: {},
  },
}

const FileAddition: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FileAddition',
  fcs: ['contents'],
  f: {
    contents: {
      nt: Base64String,
    },
    path: {},
  },
}

const FileChanges: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FileChanges',
  fcs: ['additions'],
  f: {
    additions: {
      // nt: FileAddition, <-- Assigned later to avoid potential circular dependency.
    },
    deletions: {},
  },
}

const FileDeletion: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FileDeletion',
  f: {
    path: {},
  },
}

const FileExtensionRestrictionParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FileExtensionRestrictionParametersInput',
  f: {
    restrictedFileExtensions: {},
  },
}

const FilePathRestrictionParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FilePathRestrictionParametersInput',
  f: {
    restrictedFilePaths: {},
  },
}

const FollowOrganizationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FollowOrganizationInput',
  f: {
    clientMutationId: {},
    organizationId: {},
  },
}

const FollowUserInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'FollowUserInput',
  f: {
    clientMutationId: {},
    userId: {},
  },
}

const GistOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'GistOrder',
  f: {
    direction: {},
    field: {},
  },
}

const GrantEnterpriseOrganizationsMigratorRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'GrantEnterpriseOrganizationsMigratorRoleInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
  },
}

const GrantMigratorRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'GrantMigratorRoleInput',
  f: {
    actor: {},
    actorType: {},
    clientMutationId: {},
    organizationId: {},
  },
}

const ImportProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ImportProjectInput',
  f: {
    body: {},
    clientMutationId: {},
    columnImports: {},
    name: {},
    ownerName: {},
    public: {},
  },
}

const InviteEnterpriseAdminInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InviteEnterpriseAdminInput',
  f: {
    clientMutationId: {},
    email: {},
    enterpriseId: {},
    invitee: {},
    role: {},
  },
}

const InviteEnterpriseMemberInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'InviteEnterpriseMemberInput',
  f: {
    clientMutationId: {},
    email: {},
    enterpriseId: {},
    invitee: {},
  },
}

const IpAllowListEntryOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'IpAllowListEntryOrder',
  f: {
    direction: {},
    field: {},
  },
}

const IssueCommentOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'IssueCommentOrder',
  f: {
    direction: {},
    field: {},
  },
}

const IssueFilters: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'IssueFilters',
  fcs: ['since'],
  f: {
    assignee: {},
    createdBy: {},
    labels: {},
    mentioned: {},
    milestone: {},
    milestoneNumber: {},
    since: {
      nt: DateTime,
    },
    states: {},
    viewerSubscribed: {},
  },
}

const IssueOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'IssueOrder',
  f: {
    direction: {},
    field: {},
  },
}

const LabelOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LabelOrder',
  f: {
    direction: {},
    field: {},
  },
}

const LanguageOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LanguageOrder',
  f: {
    direction: {},
    field: {},
  },
}

const LinkProjectV2ToRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LinkProjectV2ToRepositoryInput',
  f: {
    clientMutationId: {},
    projectId: {},
    repositoryId: {},
  },
}

const LinkProjectV2ToTeamInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LinkProjectV2ToTeamInput',
  f: {
    clientMutationId: {},
    projectId: {},
    teamId: {},
  },
}

const LinkRepositoryToProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LinkRepositoryToProjectInput',
  f: {
    clientMutationId: {},
    projectId: {},
    repositoryId: {},
  },
}

const LockLockableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'LockLockableInput',
  f: {
    clientMutationId: {},
    lockReason: {},
    lockableId: {},
  },
}

const MannequinOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MannequinOrder',
  f: {
    direction: {},
    field: {},
  },
}

const MarkDiscussionCommentAsAnswerInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MarkDiscussionCommentAsAnswerInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const MarkFileAsViewedInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MarkFileAsViewedInput',
  f: {
    clientMutationId: {},
    path: {},
    pullRequestId: {},
  },
}

const MarkProjectV2AsTemplateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MarkProjectV2AsTemplateInput',
  f: {
    clientMutationId: {},
    projectId: {},
  },
}

const MarkPullRequestReadyForReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MarkPullRequestReadyForReviewInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
  },
}

const MaxFilePathLengthParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MaxFilePathLengthParametersInput',
  f: {
    maxFilePathLength: {},
  },
}

const MaxFileSizeParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MaxFileSizeParametersInput',
  f: {
    maxFileSize: {},
  },
}

const MergeBranchInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MergeBranchInput',
  f: {
    authorEmail: {},
    base: {},
    clientMutationId: {},
    commitMessage: {},
    head: {},
    repositoryId: {},
  },
}

const MergePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MergePullRequestInput',
  fcs: ['expectedHeadOid'],
  f: {
    authorEmail: {},
    clientMutationId: {},
    commitBody: {},
    commitHeadline: {},
    expectedHeadOid: {
      nt: GitObjectID,
    },
    mergeMethod: {},
    pullRequestId: {},
  },
}

const MergeQueueParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MergeQueueParametersInput',
  f: {
    checkResponseTimeoutMinutes: {},
    groupingStrategy: {},
    maxEntriesToBuild: {},
    maxEntriesToMerge: {},
    mergeMethod: {},
    minEntriesToMerge: {},
    minEntriesToMergeWaitMinutes: {},
  },
}

const MilestoneOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MilestoneOrder',
  f: {
    direction: {},
    field: {},
  },
}

const MinimizeCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MinimizeCommentInput',
  f: {
    classifier: {},
    clientMutationId: {},
    subjectId: {},
  },
}

const MoveProjectCardInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MoveProjectCardInput',
  f: {
    afterCardId: {},
    cardId: {},
    clientMutationId: {},
    columnId: {},
  },
}

const MoveProjectColumnInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'MoveProjectColumnInput',
  f: {
    afterColumnId: {},
    clientMutationId: {},
    columnId: {},
  },
}

const OrgEnterpriseOwnerOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'OrgEnterpriseOwnerOrder',
  f: {
    direction: {},
    field: {},
  },
}

const OrganizationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'OrganizationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PackageFileOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PackageFileOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PackageOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PackageOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PackageVersionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PackageVersionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PinEnvironmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PinEnvironmentInput',
  f: {
    clientMutationId: {},
    environmentId: {},
    pinned: {},
  },
}

const PinIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PinIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
  },
}

const PinnedEnvironmentOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PinnedEnvironmentOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectCardImport: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectCardImport',
  f: {
    number: {},
    repository: {},
  },
}

const ProjectColumnImport: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectColumnImport',
  f: {
    columnName: {},
    issues: {},
    position: {},
  },
}

const ProjectOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2Collaborator: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2Collaborator',
  f: {
    role: {},
    teamId: {},
    userId: {},
  },
}

const ProjectV2FieldOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2FieldOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2FieldValue: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2FieldValue',
  fcs: ['date'],
  f: {
    date: {
      nt: Date,
    },
    iterationId: {},
    number: {},
    singleSelectOptionId: {},
    text: {},
  },
}

const ProjectV2Filters: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2Filters',
  f: {
    state: {},
  },
}

const ProjectV2ItemFieldValueOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2ItemFieldValueOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2ItemOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2ItemOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2Order: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2Order',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2SingleSelectFieldOptionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2SingleSelectFieldOptionInput',
  f: {
    color: {},
    description: {},
    name: {},
  },
}

const ProjectV2StatusOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2StatusOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2ViewOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2ViewOrder',
  f: {
    direction: {},
    field: {},
  },
}

const ProjectV2WorkflowOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ProjectV2WorkflowOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PropertyTargetDefinitionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PropertyTargetDefinitionInput',
  f: {
    name: {},
    propertyValues: {},
    source: {},
  },
}

const PublishSponsorsTierInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PublishSponsorsTierInput',
  f: {
    clientMutationId: {},
    tierId: {},
  },
}

const PullRequestOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PullRequestOrder',
  f: {
    direction: {},
    field: {},
  },
}

const PullRequestParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'PullRequestParametersInput',
  f: {
    allowedMergeMethods: {},
    dismissStaleReviewsOnPush: {},
    requireCodeOwnerReview: {},
    requireLastPushApproval: {},
    requiredApprovingReviewCount: {},
    requiredReviewThreadResolution: {},
  },
}

const ReactionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReactionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RefNameConditionTargetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RefNameConditionTargetInput',
  f: {
    exclude: {},
    include: {},
  },
}

const RefOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RefOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RefUpdate: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RefUpdate',
  fcs: ['afterOid', 'beforeOid', 'name'],
  f: {
    afterOid: {
      nt: GitObjectID,
    },
    beforeOid: {
      nt: GitObjectID,
    },
    force: {},
    name: {
      nt: GitRefname,
    },
  },
}

const RegenerateEnterpriseIdentityProviderRecoveryCodesInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RegenerateEnterpriseIdentityProviderRecoveryCodesInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
  },
}

const RegenerateVerifiableDomainTokenInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RegenerateVerifiableDomainTokenInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const RejectDeploymentsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RejectDeploymentsInput',
  f: {
    clientMutationId: {},
    comment: {},
    environmentIds: {},
    workflowRunId: {},
  },
}

const ReleaseOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReleaseOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RemoveAssigneesFromAssignableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveAssigneesFromAssignableInput',
  f: {
    assignableId: {},
    assigneeIds: {},
    clientMutationId: {},
  },
}

const RemoveEnterpriseAdminInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveEnterpriseAdminInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
  },
}

const RemoveEnterpriseIdentityProviderInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveEnterpriseIdentityProviderInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
  },
}

const RemoveEnterpriseMemberInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveEnterpriseMemberInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    userId: {},
  },
}

const RemoveEnterpriseOrganizationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveEnterpriseOrganizationInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    organizationId: {},
  },
}

const RemoveEnterpriseSupportEntitlementInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveEnterpriseSupportEntitlementInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
  },
}

const RemoveLabelsFromLabelableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveLabelsFromLabelableInput',
  f: {
    clientMutationId: {},
    labelIds: {},
    labelableId: {},
  },
}

const RemoveOutsideCollaboratorInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveOutsideCollaboratorInput',
  f: {
    clientMutationId: {},
    organizationId: {},
    userId: {},
  },
}

const RemoveReactionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveReactionInput',
  f: {
    clientMutationId: {},
    content: {},
    subjectId: {},
  },
}

const RemoveStarInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveStarInput',
  f: {
    clientMutationId: {},
    starrableId: {},
  },
}

const RemoveSubIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveSubIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
    subIssueId: {},
  },
}

const RemoveUpvoteInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RemoveUpvoteInput',
  f: {
    clientMutationId: {},
    subjectId: {},
  },
}

const ReopenDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReopenDiscussionInput',
  f: {
    clientMutationId: {},
    discussionId: {},
  },
}

const ReopenIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReopenIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
  },
}

const ReopenPullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReopenPullRequestInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
  },
}

const ReorderEnvironmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReorderEnvironmentInput',
  f: {
    clientMutationId: {},
    environmentId: {},
    position: {},
  },
}

const RepositoryIdConditionTargetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryIdConditionTargetInput',
  f: {
    repositoryIds: {},
  },
}

const RepositoryInvitationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryInvitationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RepositoryMigrationOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryMigrationOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RepositoryNameConditionTargetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryNameConditionTargetInput',
  f: {
    exclude: {},
    include: {},
    protected: {},
  },
}

const RepositoryOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RepositoryPropertyConditionTargetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryPropertyConditionTargetInput',
  f: {
    exclude: {},
    include: {},
  },
}

const RepositoryRuleConditionsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryRuleConditionsInput',
  f: {
    refName: {},
    repositoryId: {},
    repositoryName: {},
    repositoryProperty: {},
  },
}

const RepositoryRuleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryRuleInput',
  f: {
    id: {},
    parameters: {},
    type: {},
  },
}

const RepositoryRuleOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryRuleOrder',
  f: {
    direction: {},
    field: {},
  },
}

const RepositoryRulesetBypassActorInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RepositoryRulesetBypassActorInput',
  f: {
    actorId: {},
    bypassMode: {},
    deployKey: {},
    enterpriseOwner: {},
    organizationAdmin: {},
    repositoryRoleDatabaseId: {},
  },
}

const ReprioritizeSubIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ReprioritizeSubIssueInput',
  f: {
    afterId: {},
    beforeId: {},
    clientMutationId: {},
    issueId: {},
    subIssueId: {},
  },
}

const RequestReviewsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RequestReviewsInput',
  f: {
    clientMutationId: {},
    pullRequestId: {},
    teamIds: {},
    union: {},
    userIds: {},
  },
}

const RequiredDeploymentsParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RequiredDeploymentsParametersInput',
  f: {
    requiredDeploymentEnvironments: {},
  },
}

const RequiredStatusCheckInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RequiredStatusCheckInput',
  f: {
    appId: {},
    context: {},
  },
}

const RequiredStatusChecksParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RequiredStatusChecksParametersInput',
  f: {
    doNotEnforceOnCreate: {},
    requiredStatusChecks: {},
    strictRequiredStatusChecksPolicy: {},
  },
}

const RerequestCheckSuiteInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RerequestCheckSuiteInput',
  f: {
    checkSuiteId: {},
    clientMutationId: {},
    repositoryId: {},
  },
}

const ResolveReviewThreadInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'ResolveReviewThreadInput',
  f: {
    clientMutationId: {},
    threadId: {},
  },
}

const RetireSponsorsTierInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RetireSponsorsTierInput',
  f: {
    clientMutationId: {},
    tierId: {},
  },
}

const RevertPullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RevertPullRequestInput',
  f: {
    body: {},
    clientMutationId: {},
    draft: {},
    pullRequestId: {},
    title: {},
  },
}

const RevokeEnterpriseOrganizationsMigratorRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RevokeEnterpriseOrganizationsMigratorRoleInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
  },
}

const RevokeMigratorRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RevokeMigratorRoleInput',
  f: {
    actor: {},
    actorType: {},
    clientMutationId: {},
    organizationId: {},
  },
}

const RuleParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'RuleParametersInput',
  f: {
    branchNamePattern: {},
    codeScanning: {},
    commitAuthorEmailPattern: {},
    commitMessagePattern: {},
    committerEmailPattern: {},
    fileExtensionRestriction: {},
    filePathRestriction: {},
    maxFilePathLength: {},
    maxFileSize: {},
    mergeQueue: {},
    pullRequest: {},
    requiredDeployments: {},
    requiredStatusChecks: {},
    tagNamePattern: {},
    update: {},
    workflows: {},
  },
}

const SavedReplyOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SavedReplyOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SecurityAdvisoryIdentifierFilter: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SecurityAdvisoryIdentifierFilter',
  f: {
    type: {},
    value: {},
  },
}

const SecurityAdvisoryOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SecurityAdvisoryOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SecurityVulnerabilityOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SecurityVulnerabilityOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SetEnterpriseIdentityProviderInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SetEnterpriseIdentityProviderInput',
  fcs: ['ssoUrl'],
  f: {
    clientMutationId: {},
    digestMethod: {},
    enterpriseId: {},
    idpCertificate: {},
    issuer: {},
    signatureMethod: {},
    ssoUrl: {
      nt: URI,
    },
  },
}

const SetOrganizationInteractionLimitInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SetOrganizationInteractionLimitInput',
  f: {
    clientMutationId: {},
    expiry: {},
    limit: {},
    organizationId: {},
  },
}

const SetRepositoryInteractionLimitInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SetRepositoryInteractionLimitInput',
  f: {
    clientMutationId: {},
    expiry: {},
    limit: {},
    repositoryId: {},
  },
}

const SetUserInteractionLimitInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SetUserInteractionLimitInput',
  f: {
    clientMutationId: {},
    expiry: {},
    limit: {},
    userId: {},
  },
}

const SponsorAndLifetimeValueOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorAndLifetimeValueOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorableOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorableOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorsActivityOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorsActivityOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorsTierOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorsTierOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorshipNewsletterOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorshipNewsletterOrder',
  f: {
    direction: {},
    field: {},
  },
}

const SponsorshipOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SponsorshipOrder',
  f: {
    direction: {},
    field: {},
  },
}

const StarOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'StarOrder',
  f: {
    direction: {},
    field: {},
  },
}

const StartOrganizationMigrationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'StartOrganizationMigrationInput',
  fcs: ['sourceOrgUrl'],
  f: {
    clientMutationId: {},
    sourceAccessToken: {},
    sourceOrgUrl: {
      nt: URI,
    },
    targetEnterpriseId: {},
    targetOrgName: {},
  },
}

const StartRepositoryMigrationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'StartRepositoryMigrationInput',
  fcs: ['sourceRepositoryUrl'],
  f: {
    accessToken: {},
    clientMutationId: {},
    continueOnError: {},
    gitArchiveUrl: {},
    githubPat: {},
    lockSource: {},
    metadataArchiveUrl: {},
    ownerId: {},
    repositoryName: {},
    skipReleases: {},
    sourceId: {},
    sourceRepositoryUrl: {
      nt: URI,
    },
    targetRepoVisibility: {},
  },
}

const StatusCheckConfigurationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'StatusCheckConfigurationInput',
  f: {
    context: {},
    integrationId: {},
  },
}

const SubmitPullRequestReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'SubmitPullRequestReviewInput',
  f: {
    body: {},
    clientMutationId: {},
    event: {},
    pullRequestId: {},
    pullRequestReviewId: {},
  },
}

const TagNamePatternParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TagNamePatternParametersInput',
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const TeamDiscussionCommentOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TeamDiscussionCommentOrder',
  f: {
    direction: {},
    field: {},
  },
}

const TeamDiscussionOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TeamDiscussionOrder',
  f: {
    direction: {},
    field: {},
  },
}

const TeamMemberOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TeamMemberOrder',
  f: {
    direction: {},
    field: {},
  },
}

const TeamOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TeamOrder',
  f: {
    direction: {},
    field: {},
  },
}

const TeamRepositoryOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TeamRepositoryOrder',
  f: {
    direction: {},
    field: {},
  },
}

const TransferEnterpriseOrganizationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TransferEnterpriseOrganizationInput',
  f: {
    clientMutationId: {},
    destinationEnterpriseId: {},
    organizationId: {},
  },
}

const TransferIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'TransferIssueInput',
  f: {
    clientMutationId: {},
    createLabelsIfMissing: {},
    issueId: {},
    repositoryId: {},
  },
}

const UnarchiveProjectV2ItemInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnarchiveProjectV2ItemInput',
  f: {
    clientMutationId: {},
    itemId: {},
    projectId: {},
  },
}

const UnarchiveRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnarchiveRepositoryInput',
  f: {
    clientMutationId: {},
    repositoryId: {},
  },
}

const UnfollowOrganizationInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnfollowOrganizationInput',
  f: {
    clientMutationId: {},
    organizationId: {},
  },
}

const UnfollowUserInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnfollowUserInput',
  f: {
    clientMutationId: {},
    userId: {},
  },
}

const UnlinkProjectV2FromRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnlinkProjectV2FromRepositoryInput',
  f: {
    clientMutationId: {},
    projectId: {},
    repositoryId: {},
  },
}

const UnlinkProjectV2FromTeamInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnlinkProjectV2FromTeamInput',
  f: {
    clientMutationId: {},
    projectId: {},
    teamId: {},
  },
}

const UnlinkRepositoryFromProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnlinkRepositoryFromProjectInput',
  f: {
    clientMutationId: {},
    projectId: {},
    repositoryId: {},
  },
}

const UnlockLockableInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnlockLockableInput',
  f: {
    clientMutationId: {},
    lockableId: {},
  },
}

const UnmarkDiscussionCommentAsAnswerInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnmarkDiscussionCommentAsAnswerInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const UnmarkFileAsViewedInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnmarkFileAsViewedInput',
  f: {
    clientMutationId: {},
    path: {},
    pullRequestId: {},
  },
}

const UnmarkIssueAsDuplicateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnmarkIssueAsDuplicateInput',
  f: {
    canonicalId: {},
    clientMutationId: {},
    duplicateId: {},
  },
}

const UnmarkProjectV2AsTemplateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnmarkProjectV2AsTemplateInput',
  f: {
    clientMutationId: {},
    projectId: {},
  },
}

const UnminimizeCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnminimizeCommentInput',
  f: {
    clientMutationId: {},
    subjectId: {},
  },
}

const UnpinIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnpinIssueInput',
  f: {
    clientMutationId: {},
    issueId: {},
  },
}

const UnresolveReviewThreadInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UnresolveReviewThreadInput',
  f: {
    clientMutationId: {},
    threadId: {},
  },
}

const UpdateBranchProtectionRuleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateBranchProtectionRuleInput',
  f: {
    allowsDeletions: {},
    allowsForcePushes: {},
    blocksCreations: {},
    branchProtectionRuleId: {},
    bypassForcePushActorIds: {},
    bypassPullRequestActorIds: {},
    clientMutationId: {},
    dismissesStaleReviews: {},
    isAdminEnforced: {},
    lockAllowsFetchAndMerge: {},
    lockBranch: {},
    pattern: {},
    pushActorIds: {},
    requireLastPushApproval: {},
    requiredApprovingReviewCount: {},
    requiredDeploymentEnvironments: {},
    requiredStatusCheckContexts: {},
    requiredStatusChecks: {},
    requiresApprovingReviews: {},
    requiresCodeOwnerReviews: {},
    requiresCommitSignatures: {},
    requiresConversationResolution: {},
    requiresDeployments: {},
    requiresLinearHistory: {},
    requiresStatusChecks: {},
    requiresStrictStatusChecks: {},
    restrictsPushes: {},
    restrictsReviewDismissals: {},
    reviewDismissalActorIds: {},
  },
}

const UpdateCheckRunInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateCheckRunInput',
  fcs: ['completedAt', 'detailsUrl', 'output', 'startedAt'],
  f: {
    actions: {},
    checkRunId: {},
    clientMutationId: {},
    completedAt: {
      nt: DateTime,
    },
    conclusion: {},
    detailsUrl: {
      nt: URI,
    },
    externalId: {},
    name: {},
    output: {
      // nt: CheckRunOutput, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryId: {},
    startedAt: {
      nt: DateTime,
    },
    status: {},
  },
}

const UpdateCheckSuitePreferencesInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateCheckSuitePreferencesInput',
  f: {
    autoTriggerPreferences: {},
    clientMutationId: {},
    repositoryId: {},
  },
}

const UpdateDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateDiscussionCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    commentId: {},
  },
}

const UpdateDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateDiscussionInput',
  f: {
    body: {},
    categoryId: {},
    clientMutationId: {},
    discussionId: {},
    title: {},
  },
}

const UpdateEnterpriseAdministratorRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseAdministratorRoleInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    login: {},
    role: {},
  },
}

const UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    policyValue: {},
    settingValue: {},
  },
}

const UpdateEnterpriseDefaultRepositoryPermissionSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseDefaultRepositoryPermissionSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseDeployKeySettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseDeployKeySettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanCreateRepositoriesSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanCreateRepositoriesSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    membersCanCreateInternalRepositories: {},
    membersCanCreatePrivateRepositories: {},
    membersCanCreatePublicRepositories: {},
    membersCanCreateRepositoriesPolicyEnabled: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanDeleteIssuesSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanDeleteIssuesSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanMakePurchasesSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanMakePurchasesSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseOrganizationProjectsSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseOrganizationProjectsSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseOwnerOrganizationRoleInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseOwnerOrganizationRoleInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    organizationId: {},
    organizationRole: {},
  },
}

const UpdateEnterpriseProfileInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseProfileInput',
  f: {
    clientMutationId: {},
    description: {},
    enterpriseId: {},
    location: {},
    name: {},
    websiteUrl: {},
  },
}

const UpdateEnterpriseRepositoryProjectsSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseRepositoryProjectsSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseTeamDiscussionsSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseTeamDiscussionsSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput:
  $$Utilities.SchemaDrivenDataMap.InputObject = {
    n: 'UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput',
    f: {
      clientMutationId: {},
      enterpriseId: {},
      settingValue: {},
    },
  }

const UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput',
  f: {
    clientMutationId: {},
    enterpriseId: {},
    settingValue: {},
  },
}

const UpdateEnvironmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateEnvironmentInput',
  f: {
    clientMutationId: {},
    environmentId: {},
    preventSelfReview: {},
    reviewers: {},
    waitTimer: {},
  },
}

const UpdateIpAllowListEnabledSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateIpAllowListEnabledSettingInput',
  f: {
    clientMutationId: {},
    ownerId: {},
    settingValue: {},
  },
}

const UpdateIpAllowListEntryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateIpAllowListEntryInput',
  f: {
    allowListValue: {},
    clientMutationId: {},
    ipAllowListEntryId: {},
    isActive: {},
    name: {},
  },
}

const UpdateIpAllowListForInstalledAppsEnabledSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateIpAllowListForInstalledAppsEnabledSettingInput',
  f: {
    clientMutationId: {},
    ownerId: {},
    settingValue: {},
  },
}

const UpdateIssueCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateIssueCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    id: {},
  },
}

const UpdateIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateIssueInput',
  f: {
    assigneeIds: {},
    body: {},
    clientMutationId: {},
    id: {},
    labelIds: {},
    milestoneId: {},
    projectIds: {},
    state: {},
    title: {},
  },
}

const UpdateLabelInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateLabelInput',
  f: {
    clientMutationId: {},
    color: {},
    description: {},
    id: {},
    name: {},
  },
}

const UpdateNotificationRestrictionSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateNotificationRestrictionSettingInput',
  f: {
    clientMutationId: {},
    ownerId: {},
    settingValue: {},
  },
}

const UpdateOrganizationAllowPrivateRepositoryForkingSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateOrganizationAllowPrivateRepositoryForkingSettingInput',
  f: {
    clientMutationId: {},
    forkingEnabled: {},
    organizationId: {},
  },
}

const UpdateOrganizationWebCommitSignoffSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateOrganizationWebCommitSignoffSettingInput',
  f: {
    clientMutationId: {},
    organizationId: {},
    webCommitSignoffRequired: {},
  },
}

const UpdateParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateParametersInput',
  f: {
    updateAllowsFetchAndMerge: {},
  },
}

const UpdatePatreonSponsorabilityInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdatePatreonSponsorabilityInput',
  f: {
    clientMutationId: {},
    enablePatreonSponsorships: {},
    sponsorableLogin: {},
  },
}

const UpdateProjectCardInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectCardInput',
  f: {
    clientMutationId: {},
    isArchived: {},
    note: {},
    projectCardId: {},
  },
}

const UpdateProjectColumnInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectColumnInput',
  f: {
    clientMutationId: {},
    name: {},
    projectColumnId: {},
  },
}

const UpdateProjectInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectInput',
  f: {
    body: {},
    clientMutationId: {},
    name: {},
    projectId: {},
    public: {},
    state: {},
  },
}

const UpdateProjectV2CollaboratorsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2CollaboratorsInput',
  f: {
    clientMutationId: {},
    collaborators: {},
    projectId: {},
  },
}

const UpdateProjectV2DraftIssueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2DraftIssueInput',
  f: {
    assigneeIds: {},
    body: {},
    clientMutationId: {},
    draftIssueId: {},
    title: {},
  },
}

const UpdateProjectV2FieldInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2FieldInput',
  f: {
    clientMutationId: {},
    fieldId: {},
    name: {},
    singleSelectOptions: {},
  },
}

const UpdateProjectV2Input: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2Input',
  f: {
    clientMutationId: {},
    closed: {},
    projectId: {},
    public: {},
    readme: {},
    shortDescription: {},
    title: {},
  },
}

const UpdateProjectV2ItemFieldValueInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2ItemFieldValueInput',
  fcs: ['value'],
  f: {
    clientMutationId: {},
    fieldId: {},
    itemId: {},
    projectId: {},
    value: {
      // nt: ProjectV2FieldValue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2ItemPositionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2ItemPositionInput',
  f: {
    afterId: {},
    clientMutationId: {},
    itemId: {},
    projectId: {},
  },
}

const UpdateProjectV2StatusUpdateInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateProjectV2StatusUpdateInput',
  fcs: ['startDate', 'targetDate'],
  f: {
    body: {},
    clientMutationId: {},
    startDate: {
      nt: Date,
    },
    status: {},
    statusUpdateId: {},
    targetDate: {
      nt: Date,
    },
  },
}

const UpdatePullRequestBranchInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdatePullRequestBranchInput',
  fcs: ['expectedHeadOid'],
  f: {
    clientMutationId: {},
    expectedHeadOid: {
      nt: GitObjectID,
    },
    pullRequestId: {},
    updateMethod: {},
  },
}

const UpdatePullRequestInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdatePullRequestInput',
  f: {
    assigneeIds: {},
    baseRefName: {},
    body: {},
    clientMutationId: {},
    labelIds: {},
    maintainerCanModify: {},
    milestoneId: {},
    projectIds: {},
    pullRequestId: {},
    state: {},
    title: {},
  },
}

const UpdatePullRequestReviewCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdatePullRequestReviewCommentInput',
  f: {
    body: {},
    clientMutationId: {},
    pullRequestReviewCommentId: {},
  },
}

const UpdatePullRequestReviewInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdatePullRequestReviewInput',
  f: {
    body: {},
    clientMutationId: {},
    pullRequestReviewId: {},
  },
}

const UpdateRefInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateRefInput',
  fcs: ['oid'],
  f: {
    clientMutationId: {},
    force: {},
    oid: {
      nt: GitObjectID,
    },
    refId: {},
  },
}

const UpdateRefsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateRefsInput',
  fcs: ['refUpdates'],
  f: {
    clientMutationId: {},
    refUpdates: {
      // nt: RefUpdate, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryId: {},
  },
}

const UpdateRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateRepositoryInput',
  fcs: ['homepageUrl'],
  f: {
    clientMutationId: {},
    description: {},
    hasDiscussionsEnabled: {},
    hasIssuesEnabled: {},
    hasProjectsEnabled: {},
    hasSponsorshipsEnabled: {},
    hasWikiEnabled: {},
    homepageUrl: {
      nt: URI,
    },
    name: {},
    repositoryId: {},
    template: {},
  },
}

const UpdateRepositoryRulesetInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateRepositoryRulesetInput',
  f: {
    bypassActors: {},
    clientMutationId: {},
    conditions: {},
    enforcement: {},
    name: {},
    repositoryRulesetId: {},
    rules: {},
    target: {},
  },
}

const UpdateRepositoryWebCommitSignoffSettingInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateRepositoryWebCommitSignoffSettingInput',
  f: {
    clientMutationId: {},
    repositoryId: {},
    webCommitSignoffRequired: {},
  },
}

const UpdateSponsorshipPreferencesInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateSponsorshipPreferencesInput',
  f: {
    clientMutationId: {},
    privacyLevel: {},
    receiveEmails: {},
    sponsorId: {},
    sponsorLogin: {},
    sponsorableId: {},
    sponsorableLogin: {},
  },
}

const UpdateSubscriptionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateSubscriptionInput',
  f: {
    clientMutationId: {},
    state: {},
    subscribableId: {},
  },
}

const UpdateTeamDiscussionCommentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateTeamDiscussionCommentInput',
  f: {
    body: {},
    bodyVersion: {},
    clientMutationId: {},
    id: {},
  },
}

const UpdateTeamDiscussionInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateTeamDiscussionInput',
  f: {
    body: {},
    bodyVersion: {},
    clientMutationId: {},
    id: {},
    pinned: {},
    title: {},
  },
}

const UpdateTeamReviewAssignmentInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateTeamReviewAssignmentInput',
  f: {
    algorithm: {},
    clientMutationId: {},
    countMembersAlreadyRequested: {},
    enabled: {},
    excludedTeamMemberIds: {},
    id: {},
    includeChildTeamMembers: {},
    notifyTeam: {},
    removeTeamRequest: {},
    teamMemberCount: {},
  },
}

const UpdateTeamsRepositoryInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateTeamsRepositoryInput',
  f: {
    clientMutationId: {},
    permission: {},
    repositoryId: {},
    teamIds: {},
  },
}

const UpdateTopicsInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateTopicsInput',
  f: {
    clientMutationId: {},
    repositoryId: {},
    topicNames: {},
  },
}

const UpdateUserListInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateUserListInput',
  f: {
    clientMutationId: {},
    description: {},
    isPrivate: {},
    listId: {},
    name: {},
  },
}

const UpdateUserListsForItemInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UpdateUserListsForItemInput',
  f: {
    clientMutationId: {},
    itemId: {},
    listIds: {},
    suggestedListIds: {},
  },
}

const UserStatusOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'UserStatusOrder',
  f: {
    direction: {},
    field: {},
  },
}

const VerifiableDomainOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'VerifiableDomainOrder',
  f: {
    direction: {},
    field: {},
  },
}

const VerifyVerifiableDomainInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'VerifyVerifiableDomainInput',
  f: {
    clientMutationId: {},
    id: {},
  },
}

const WorkflowFileReferenceInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'WorkflowFileReferenceInput',
  f: {
    path: {},
    ref: {},
    repositoryId: {},
    sha: {},
  },
}

const WorkflowRunOrder: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'WorkflowRunOrder',
  f: {
    direction: {},
    field: {},
  },
}

const WorkflowsParametersInput: $$Utilities.SchemaDrivenDataMap.InputObject = {
  n: 'WorkflowsParametersInput',
  f: {
    doNotEnforceOnCreate: {},
    workflows: {},
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                            OutputObject
// ==================================================================================================
//
//
//
//
//
//

const AbortQueuedMigrationsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    success: {},
  },
}

const AbortRepositoryMigrationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    success: {},
  },
}

const AcceptEnterpriseAdministratorInvitationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const AcceptEnterpriseMemberInvitationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const AcceptTopicSuggestionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    topic: {
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AccessUserNamespaceRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    expiresAt: {
      nt: DateTime,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ActorLocation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    city: {},
    country: {},
    countryCode: {},
    region: {},
    regionCode: {},
  },
}

const AddAssigneesToAssignablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    assignable: {
      // nt: Assignable, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const AddCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    commentEdge: {
      // nt: IssueCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: Node, <-- Assigned later to avoid potential circular dependency.
    },
    timelineEdge: {
      // nt: IssueTimelineItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    comment: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddDiscussionPollVotePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pollOption: {
      // nt: DiscussionPollOption, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddEnterpriseOrganizationMemberPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    users: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddEnterpriseSupportEntitlementPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
  },
}

const AddLabelsToLabelablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    labelable: {
      // nt: Labelable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddProjectCardPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cardEdge: {
      // nt: ProjectCardEdge, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    projectColumn: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddProjectColumnPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    columnEdge: {
      // nt: ProjectColumnEdge, <-- Assigned later to avoid potential circular dependency.
    },
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddProjectV2DraftIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectItem: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddProjectV2ItemByIdPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddPullRequestReviewCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    comment: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
    commentEdge: {
      // nt: PullRequestReviewCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddPullRequestReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    reviewEdge: {
      // nt: PullRequestReviewEdge, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddPullRequestReviewThreadPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    thread: {
      // nt: PullRequestReviewThread, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddPullRequestReviewThreadReplyPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    comment: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddReactionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    reaction: {
      // nt: Reaction, <-- Assigned later to avoid potential circular dependency.
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: Reactable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddStarPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    starrable: {
      // nt: Starrable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddSubIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    subIssue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddUpvotePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    subject: {
      // nt: Votable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddVerifiableDomainPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    domain: {
      // nt: VerifiableDomain, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddedToMergeQueueEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    enqueuer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    mergeQueue: {
      // nt: MergeQueue, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AddedToProjectEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectCard: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
    projectColumnName: {},
  },
}

const AnnouncementBanner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    expiresAt: {
      nt: DateTime,
    },
    isUserDismissible: {},
    message: {},
  },
}

const App: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientId: {},
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    description: {},
    id: {},
    ipAllowListEntries: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IpAllowListEntryOrder,
          it: [0],
        },
      },
      // nt: IpAllowListEntryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    logoBackgroundColor: {},
    logoUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    name: {},
    slug: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const ApproveDeploymentsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deployments: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ApproveVerifiableDomainPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    domain: {
      // nt: VerifiableDomain, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ArchiveProjectV2ItemPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ArchiveRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AssignedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    assignable: {
      // nt: Assignable, <-- Assigned later to avoid potential circular dependency.
    },
    assignee: {
      // nt: Assignee, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutoMergeDisabledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    disabler: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    reason: {},
    reasonCode: {},
  },
}

const AutoMergeEnabledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    enabler: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutoMergeRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    authorEmail: {},
    commitBody: {},
    commitHeadline: {},
    enabledAt: {
      nt: DateTime,
    },
    enabledBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    mergeMethod: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutoRebaseEnabledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    enabler: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutoSquashEnabledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    enabler: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutomaticBaseChangeFailedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    newBase: {},
    oldBase: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const AutomaticBaseChangeSucceededEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    newBase: {},
    oldBase: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BaseRefChangedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    currentRefName: {},
    databaseId: {},
    id: {},
    previousRefName: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BaseRefDeletedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    baseRefName: {},
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BaseRefForcePushedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    afterCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    beforeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Blame: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ranges: {
      // nt: BlameRange, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BlameRange: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    age: {},
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    endingLine: {},
    startingLine: {},
  },
}

const Blob: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    abbreviatedOid: {},
    byteSize: {},
    commitResourcePath: {
      nt: URI,
    },
    commitUrl: {
      nt: URI,
    },
    id: {},
    isBinary: {},
    isTruncated: {},
    oid: {
      nt: GitObjectID,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    text: {},
  },
}

const Bot: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    login: {},
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const BranchNamePatternParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const BranchProtectionRule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allowsDeletions: {},
    allowsForcePushes: {},
    blocksCreations: {},
    branchProtectionRuleConflicts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: BranchProtectionRuleConflictConnection, <-- Assigned later to avoid potential circular dependency.
    },
    bypassForcePushAllowances: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: BypassForcePushAllowanceConnection, <-- Assigned later to avoid potential circular dependency.
    },
    bypassPullRequestAllowances: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: BypassPullRequestAllowanceConnection, <-- Assigned later to avoid potential circular dependency.
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    dismissesStaleReviews: {},
    id: {},
    isAdminEnforced: {},
    lockAllowsFetchAndMerge: {},
    lockBranch: {},
    matchingRefs: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: RefConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pattern: {},
    pushAllowances: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PushAllowanceConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    requireLastPushApproval: {},
    requiredApprovingReviewCount: {},
    requiredDeploymentEnvironments: {},
    requiredStatusCheckContexts: {},
    requiredStatusChecks: {
      // nt: RequiredStatusCheckDescription, <-- Assigned later to avoid potential circular dependency.
    },
    requiresApprovingReviews: {},
    requiresCodeOwnerReviews: {},
    requiresCommitSignatures: {},
    requiresConversationResolution: {},
    requiresDeployments: {},
    requiresLinearHistory: {},
    requiresStatusChecks: {},
    requiresStrictStatusChecks: {},
    restrictsPushes: {},
    restrictsReviewDismissals: {},
    reviewDismissalAllowances: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ReviewDismissalAllowanceConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BranchProtectionRuleConflict: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    conflictingBranchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BranchProtectionRuleConflictConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: BranchProtectionRuleConflictEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: BranchProtectionRuleConflict, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const BranchProtectionRuleConflictEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: BranchProtectionRuleConflict, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BranchProtectionRuleConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: BranchProtectionRuleEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const BranchProtectionRuleEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BypassForcePushAllowance: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: BranchActorAllowanceActor, <-- Assigned later to avoid potential circular dependency.
    },
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const BypassForcePushAllowanceConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: BypassForcePushAllowanceEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: BypassForcePushAllowance, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const BypassForcePushAllowanceEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: BypassForcePushAllowance, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const BypassPullRequestAllowance: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: BranchActorAllowanceActor, <-- Assigned later to avoid potential circular dependency.
    },
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const BypassPullRequestAllowanceConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: BypassPullRequestAllowanceEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: BypassPullRequestAllowance, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const BypassPullRequestAllowanceEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: BypassPullRequestAllowance, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CVSS: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    score: {},
    vectorString: {},
  },
}

const CWE: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cweId: {},
    description: {},
    id: {},
    name: {},
  },
}

const CWEConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CWEEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CWE, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CWEEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CWE, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CancelEnterpriseAdminInvitationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const CancelEnterpriseMemberInvitationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const CancelSponsorshipPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ChangeUserStatusPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    status: {
      // nt: UserStatus, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckAnnotation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    annotationLevel: {},
    blobUrl: {
      nt: URI,
    },
    databaseId: {},
    location: {
      // nt: CheckAnnotationSpan, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
    path: {},
    rawDetails: {},
    title: {},
  },
}

const CheckAnnotationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CheckAnnotationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CheckAnnotation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CheckAnnotationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CheckAnnotation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckAnnotationPosition: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    column: {},
    line: {},
  },
}

const CheckAnnotationSpan: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    end: {
      // nt: CheckAnnotationPosition, <-- Assigned later to avoid potential circular dependency.
    },
    start: {
      // nt: CheckAnnotationPosition, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckRun: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    annotations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CheckAnnotationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    checkSuite: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
    completedAt: {
      nt: DateTime,
    },
    conclusion: {},
    databaseId: {},
    deployment: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
    detailsUrl: {
      nt: URI,
    },
    externalId: {},
    id: {},
    isRequired: {
      a: {
        pullRequestId: {
          nt: ID,
          it: [0],
        },
        pullRequestNumber: {
          nt: Int,
          it: [0],
        },
      },
    },
    name: {},
    pendingDeploymentRequest: {
      // nt: DeploymentRequest, <-- Assigned later to avoid potential circular dependency.
    },
    permalink: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    startedAt: {
      nt: DateTime,
    },
    status: {},
    steps: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        number: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CheckStepConnection, <-- Assigned later to avoid potential circular dependency.
    },
    summary: {},
    text: {},
    title: {},
    url: {
      nt: URI,
    },
  },
}

const CheckRunConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CheckRunEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CheckRun, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CheckRunEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CheckRun, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckRunStateCount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    count: {},
    state: {},
  },
}

const CheckStep: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    completedAt: {
      nt: DateTime,
    },
    conclusion: {},
    externalId: {},
    name: {},
    number: {},
    secondsToCompletion: {},
    startedAt: {
      nt: DateTime,
    },
    status: {},
  },
}

const CheckStepConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CheckStepEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CheckStep, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CheckStepEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CheckStep, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckSuite: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    app: {
      // nt: App, <-- Assigned later to avoid potential circular dependency.
    },
    branch: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    checkRuns: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: CheckRunFilter,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CheckRunConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    conclusion: {},
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    id: {},
    matchingPullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    push: {
      // nt: Push, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    status: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    workflowRun: {
      // nt: WorkflowRun, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CheckSuiteConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CheckSuiteEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CheckSuiteEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ClearLabelsFromLabelablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    labelable: {
      // nt: Labelable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ClearProjectV2ItemFieldValuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2Item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CloneProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    jobStatusId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CloneTemplateRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CloseDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CloseIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ClosePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ClosedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    closable: {
      // nt: Closable, <-- Assigned later to avoid potential circular dependency.
    },
    closer: {
      // nt: Closer, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    resourcePath: {
      nt: URI,
    },
    stateReason: {},
    url: {
      nt: URI,
    },
  },
}

const CodeOfConduct: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    id: {},
    key: {},
    name: {},
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const CodeScanningParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    codeScanningTools: {
      // nt: CodeScanningTool, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CodeScanningTool: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    alertsThreshold: {},
    securityAlertsThreshold: {},
    tool: {},
  },
}

const CommentDeletedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    deletedCommentAuthor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const Commit: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    abbreviatedOid: {},
    additions: {},
    associatedPullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: PullRequestOrder,
          it: [0],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    author: {
      // nt: GitActor, <-- Assigned later to avoid potential circular dependency.
    },
    authoredByCommitter: {},
    authoredDate: {
      nt: DateTime,
    },
    authors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: GitActorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    blame: {
      a: {
        path: {
          nt: String,
          it: [1],
        },
      },
      // nt: Blame, <-- Assigned later to avoid potential circular dependency.
    },
    changedFiles: {},
    changedFilesIfAvailable: {},
    checkSuites: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: CheckSuiteFilter,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CheckSuiteConnection, <-- Assigned later to avoid potential circular dependency.
    },
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commitResourcePath: {
      nt: URI,
    },
    commitUrl: {
      nt: URI,
    },
    committedDate: {
      nt: DateTime,
    },
    committedViaWeb: {},
    committer: {
      // nt: GitActor, <-- Assigned later to avoid potential circular dependency.
    },
    deletions: {},
    deployments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        environments: {
          nt: String,
          it: [0, [1]],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DeploymentOrder,
          it: [0],
        },
      },
      // nt: DeploymentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    file: {
      a: {
        path: {
          nt: String,
          it: [1],
        },
      },
      // nt: TreeEntry, <-- Assigned later to avoid potential circular dependency.
    },
    history: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        author: {
          nt: CommitAuthor,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        path: {
          nt: String,
          it: [0],
        },
        since: {
          nt: GitTimestamp,
          it: [0],
        },
        until: {
          nt: GitTimestamp,
          it: [0],
        },
      },
      // nt: CommitHistoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    message: {},
    messageBody: {},
    messageBodyHTML: {
      nt: HTML,
    },
    messageHeadline: {},
    messageHeadlineHTML: {
      nt: HTML,
    },
    oid: {
      nt: GitObjectID,
    },
    onBehalfOf: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    parents: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pushedDate: {
      nt: DateTime,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    signature: {
      // nt: GitSignature, <-- Assigned later to avoid potential circular dependency.
    },
    status: {
      // nt: Status, <-- Assigned later to avoid potential circular dependency.
    },
    statusCheckRollup: {
      // nt: StatusCheckRollup, <-- Assigned later to avoid potential circular dependency.
    },
    submodules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: SubmoduleConnection, <-- Assigned later to avoid potential circular dependency.
    },
    tarballUrl: {
      nt: URI,
    },
    tree: {
      // nt: Tree, <-- Assigned later to avoid potential circular dependency.
    },
    treeResourcePath: {
      nt: URI,
    },
    treeUrl: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    viewerCanSubscribe: {},
    viewerSubscription: {},
    zipballUrl: {
      nt: URI,
    },
  },
}

const CommitAuthorEmailPatternParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const CommitComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isMinimized: {},
    lastEditedAt: {
      nt: DateTime,
    },
    minimizedReason: {},
    path: {},
    position: {},
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMinimize: {},
    viewerCanReact: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const CommitCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CommitCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CommitComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CommitCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CommitComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CommitCommentThread: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    path: {},
    position: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CommitConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CommitEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CommitContributionsByRepository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: CommitContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedCommitContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const CommitEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CommitHistoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CommitEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CommitMessagePatternParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const CommitterEmailPatternParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const Comparison: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    aheadBy: {},
    baseTarget: {
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
    behindBy: {},
    commits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ComparisonCommitConnection, <-- Assigned later to avoid potential circular dependency.
    },
    headTarget: {
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    status: {},
  },
}

const ComparisonCommitConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    authorCount: {},
    edges: {
      // nt: CommitEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ConnectedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isCrossRepository: {},
    source: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ContributingGuidelines: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const ContributionCalendar: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    colors: {},
    isHalloween: {},
    months: {
      // nt: ContributionCalendarMonth, <-- Assigned later to avoid potential circular dependency.
    },
    totalContributions: {},
    weeks: {
      // nt: ContributionCalendarWeek, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ContributionCalendarDay: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    color: {},
    contributionCount: {},
    contributionLevel: {},
    date: {
      nt: Date,
    },
    weekday: {},
  },
}

const ContributionCalendarMonth: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    firstDay: {
      nt: Date,
    },
    name: {},
    totalWeeks: {},
    year: {},
  },
}

const ContributionCalendarWeek: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contributionDays: {
      // nt: ContributionCalendarDay, <-- Assigned later to avoid potential circular dependency.
    },
    firstDay: {
      nt: Date,
    },
  },
}

const ContributionsCollection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    commitContributionsByRepository: {
      a: {
        maxRepositories: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitContributionsByRepository, <-- Assigned later to avoid potential circular dependency.
    },
    contributionCalendar: {
      // nt: ContributionCalendar, <-- Assigned later to avoid potential circular dependency.
    },
    contributionYears: {},
    doesEndInCurrentMonth: {},
    earliestRestrictedContributionDate: {
      nt: Date,
    },
    endedAt: {
      nt: DateTime,
    },
    firstIssueContribution: {
      // nt: CreatedIssueOrRestrictedContribution, <-- Assigned later to avoid potential circular dependency.
    },
    firstPullRequestContribution: {
      // nt: CreatedPullRequestOrRestrictedContribution, <-- Assigned later to avoid potential circular dependency.
    },
    firstRepositoryContribution: {
      // nt: CreatedRepositoryOrRestrictedContribution, <-- Assigned later to avoid potential circular dependency.
    },
    hasActivityInThePast: {},
    hasAnyContributions: {},
    hasAnyRestrictedContributions: {},
    isSingleDay: {},
    issueContributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedIssueContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    issueContributionsByRepository: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
        maxRepositories: {
          nt: Int,
          it: [0],
        },
      },
      // nt: IssueContributionsByRepository, <-- Assigned later to avoid potential circular dependency.
    },
    joinedGitHubContribution: {
      // nt: JoinedGitHubContribution, <-- Assigned later to avoid potential circular dependency.
    },
    latestRestrictedContributionDate: {
      nt: Date,
    },
    mostRecentCollectionWithActivity: {
      // nt: ContributionsCollection, <-- Assigned later to avoid potential circular dependency.
    },
    mostRecentCollectionWithoutActivity: {
      // nt: ContributionsCollection, <-- Assigned later to avoid potential circular dependency.
    },
    popularIssueContribution: {
      // nt: CreatedIssueContribution, <-- Assigned later to avoid potential circular dependency.
    },
    popularPullRequestContribution: {
      // nt: CreatedPullRequestContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestContributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedPullRequestContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestContributionsByRepository: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
        maxRepositories: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestContributionsByRepository, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestReviewContributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedPullRequestReviewContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestReviewContributionsByRepository: {
      a: {
        maxRepositories: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewContributionsByRepository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryContributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedRepositoryContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    restrictedContributionsCount: {},
    startedAt: {
      nt: DateTime,
    },
    totalCommitContributions: {},
    totalIssueContributions: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    totalPullRequestContributions: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    totalPullRequestReviewContributions: {},
    totalRepositoriesWithContributedCommits: {},
    totalRepositoriesWithContributedIssues: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    totalRepositoriesWithContributedPullRequestReviews: {},
    totalRepositoriesWithContributedPullRequests: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
        excludePopular: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    totalRepositoryContributions: {
      a: {
        excludeFirst: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ConvertProjectCardNoteToIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectCard: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ConvertProjectV2DraftIssueItemToIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ConvertPullRequestToDraftPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ConvertToDraftEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const ConvertedNoteToIssueEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectCard: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
    projectColumnName: {},
  },
}

const ConvertedToDiscussionEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const CopilotEndpoints: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    api: {},
    originTracker: {},
    proxy: {},
    telemetry: {},
  },
}

const CopyProjectV2Payload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateAttributionInvitationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    source: {
      // nt: Claimable, <-- Assigned later to avoid potential circular dependency.
    },
    target: {
      // nt: Claimable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateBranchProtectionRulePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const CreateCheckRunPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkRun: {
      // nt: CheckRun, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const CreateCheckSuitePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkSuite: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const CreateCommitOnBranchPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateDeploymentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    autoMerged: {},
    clientMutationId: {},
    deployment: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateDeploymentStatusPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deploymentStatus: {
      // nt: DeploymentStatus, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateEnterpriseOrganizationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateEnvironmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateIpAllowListEntryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ipAllowListEntry: {
      // nt: IpAllowListEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateLabelPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    label: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateLinkedBranchPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    linkedBranch: {
      // nt: LinkedBranch, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateMigrationSourcePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    migrationSource: {
      // nt: MigrationSource, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateProjectV2FieldPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2Field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateProjectV2Payload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateProjectV2StatusUpdatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    statusUpdate: {
      // nt: ProjectV2StatusUpdate, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateRefPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateRepositoryRulesetPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ruleset: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateSponsorsListingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateSponsorsTierPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateSponsorshipPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorship: {
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateSponsorshipsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorables: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateTeamDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    teamDiscussionComment: {
      // nt: TeamDiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateTeamDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    teamDiscussion: {
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreateUserListPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    list: {
      // nt: UserList, <-- Assigned later to avoid potential circular dependency.
    },
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedCommitContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    commitCount: {},
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedCommitContributionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CreatedCommitContributionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CreatedCommitContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CreatedCommitContributionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CreatedCommitContribution, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedIssueContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    occurredAt: {
      nt: DateTime,
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedIssueContributionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CreatedIssueContributionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CreatedIssueContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CreatedIssueContributionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CreatedIssueContribution, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedPullRequestContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedPullRequestContributionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CreatedPullRequestContributionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CreatedPullRequestContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CreatedPullRequestContributionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CreatedPullRequestContribution, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedPullRequestReviewContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedPullRequestReviewContributionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CreatedPullRequestReviewContributionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CreatedPullRequestReviewContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CreatedPullRequestReviewContributionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CreatedPullRequestReviewContribution, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedRepositoryContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CreatedRepositoryContributionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: CreatedRepositoryContributionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: CreatedRepositoryContribution, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const CreatedRepositoryContributionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: CreatedRepositoryContribution, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const CrossReferencedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isCrossRepository: {},
    referencedAt: {
      nt: DateTime,
    },
    resourcePath: {
      nt: URI,
    },
    source: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
    target: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
    willCloseTarget: {},
  },
}

const CvssSeverities: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cvssV3: {
      // nt: CVSS, <-- Assigned later to avoid potential circular dependency.
    },
    cvssV4: {
      // nt: CVSS, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeclineTopicSuggestionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    topic: {
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteBranchProtectionRulePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteDeploymentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    comment: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteEnvironmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteIpAllowListEntryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ipAllowListEntry: {
      // nt: IpAllowListEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteIssueCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteLabelPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteLinkedBranchPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeletePackageVersionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    success: {},
  },
}

const DeleteProjectCardPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    column: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
    deletedCardId: {},
  },
}

const DeleteProjectColumnPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deletedColumnId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: ProjectOwner, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteProjectV2FieldPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2Field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteProjectV2ItemPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deletedItemId: {},
  },
}

const DeleteProjectV2Payload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteProjectV2StatusUpdatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deletedStatusUpdateId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteProjectV2WorkflowPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deletedWorkflowId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeletePullRequestReviewCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestReviewComment: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeletePullRequestReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteRefPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteRepositoryRulesetPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteTeamDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteTeamDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const DeleteUserListPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeleteVerifiableDomainPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: VerifiableDomainOwner, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DemilestonedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    milestoneTitle: {},
    subject: {
      // nt: MilestoneItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DependabotUpdate: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    error: {
      // nt: DependabotUpdateError, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DependabotUpdateError: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    errorType: {},
    title: {},
  },
}

const DependencyGraphDependency: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    hasDependencies: {},
    packageLabel: {},
    packageManager: {},
    packageName: {},
    relationship: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    requirements: {},
  },
}

const DependencyGraphDependencyConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DependencyGraphDependencyEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DependencyGraphDependency, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DependencyGraphDependencyEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DependencyGraphDependency, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DependencyGraphManifest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    blobPath: {},
    dependencies: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DependencyGraphDependencyConnection, <-- Assigned later to avoid potential circular dependency.
    },
    dependenciesCount: {},
    exceedsMaxSize: {},
    filename: {},
    id: {},
    parseable: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DependencyGraphManifestConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DependencyGraphManifestEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DependencyGraphManifest, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DependencyGraphManifestEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DependencyGraphManifest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeployKey: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    enabled: {},
    id: {},
    key: {},
    readOnly: {},
    title: {},
    verified: {},
  },
}

const DeployKeyConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeployKeyEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeployKey, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeployKeyEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeployKey, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeployedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    deployment: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Deployment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    commitOid: {},
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    description: {},
    environment: {},
    id: {},
    latestEnvironment: {},
    latestStatus: {
      // nt: DeploymentStatus, <-- Assigned later to avoid potential circular dependency.
    },
    originalEnvironment: {},
    payload: {},
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    statuses: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentStatusConnection, <-- Assigned later to avoid potential circular dependency.
    },
    task: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const DeploymentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentEnvironmentChangedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    deploymentStatus: {
      // nt: DeploymentStatus, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentProtectionRule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    databaseId: {},
    preventSelfReview: {},
    reviewers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentReviewerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    timeout: {},
    type: {},
  },
}

const DeploymentProtectionRuleConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentProtectionRuleEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeploymentProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentProtectionRuleEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeploymentProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    currentUserCanApprove: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
    reviewers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentReviewerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    waitTimer: {},
    waitTimerStartedAt: {
      nt: DateTime,
    },
  },
}

const DeploymentRequestConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentRequestEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeploymentRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentRequestEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeploymentRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentReview: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comment: {},
    databaseId: {},
    environments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: EnvironmentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    state: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentReviewConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentReviewEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeploymentReview, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentReviewEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeploymentReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentReviewerConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentReviewerEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeploymentReviewer, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentReviewerEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeploymentReviewer, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DeploymentStatus: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    deployment: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
    description: {},
    environment: {},
    environmentUrl: {
      nt: URI,
    },
    id: {},
    logUrl: {
      nt: URI,
    },
    state: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const DeploymentStatusConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DeploymentStatusEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DeploymentStatus, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DeploymentStatusEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DeploymentStatus, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DequeuePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    mergeQueueEntry: {
      // nt: MergeQueueEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DisablePullRequestAutoMergePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DisconnectedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isCrossRepository: {},
    source: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Discussion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    activeLockReason: {},
    answer: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
    answerChosenAt: {
      nt: DateTime,
    },
    answerChosenBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    category: {
      // nt: DiscussionCategory, <-- Assigned later to avoid potential circular dependency.
    },
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DiscussionCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isAnswered: {},
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LabelOrder,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
    lastEditedAt: {
      nt: DateTime,
    },
    locked: {},
    number: {},
    poll: {
      // nt: DiscussionPoll, <-- Assigned later to avoid potential circular dependency.
    },
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    stateReason: {},
    title: {},
    updatedAt: {
      nt: DateTime,
    },
    upvoteCount: {},
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanClose: {},
    viewerCanDelete: {},
    viewerCanLabel: {},
    viewerCanReact: {},
    viewerCanReopen: {},
    viewerCanSubscribe: {},
    viewerCanUpdate: {},
    viewerCanUpvote: {},
    viewerDidAuthor: {},
    viewerHasUpvoted: {},
    viewerSubscription: {},
  },
}

const DiscussionCategory: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    description: {},
    emoji: {},
    emojiHTML: {
      nt: HTML,
    },
    id: {},
    isAnswerable: {},
    name: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    slug: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const DiscussionCategoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DiscussionCategoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DiscussionCategory, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DiscussionCategoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DiscussionCategory, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DiscussionComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    deletedAt: {
      nt: DateTime,
    },
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isAnswer: {},
    isMinimized: {},
    lastEditedAt: {
      nt: DateTime,
    },
    minimizedReason: {},
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    replies: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DiscussionCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    replyTo: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    upvoteCount: {},
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMarkAsAnswer: {},
    viewerCanMinimize: {},
    viewerCanReact: {},
    viewerCanUnmarkAsAnswer: {},
    viewerCanUpdate: {},
    viewerCanUpvote: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
    viewerHasUpvoted: {},
  },
}

const DiscussionCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DiscussionCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DiscussionCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DiscussionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DiscussionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DiscussionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DiscussionPoll: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    options: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DiscussionPollOptionOrder,
          it: [0],
        },
      },
      // nt: DiscussionPollOptionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    question: {},
    totalVoteCount: {},
    viewerCanVote: {},
    viewerHasVoted: {},
  },
}

const DiscussionPollOption: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    option: {},
    poll: {
      // nt: DiscussionPoll, <-- Assigned later to avoid potential circular dependency.
    },
    totalVoteCount: {},
    viewerHasVoted: {},
  },
}

const DiscussionPollOptionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: DiscussionPollOptionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: DiscussionPollOption, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const DiscussionPollOptionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: DiscussionPollOption, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DismissPullRequestReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DismissRepositoryVulnerabilityAlertPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repositoryVulnerabilityAlert: {
      // nt: RepositoryVulnerabilityAlert, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const DraftIssue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    assignees: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    projectV2Items: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2ItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    title: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const EPSS: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    percentage: {},
    percentile: {},
  },
}

const EnablePullRequestAutoMergePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnqueuePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    mergeQueueEntry: {
      // nt: MergeQueueEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Enterprise: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    announcement: {},
    announcementBanner: {
      // nt: AnnouncementBanner, <-- Assigned later to avoid potential circular dependency.
    },
    announcementCreatedAt: {
      nt: DateTime,
    },
    announcementExpiresAt: {
      nt: DateTime,
    },
    announcementUserDismissible: {},
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    billingEmail: {},
    billingInfo: {
      // nt: EnterpriseBillingInfo, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    description: {},
    descriptionHTML: {
      nt: HTML,
    },
    id: {},
    location: {},
    members: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        deployment: {
          nt: EnterpriseUserDeployment,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasTwoFactorEnabled: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseMemberOrder,
          it: [0],
        },
        organizationLogins: {
          nt: String,
          it: [0, [1]],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: EnterpriseUserAccountMembershipRole,
          it: [0],
        },
        twoFactorMethodSecurity: {
          nt: TwoFactorCredentialSecurityType,
          it: [0],
        },
      },
      // nt: EnterpriseMemberConnection, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    organizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        viewerOrganizationRole: {
          nt: RoleInOrganization,
          it: [0],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    ownerInfo: {
      // nt: EnterpriseOwnerInfo, <-- Assigned later to avoid potential circular dependency.
    },
    readme: {},
    readmeHTML: {
      nt: HTML,
    },
    resourcePath: {
      nt: URI,
    },
    ruleset: {
      a: {
        databaseId: {
          nt: Int,
          it: [1],
        },
      },
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
    rulesets: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: RepositoryRulesetConnection, <-- Assigned later to avoid potential circular dependency.
    },
    slug: {},
    url: {
      nt: URI,
    },
    userNamespaceRepositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: UserNamespaceRepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerIsAdmin: {},
    websiteUrl: {
      nt: URI,
    },
  },
}

const EnterpriseAdministratorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseAdministratorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseAdministratorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const EnterpriseAdministratorInvitation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    email: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    invitee: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    inviter: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const EnterpriseAdministratorInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseAdministratorInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseAdministratorInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseBillingInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allLicensableUsersCount: {},
    assetPacks: {},
    bandwidthQuota: {},
    bandwidthUsage: {},
    bandwidthUsagePercentage: {},
    storageQuota: {},
    storageUsage: {},
    storageUsagePercentage: {},
    totalAvailableLicenses: {},
    totalLicenses: {},
  },
}

const EnterpriseConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseFailedInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseFailedInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    totalUniqueUserCount: {},
  },
}

const EnterpriseFailedInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseIdentityProvider: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    digestMethod: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    externalIdentities: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        membersOnly: {
          nt: Boolean,
          it: [0],
        },
        userName: {
          nt: String,
          it: [0],
        },
      },
      // nt: ExternalIdentityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    idpCertificate: {
      nt: X509Certificate,
    },
    issuer: {},
    recoveryCodes: {},
    signatureMethod: {},
    ssoUrl: {
      nt: URI,
    },
  },
}

const EnterpriseMemberConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseMemberEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseMember, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseMemberEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseMember, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseMemberInvitation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    email: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    invitee: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    inviter: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseMemberInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseMemberInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseMemberInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseOrganizationMembershipConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseOrganizationMembershipEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseOrganizationMembershipEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const EnterpriseOutsideCollaboratorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseOutsideCollaboratorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseOutsideCollaboratorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    repositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
      },
      // nt: EnterpriseRepositoryInfoConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseOwnerInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    admins: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasTwoFactorEnabled: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseMemberOrder,
          it: [0],
        },
        organizationLogins: {
          nt: String,
          it: [0, [1]],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: EnterpriseAdministratorRole,
          it: [0],
        },
        twoFactorMethodSecurity: {
          nt: TwoFactorCredentialSecurityType,
          it: [0],
        },
      },
      // nt: EnterpriseAdministratorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    affiliatedUsersWithTwoFactorDisabled: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    affiliatedUsersWithTwoFactorDisabledExist: {},
    allowPrivateRepositoryForkingSetting: {},
    allowPrivateRepositoryForkingSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    allowPrivateRepositoryForkingSettingPolicyValue: {},
    defaultRepositoryPermissionSetting: {},
    defaultRepositoryPermissionSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: DefaultRepositoryPermissionField,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    domains: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        isApproved: {
          nt: Boolean,
          it: [0],
        },
        isVerified: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: VerifiableDomainOrder,
          it: [0],
        },
      },
      // nt: VerifiableDomainConnection, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseServerInstallations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        connectedOnly: {
          nt: Boolean,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseServerInstallationOrder,
          it: [0],
        },
      },
      // nt: EnterpriseServerInstallationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    failedInvitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: EnterpriseFailedInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    ipAllowListEnabledSetting: {},
    ipAllowListEntries: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IpAllowListEntryOrder,
          it: [0],
        },
      },
      // nt: IpAllowListEntryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    ipAllowListForInstalledAppsEnabledSetting: {},
    isUpdatingDefaultRepositoryPermission: {},
    isUpdatingTwoFactorRequirement: {},
    membersCanChangeRepositoryVisibilitySetting: {},
    membersCanChangeRepositoryVisibilitySettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanCreateInternalRepositoriesSetting: {},
    membersCanCreatePrivateRepositoriesSetting: {},
    membersCanCreatePublicRepositoriesSetting: {},
    membersCanCreateRepositoriesSetting: {},
    membersCanCreateRepositoriesSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: OrganizationMembersCanCreateRepositoriesSettingValue,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanDeleteIssuesSetting: {},
    membersCanDeleteIssuesSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanDeleteRepositoriesSetting: {},
    membersCanDeleteRepositoriesSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanInviteCollaboratorsSetting: {},
    membersCanInviteCollaboratorsSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanMakePurchasesSetting: {},
    membersCanUpdateProtectedBranchesSetting: {},
    membersCanUpdateProtectedBranchesSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanViewDependencyInsightsSetting: {},
    membersCanViewDependencyInsightsSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    notificationDeliveryRestrictionEnabledSetting: {},
    oidcProvider: {
      // nt: OIDCProvider, <-- Assigned later to avoid potential circular dependency.
    },
    organizationProjectsSetting: {},
    organizationProjectsSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    outsideCollaborators: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasTwoFactorEnabled: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseMemberOrder,
          it: [0],
        },
        organizationLogins: {
          nt: String,
          it: [0, [1]],
        },
        query: {
          nt: String,
          it: [0],
        },
        twoFactorMethodSecurity: {
          nt: TwoFactorCredentialSecurityType,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: EnterpriseOutsideCollaboratorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pendingAdminInvitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseAdministratorInvitationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: EnterpriseAdministratorRole,
          it: [0],
        },
      },
      // nt: EnterpriseAdministratorInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pendingCollaboratorInvitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryInvitationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: RepositoryInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pendingMemberInvitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        invitationSource: {
          nt: OrganizationInvitationSource,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        organizationLogins: {
          nt: String,
          it: [0, [1]],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: EnterprisePendingMemberInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pendingUnaffiliatedMemberInvitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseMemberInvitationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: EnterpriseMemberInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryDeployKeySetting: {},
    repositoryDeployKeySettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryProjectsSetting: {},
    repositoryProjectsSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    samlIdentityProvider: {
      // nt: EnterpriseIdentityProvider, <-- Assigned later to avoid potential circular dependency.
    },
    samlIdentityProviderSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: IdentityProviderConfigurationState,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    supportEntitlements: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseMemberOrder,
          it: [0],
        },
      },
      // nt: EnterpriseMemberConnection, <-- Assigned later to avoid potential circular dependency.
    },
    teamDiscussionsSetting: {},
    teamDiscussionsSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    twoFactorDisallowedMethodsSetting: {},
    twoFactorRequiredSetting: {},
    twoFactorRequiredSettingOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        value: {
          nt: Boolean,
          it: [1],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterprisePendingMemberInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterprisePendingMemberInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    totalUniqueUserCount: {},
  },
}

const EnterprisePendingMemberInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseRepositoryInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    isPrivate: {},
    name: {},
    nameWithOwner: {},
  },
}

const EnterpriseRepositoryInfoConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseRepositoryInfoEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseRepositoryInfo, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseRepositoryInfoEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseRepositoryInfo, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerInstallation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    customerName: {},
    hostName: {},
    id: {},
    isConnected: {},
    updatedAt: {
      nt: DateTime,
    },
    userAccounts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseServerUserAccountOrder,
          it: [0],
        },
      },
      // nt: EnterpriseServerUserAccountConnection, <-- Assigned later to avoid potential circular dependency.
    },
    userAccountsUploads: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseServerUserAccountsUploadOrder,
          it: [0],
        },
      },
      // nt: EnterpriseServerUserAccountsUploadConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerInstallationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseServerInstallationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseServerInstallationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerInstallationMembershipConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseServerInstallationMembershipEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseServerInstallationMembershipEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const EnterpriseServerUserAccount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    emails: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseServerUserAccountEmailOrder,
          it: [0],
        },
      },
      // nt: EnterpriseServerUserAccountEmailConnection, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseServerInstallation: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    isSiteAdmin: {},
    login: {},
    profileName: {},
    remoteCreatedAt: {
      nt: DateTime,
    },
    remoteUserId: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const EnterpriseServerUserAccountConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseServerUserAccountEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseServerUserAccount, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseServerUserAccountEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseServerUserAccount, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerUserAccountEmail: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    email: {},
    id: {},
    isPrimary: {},
    updatedAt: {
      nt: DateTime,
    },
    userAccount: {
      // nt: EnterpriseServerUserAccount, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerUserAccountEmailConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseServerUserAccountEmailEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseServerUserAccountEmail, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseServerUserAccountEmailEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseServerUserAccountEmail, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseServerUserAccountsUpload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseServerInstallation: {
      // nt: EnterpriseServerInstallation, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    name: {},
    syncState: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const EnterpriseServerUserAccountsUploadConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnterpriseServerUserAccountsUploadEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: EnterpriseServerUserAccountsUpload, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnterpriseServerUserAccountsUploadEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: EnterpriseServerUserAccountsUpload, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnterpriseUserAccount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    createdAt: {
      nt: DateTime,
    },
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseInstallations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseServerInstallationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: EnterpriseUserAccountMembershipRole,
          it: [0],
        },
      },
      // nt: EnterpriseServerInstallationMembershipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    login: {},
    name: {},
    organizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: EnterpriseUserAccountMembershipRole,
          it: [0],
        },
      },
      // nt: EnterpriseOrganizationMembershipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Environment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    databaseId: {},
    id: {},
    isPinned: {},
    latestCompletedDeployment: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    pinnedPosition: {},
    protectionRules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentProtectionRuleConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const EnvironmentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: EnvironmentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const EnvironmentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ExternalIdentity: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    guid: {},
    id: {},
    organizationInvitation: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    samlIdentity: {
      // nt: ExternalIdentitySamlAttributes, <-- Assigned later to avoid potential circular dependency.
    },
    scimIdentity: {
      // nt: ExternalIdentityScimAttributes, <-- Assigned later to avoid potential circular dependency.
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ExternalIdentityAttribute: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    metadata: {},
    name: {},
    value: {},
  },
}

const ExternalIdentityConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ExternalIdentityEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ExternalIdentity, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ExternalIdentityEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ExternalIdentity, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ExternalIdentitySamlAttributes: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    attributes: {
      // nt: ExternalIdentityAttribute, <-- Assigned later to avoid potential circular dependency.
    },
    emails: {
      // nt: UserEmailMetadata, <-- Assigned later to avoid potential circular dependency.
    },
    familyName: {},
    givenName: {},
    groups: {},
    nameId: {},
    username: {},
  },
}

const ExternalIdentityScimAttributes: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    emails: {
      // nt: UserEmailMetadata, <-- Assigned later to avoid potential circular dependency.
    },
    familyName: {},
    givenName: {},
    groups: {},
    username: {},
  },
}

const FileExtensionRestrictionParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    restrictedFileExtensions: {},
  },
}

const FilePathRestrictionParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    restrictedFilePaths: {},
  },
}

const FollowOrganizationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const FollowUserPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const FollowerConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const FollowingConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const FundingLink: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    platform: {},
    url: {
      nt: URI,
    },
  },
}

const GenericHovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    message: {},
    octicon: {},
  },
}

const Gist: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: GistCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    description: {},
    files: {
      a: {
        limit: {
          nt: Int,
          it: [0],
        },
        oid: {
          nt: GitObjectID,
          it: [0],
        },
      },
      // nt: GistFile, <-- Assigned later to avoid potential circular dependency.
    },
    forks: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: GistOrder,
          it: [0],
        },
      },
      // nt: GistConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    isFork: {},
    isPublic: {},
    name: {},
    owner: {
      // nt: RepositoryOwner, <-- Assigned later to avoid potential circular dependency.
    },
    pushedAt: {
      nt: DateTime,
    },
    resourcePath: {
      nt: URI,
    },
    stargazerCount: {},
    stargazers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: StarOrder,
          it: [0],
        },
      },
      // nt: StargazerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerHasStarred: {},
  },
}

const GistComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    gist: {
      // nt: Gist, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isMinimized: {},
    lastEditedAt: {
      nt: DateTime,
    },
    minimizedReason: {},
    publishedAt: {
      nt: DateTime,
    },
    updatedAt: {
      nt: DateTime,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMinimize: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const GistCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: GistCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: GistComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const GistCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: GistComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const GistConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: GistEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Gist, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const GistEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Gist, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const GistFile: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    encodedName: {},
    encoding: {},
    extension: {},
    isImage: {},
    isTruncated: {},
    language: {
      // nt: Language, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    size: {},
    text: {
      a: {
        truncate: {
          nt: Int,
          it: [0],
        },
      },
    },
  },
}

const GitActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    date: {
      nt: GitTimestamp,
    },
    email: {},
    name: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const GitActorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: GitActorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: GitActor, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const GitActorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: GitActor, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const GitHubMetadata: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    gitHubServicesSha: {
      nt: GitObjectID,
    },
    gitIpAddresses: {},
    githubEnterpriseImporterIpAddresses: {},
    hookIpAddresses: {},
    importerIpAddresses: {},
    isPasswordAuthenticationVerifiable: {},
    pagesIpAddresses: {},
  },
}

const GpgSignature: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    email: {},
    isValid: {},
    keyId: {},
    payload: {},
    signature: {},
    signer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    verifiedAt: {
      nt: DateTime,
    },
    wasSignedByGitHub: {},
  },
}

const GrantEnterpriseOrganizationsMigratorRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const GrantMigratorRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    success: {},
  },
}

const HeadRefDeletedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    headRef: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    headRefName: {},
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const HeadRefForcePushedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    afterCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    beforeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const HeadRefRestoredEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Hovercard: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contexts: {
      // nt: HovercardContext, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ImportProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const InviteEnterpriseAdminPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const InviteEnterpriseMemberPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invitation: {
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const IpAllowListEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allowListValue: {},
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isActive: {},
    name: {},
    owner: {
      // nt: IpAllowListOwner, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const IpAllowListEntryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: IpAllowListEntryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: IpAllowListEntry, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const IpAllowListEntryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: IpAllowListEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Issue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    activeLockReason: {},
    assignees: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyResourcePath: {
      nt: URI,
    },
    bodyText: {},
    bodyUrl: {
      nt: URI,
    },
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    closedByPullRequestsReferences: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeClosedPrs: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderByState: {
          nt: Boolean,
          it: [0],
        },
        userLinkedOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueCommentOrder,
          it: [0],
        },
      },
      // nt: IssueCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    hovercard: {
      a: {
        includeNotificationContexts: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Hovercard, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isPinned: {},
    isReadByViewer: {},
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LabelOrder,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
    lastEditedAt: {
      nt: DateTime,
    },
    linkedBranches: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: LinkedBranchConnection, <-- Assigned later to avoid potential circular dependency.
    },
    locked: {},
    milestone: {
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
    number: {},
    parent: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    participants: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectCards: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        archivedStates: {
          nt: ProjectCardArchivedState,
          it: [0, [0]],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectCardConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeArchived: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2ItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    state: {},
    stateReason: {
      a: {
        enableDuplicate: {
          nt: Boolean,
          it: [0],
        },
      },
    },
    subIssues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    subIssuesSummary: {
      // nt: SubIssuesSummary, <-- Assigned later to avoid potential circular dependency.
    },
    timeline: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: IssueTimelineConnection, <-- Assigned later to avoid potential circular dependency.
    },
    timelineItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        itemTypes: {
          nt: IssueTimelineItemsItemType,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
        skip: {
          nt: Int,
          it: [0],
        },
      },
      // nt: IssueTimelineItemsConnection, <-- Assigned later to avoid potential circular dependency.
    },
    title: {},
    titleHTML: {},
    trackedInIssues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    trackedIssues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    trackedIssuesCount: {
      a: {
        states: {
          nt: TrackedIssueStates,
          it: [0, [0]],
        },
      },
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanClose: {},
    viewerCanDelete: {},
    viewerCanLabel: {},
    viewerCanReact: {},
    viewerCanReopen: {},
    viewerCanSubscribe: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
    viewerSubscription: {},
    viewerThreadSubscriptionFormAction: {},
    viewerThreadSubscriptionStatus: {},
  },
}

const IssueComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    includesCreatedEdit: {},
    isMinimized: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    lastEditedAt: {
      nt: DateTime,
    },
    minimizedReason: {},
    publishedAt: {
      nt: DateTime,
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMinimize: {},
    viewerCanReact: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const IssueCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: IssueCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: IssueComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const IssueCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: IssueComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const IssueConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: IssueEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const IssueContributionsByRepository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedIssueContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const IssueEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const IssueTemplate: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    about: {},
    assignees: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    body: {},
    filename: {},
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LabelOrder,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    title: {},
  },
}

const IssueTimelineConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: IssueTimelineItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: IssueTimelineItem, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const IssueTimelineItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: IssueTimelineItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const IssueTimelineItemsConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: IssueTimelineItemsEdge, <-- Assigned later to avoid potential circular dependency.
    },
    filteredCount: {},
    nodes: {
      // nt: IssueTimelineItems, <-- Assigned later to avoid potential circular dependency.
    },
    pageCount: {},
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const IssueTimelineItemsEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: IssueTimelineItems, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const JoinedGitHubContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Label: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    color: {},
    createdAt: {
      nt: DateTime,
    },
    description: {},
    id: {},
    isDefault: {},
    issues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: IssueFilters,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: IssueState,
          it: [0, [1]],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    pullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const LabelConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: LabelEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const LabelEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LabeledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    label: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
    labelable: {
      // nt: Labelable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Language: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    color: {},
    id: {},
    name: {},
  },
}

const LanguageConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: LanguageEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Language, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    totalSize: {},
  },
}

const LanguageEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Language, <-- Assigned later to avoid potential circular dependency.
    },
    size: {},
  },
}

const License: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    conditions: {
      // nt: LicenseRule, <-- Assigned later to avoid potential circular dependency.
    },
    description: {},
    featured: {},
    hidden: {},
    id: {},
    implementation: {},
    key: {},
    limitations: {
      // nt: LicenseRule, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    nickname: {},
    permissions: {
      // nt: LicenseRule, <-- Assigned later to avoid potential circular dependency.
    },
    pseudoLicense: {},
    spdxId: {},
    url: {
      nt: URI,
    },
  },
}

const LicenseRule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    description: {},
    key: {},
    label: {},
  },
}

const LinkProjectV2ToRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LinkProjectV2ToTeamPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LinkRepositoryToProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LinkedBranch: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LinkedBranchConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: LinkedBranchEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: LinkedBranch, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const LinkedBranchEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: LinkedBranch, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LockLockablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    lockedRecord: {
      // nt: Lockable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const LockedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    lockReason: {},
    lockable: {
      // nt: Lockable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Mannequin: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    claimant: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    email: {},
    id: {},
    login: {},
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const MannequinConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: MannequinEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Mannequin, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const MannequinEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Mannequin, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MarkDiscussionCommentAsAnswerPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MarkFileAsViewedPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MarkProjectV2AsTemplatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MarkPullRequestReadyForReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MarkedAsDuplicateEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    canonical: {
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    duplicate: {
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    isCrossRepository: {},
  },
}

const MarketplaceCategory: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    description: {},
    howItWorks: {},
    id: {},
    name: {},
    primaryListingCount: {},
    resourcePath: {
      nt: URI,
    },
    secondaryListingCount: {},
    slug: {},
    url: {
      nt: URI,
    },
  },
}

const MarketplaceListing: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    app: {
      // nt: App, <-- Assigned later to avoid potential circular dependency.
    },
    companyUrl: {
      nt: URI,
    },
    configurationResourcePath: {
      nt: URI,
    },
    configurationUrl: {
      nt: URI,
    },
    documentationUrl: {
      nt: URI,
    },
    extendedDescription: {},
    extendedDescriptionHTML: {
      nt: HTML,
    },
    fullDescription: {},
    fullDescriptionHTML: {
      nt: HTML,
    },
    hasPublishedFreeTrialPlans: {},
    hasTermsOfService: {},
    hasVerifiedOwner: {},
    howItWorks: {},
    howItWorksHTML: {
      nt: HTML,
    },
    id: {},
    installationUrl: {
      nt: URI,
    },
    installedForViewer: {},
    isArchived: {},
    isDraft: {},
    isPaid: {},
    isPublic: {},
    isRejected: {},
    isUnverified: {},
    isUnverifiedPending: {},
    isVerificationPendingFromDraft: {},
    isVerificationPendingFromUnverified: {},
    isVerified: {},
    logoBackgroundColor: {},
    logoUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    name: {},
    normalizedShortDescription: {},
    pricingUrl: {
      nt: URI,
    },
    primaryCategory: {
      // nt: MarketplaceCategory, <-- Assigned later to avoid potential circular dependency.
    },
    privacyPolicyUrl: {
      nt: URI,
    },
    resourcePath: {
      nt: URI,
    },
    screenshotUrls: {},
    secondaryCategory: {
      // nt: MarketplaceCategory, <-- Assigned later to avoid potential circular dependency.
    },
    shortDescription: {},
    slug: {},
    statusUrl: {
      nt: URI,
    },
    supportEmail: {},
    supportUrl: {
      nt: URI,
    },
    termsOfServiceUrl: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    viewerCanAddPlans: {},
    viewerCanApprove: {},
    viewerCanDelist: {},
    viewerCanEdit: {},
    viewerCanEditCategories: {},
    viewerCanEditPlans: {},
    viewerCanRedraft: {},
    viewerCanReject: {},
    viewerCanRequestApproval: {},
    viewerHasPurchased: {},
    viewerHasPurchasedForAllOrganizations: {},
    viewerIsListingAdmin: {},
  },
}

const MarketplaceListingConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: MarketplaceListingEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: MarketplaceListing, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const MarketplaceListingEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: MarketplaceListing, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MaxFilePathLengthParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    maxFilePathLength: {},
  },
}

const MaxFileSizeParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    maxFileSize: {},
  },
}

const MemberFeatureRequestNotification: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    id: {},
    title: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const MembersCanDeleteReposClearAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const MembersCanDeleteReposDisableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const MembersCanDeleteReposEnableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const MentionedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
  },
}

const MergeBranchPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    mergeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MergePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MergeQueue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    configuration: {
      // nt: MergeQueueConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    entries: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: MergeQueueEntryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    nextEntryEstimatedTimeToMerge: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const MergeQueueConfiguration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkResponseTimeout: {},
    maximumEntriesToBuild: {},
    maximumEntriesToMerge: {},
    mergeMethod: {},
    mergingStrategy: {},
    minimumEntriesToMerge: {},
    minimumEntriesToMergeWaitTime: {},
  },
}

const MergeQueueEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    baseCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    enqueuedAt: {
      nt: DateTime,
    },
    enqueuer: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    estimatedTimeToMerge: {},
    headCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    jump: {},
    mergeQueue: {
      // nt: MergeQueue, <-- Assigned later to avoid potential circular dependency.
    },
    position: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    solo: {},
    state: {},
  },
}

const MergeQueueEntryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: MergeQueueEntryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: MergeQueueEntry, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const MergeQueueEntryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: MergeQueueEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MergeQueueParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkResponseTimeoutMinutes: {},
    groupingStrategy: {},
    maxEntriesToBuild: {},
    maxEntriesToMerge: {},
    mergeMethod: {},
    minEntriesToMerge: {},
    minEntriesToMergeWaitMinutes: {},
  },
}

const MergedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    mergeRef: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    mergeRefName: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const MigrationSource: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    name: {},
    type: {},
    url: {
      nt: URI,
    },
  },
}

const Milestone: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    description: {},
    dueOn: {
      nt: DateTime,
    },
    id: {},
    issues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: IssueFilters,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: IssueState,
          it: [0, [1]],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    number: {},
    progressPercentage: {},
    pullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    state: {},
    title: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerCanClose: {},
    viewerCanReopen: {},
  },
}

const MilestoneConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: MilestoneEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const MilestoneEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MilestonedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    milestoneTitle: {},
    subject: {
      // nt: MilestoneItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MinimizeCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    minimizedComment: {
      // nt: Minimizable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MoveProjectCardPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cardEdge: {
      // nt: ProjectCardEdge, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const MoveProjectColumnPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    columnEdge: {
      // nt: ProjectColumnEdge, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const MovedColumnsInProjectEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    previousProjectColumnName: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectCard: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
    projectColumnName: {},
  },
}

const OIDCProvider: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    externalIdentities: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        membersOnly: {
          nt: Boolean,
          it: [0],
        },
        userName: {
          nt: String,
          it: [0],
        },
      },
      // nt: ExternalIdentityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    providerType: {},
    tenantId: {},
  },
}

const OauthApplicationCreateAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    applicationUrl: {
      nt: URI,
    },
    callbackUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    rateLimit: {},
    state: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgAddBillingManagerAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    invitationEmail: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgAddMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    permission: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgBlockUserAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    blockedUser: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    blockedUserName: {},
    blockedUserResourcePath: {
      nt: URI,
    },
    blockedUserUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgConfigDisableCollaboratorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgConfigEnableCollaboratorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgCreateAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    billingPlan: {},
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgDisableOauthAppRestrictionsAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgDisableSamlAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    digestMethodUrl: {
      nt: URI,
    },
    id: {},
    issuerUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    signatureMethodUrl: {
      nt: URI,
    },
    singleSignOnUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgDisableTwoFactorRequirementAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgEnableOauthAppRestrictionsAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgEnableSamlAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    digestMethodUrl: {
      nt: URI,
    },
    id: {},
    issuerUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    signatureMethodUrl: {
      nt: URI,
    },
    singleSignOnUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgEnableTwoFactorRequirementAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgInviteMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    email: {},
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationInvitation: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgInviteToBusinessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgOauthAppAccessApprovedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgOauthAppAccessBlockedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgOauthAppAccessDeniedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgOauthAppAccessRequestedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgOauthAppAccessUnblockedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    oauthApplicationName: {},
    oauthApplicationResourcePath: {
      nt: URI,
    },
    oauthApplicationUrl: {
      nt: URI,
    },
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgRemoveBillingManagerAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    reason: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgRemoveMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    membershipTypes: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    reason: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgRemoveOutsideCollaboratorAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    membershipTypes: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    reason: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgRestoreMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    restoredCustomEmailRoutingsCount: {},
    restoredIssueAssignmentsCount: {},
    restoredMemberships: {
      // nt: OrgRestoreMemberAuditEntryMembership, <-- Assigned later to avoid potential circular dependency.
    },
    restoredMembershipsCount: {},
    restoredRepositoriesCount: {},
    restoredRepositoryStarsCount: {},
    restoredRepositoryWatchesCount: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgRestoreMemberMembershipOrganizationAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
  },
}

const OrgRestoreMemberMembershipRepositoryAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
  },
}

const OrgRestoreMemberMembershipTeamAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
  },
}

const OrgUnblockUserAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    blockedUser: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    blockedUserName: {},
    blockedUserResourcePath: {
      nt: URI,
    },
    blockedUserUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgUpdateDefaultRepositoryPermissionAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    permission: {},
    permissionWas: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgUpdateMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    permission: {},
    permissionWas: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const OrgUpdateMemberRepositoryCreationPermissionAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    canCreateRepositories: {},
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    canInviteOutsideCollaboratorsToRepositories: {},
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const Organization: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    announcement: {},
    announcementBanner: {
      // nt: AnnouncementBanner, <-- Assigned later to avoid potential circular dependency.
    },
    announcementCreatedAt: {
      nt: DateTime,
    },
    announcementExpiresAt: {
      nt: DateTime,
    },
    announcementUserDismissible: {},
    anyPinnableItems: {
      a: {
        type: {
          nt: PinnableItemType,
          it: [0],
        },
      },
    },
    archivedAt: {
      nt: DateTime,
    },
    auditLog: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: AuditLogOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: OrganizationAuditEntryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    description: {},
    descriptionHTML: {},
    domains: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        isApproved: {
          nt: Boolean,
          it: [0],
        },
        isVerified: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: VerifiableDomainOrder,
          it: [0],
        },
      },
      // nt: VerifiableDomainConnection, <-- Assigned later to avoid potential circular dependency.
    },
    email: {},
    enterpriseOwners: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrgEnterpriseOwnerOrder,
          it: [0],
        },
        organizationRole: {
          nt: RoleInOrganization,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: OrganizationEnterpriseOwnerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    estimatedNextSponsorsPayoutInCents: {},
    hasSponsorsListing: {},
    id: {},
    interactionAbility: {
      // nt: RepositoryInteractionAbility, <-- Assigned later to avoid potential circular dependency.
    },
    ipAllowListEnabledSetting: {},
    ipAllowListEntries: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IpAllowListEntryOrder,
          it: [0],
        },
      },
      // nt: IpAllowListEntryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    ipAllowListForInstalledAppsEnabledSetting: {},
    isSponsoredBy: {
      a: {
        accountLogin: {
          nt: String,
          it: [1],
        },
      },
    },
    isSponsoringViewer: {},
    isVerified: {},
    itemShowcase: {
      // nt: ProfileItemShowcase, <-- Assigned later to avoid potential circular dependency.
    },
    lifetimeReceivedSponsorshipValues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorAndLifetimeValueOrder,
          it: [0],
        },
      },
      // nt: SponsorAndLifetimeValueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    location: {},
    login: {},
    mannequins: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        orderBy: {
          nt: MannequinOrder,
          it: [0],
        },
      },
      // nt: MannequinConnection, <-- Assigned later to avoid potential circular dependency.
    },
    memberStatuses: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: UserStatusOrder,
          it: [0],
        },
      },
      // nt: UserStatusConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersCanForkPrivateRepositories: {},
    membersWithRole: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: OrganizationMemberConnection, <-- Assigned later to avoid potential circular dependency.
    },
    monthlyEstimatedSponsorsIncomeInCents: {},
    name: {},
    newTeamResourcePath: {
      nt: URI,
    },
    newTeamUrl: {
      nt: URI,
    },
    notificationDeliveryRestrictionEnabledSetting: {},
    organizationBillingEmail: {},
    packages: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        names: {
          nt: String,
          it: [0, [0]],
        },
        orderBy: {
          nt: PackageOrder,
          it: [0],
        },
        packageType: {
          nt: PackageType,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: PackageConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pendingMembers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnableItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        types: {
          nt: PinnableItemType,
          it: [0, [1]],
        },
      },
      // nt: PinnableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        types: {
          nt: PinnableItemType,
          it: [0, [1]],
        },
      },
      // nt: PinnableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedItemsRemaining: {},
    project: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectOrder,
          it: [0],
        },
        search: {
          nt: String,
          it: [0],
        },
        states: {
          nt: ProjectState,
          it: [0, [1]],
        },
      },
      // nt: ProjectConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectsResourcePath: {
      nt: URI,
    },
    projectsUrl: {
      nt: URI,
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    recentProjects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    repositories: {
      a: {
        affiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssuesEnabled: {
          nt: Boolean,
          it: [0],
        },
        isArchived: {
          nt: Boolean,
          it: [0],
        },
        isFork: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        ownerAffiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      a: {
        followRenames: {
          nt: Boolean,
          it: [0],
        },
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryDiscussionComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        onlyAnswers: {
          nt: Boolean,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: DiscussionCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryDiscussions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        answered: {
          nt: Boolean,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DiscussionOrder,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
        states: {
          nt: DiscussionState,
          it: [0, [1]],
        },
      },
      // nt: DiscussionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryMigrations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryMigrationOrder,
          it: [0],
        },
        repositoryName: {
          nt: String,
          it: [0],
        },
        state: {
          nt: MigrationState,
          it: [0],
        },
      },
      // nt: RepositoryMigrationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    requiresTwoFactorAuthentication: {},
    resourcePath: {
      nt: URI,
    },
    ruleset: {
      a: {
        databaseId: {
          nt: Int,
          it: [1],
        },
        includeParents: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
    rulesets: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeParents: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        targets: {
          nt: RepositoryRulesetTarget,
          it: [0, [1]],
        },
      },
      // nt: RepositoryRulesetConnection, <-- Assigned later to avoid potential circular dependency.
    },
    samlIdentityProvider: {
      // nt: OrganizationIdentityProvider, <-- Assigned later to avoid potential circular dependency.
    },
    sponsoring: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorOrder,
          it: [0],
        },
      },
      // nt: SponsorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorOrder,
          it: [0],
        },
        tierId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: SponsorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorsActivities: {
      a: {
        actions: {
          nt: SponsorsActivityAction,
          it: [0, [1]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeAsSponsor: {
          nt: Boolean,
          it: [0],
        },
        includePrivate: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorsActivityOrder,
          it: [0],
        },
        period: {
          nt: SponsorsActivityPeriod,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
        until: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: SponsorsActivityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipForViewerAsSponsor: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipForViewerAsSponsorable: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipNewsletters: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorshipNewsletterOrder,
          it: [0],
        },
      },
      // nt: SponsorshipNewsletterConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipsAsMaintainer: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includePrivate: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorshipOrder,
          it: [0],
        },
      },
      // nt: SponsorshipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipsAsSponsor: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        maintainerLogins: {
          nt: String,
          it: [0, [1]],
        },
        orderBy: {
          nt: SponsorshipOrder,
          it: [0],
        },
      },
      // nt: SponsorshipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    team: {
      a: {
        slug: {
          nt: String,
          it: [1],
        },
      },
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teams: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        ldapMapped: {
          nt: Boolean,
          it: [0],
        },
        notificationSetting: {
          nt: TeamNotificationSetting,
          it: [0],
        },
        orderBy: {
          nt: TeamOrder,
          it: [0],
        },
        privacy: {
          nt: TeamPrivacy,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: TeamRole,
          it: [0],
        },
        rootTeamsOnly: {
          nt: Boolean,
          it: [0],
        },
        userLogins: {
          nt: String,
          it: [0, [1]],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    teamsResourcePath: {
      nt: URI,
    },
    teamsUrl: {
      nt: URI,
    },
    totalSponsorshipAmountAsSponsorInCents: {
      a: {
        since: {
          nt: DateTime,
          it: [0],
        },
        sponsorableLogins: {
          nt: String,
          it: [0, [1]],
        },
        until: {
          nt: DateTime,
          it: [0],
        },
      },
    },
    twitterUsername: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerCanAdminister: {},
    viewerCanChangePinnedItems: {},
    viewerCanCreateProjects: {},
    viewerCanCreateRepositories: {},
    viewerCanCreateTeams: {},
    viewerCanSponsor: {},
    viewerIsAMember: {},
    viewerIsFollowing: {},
    viewerIsSponsoring: {},
    webCommitSignoffRequired: {},
    websiteUrl: {
      nt: URI,
    },
  },
}

const OrganizationAuditEntryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: OrganizationAuditEntryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: OrganizationAuditEntry, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const OrganizationAuditEntryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: OrganizationAuditEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const OrganizationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: OrganizationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const OrganizationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const OrganizationEnterpriseOwnerConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: OrganizationEnterpriseOwnerEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const OrganizationEnterpriseOwnerEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    organizationRole: {},
  },
}

const OrganizationIdentityProvider: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    digestMethod: {
      nt: URI,
    },
    externalIdentities: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        membersOnly: {
          nt: Boolean,
          it: [0],
        },
        userName: {
          nt: String,
          it: [0],
        },
      },
      // nt: ExternalIdentityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    idpCertificate: {
      nt: X509Certificate,
    },
    issuer: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    signatureMethod: {
      nt: URI,
    },
    ssoUrl: {
      nt: URI,
    },
  },
}

const OrganizationInvitation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    email: {},
    id: {},
    invitationSource: {},
    invitationType: {},
    invitee: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    inviter: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    inviterActor: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const OrganizationInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: OrganizationInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const OrganizationInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: OrganizationInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const OrganizationMemberConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: OrganizationMemberEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const OrganizationMemberEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    hasTwoFactorEnabled: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const OrganizationMigration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    failureReason: {},
    id: {},
    remainingRepositoriesCount: {},
    sourceOrgName: {},
    sourceOrgUrl: {
      nt: URI,
    },
    state: {},
    targetOrgName: {},
    totalRepositoriesCount: {},
  },
}

const OrganizationTeamsHovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    message: {},
    octicon: {},
    relevantTeams: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    teamsResourcePath: {
      nt: URI,
    },
    teamsUrl: {
      nt: URI,
    },
    totalTeamCount: {},
  },
}

const OrganizationsHovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    message: {},
    octicon: {},
    relevantOrganizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    totalOrganizationCount: {},
  },
}

const Package: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    latestVersion: {
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    packageType: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    statistics: {
      // nt: PackageStatistics, <-- Assigned later to avoid potential circular dependency.
    },
    version: {
      a: {
        version: {
          nt: String,
          it: [1],
        },
      },
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
    versions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: PackageVersionOrder,
          it: [0],
        },
      },
      // nt: PackageVersionConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PackageConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PackageEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Package, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PackageEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Package, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PackageFile: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    md5: {},
    name: {},
    packageVersion: {
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
    sha1: {},
    sha256: {},
    size: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const PackageFileConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PackageFileEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PackageFile, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PackageFileEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PackageFile, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PackageStatistics: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    downloadsTotalCount: {},
  },
}

const PackageTag: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    name: {},
    version: {
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PackageVersion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    files: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: PackageFileOrder,
          it: [0],
        },
      },
      // nt: PackageFileConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    package: {
      // nt: Package, <-- Assigned later to avoid potential circular dependency.
    },
    platform: {},
    preRelease: {},
    readme: {},
    release: {
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
    statistics: {
      // nt: PackageVersionStatistics, <-- Assigned later to avoid potential circular dependency.
    },
    summary: {},
    version: {},
  },
}

const PackageVersionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PackageVersionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PackageVersionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PackageVersionStatistics: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    downloadsTotalCount: {},
  },
}

const PageInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    endCursor: {},
    hasNextPage: {},
    hasPreviousPage: {},
    startCursor: {},
  },
}

const ParentIssueAddedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    parent: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ParentIssueRemovedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    parent: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PermissionSource: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    permission: {},
    roleName: {},
    source: {
      // nt: PermissionGranter, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinEnvironmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedEnvironment: {
      // nt: PinnedEnvironment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnableItemConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PinnableItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PinnableItem, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PinnableItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PinnableItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedDiscussion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    gradientStopColors: {},
    id: {},
    pattern: {},
    pinnedBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    preconfiguredGradient: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const PinnedDiscussionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PinnedDiscussionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PinnedDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PinnedDiscussionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PinnedDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedEnvironment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    position: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedEnvironmentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PinnedEnvironmentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PinnedEnvironment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PinnedEnvironmentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PinnedEnvironment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedIssue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    databaseId: {},
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PinnedIssueConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PinnedIssueEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PinnedIssue, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PinnedIssueEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PinnedIssue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PrivateRepositoryForkingDisableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const PrivateRepositoryForkingEnableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const ProfileItemShowcase: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    hasPinnedItems: {},
    items: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PinnableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Project: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    columns: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectColumnConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    id: {},
    name: {},
    number: {},
    owner: {
      // nt: ProjectOwner, <-- Assigned later to avoid potential circular dependency.
    },
    pendingCards: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        archivedStates: {
          nt: ProjectCardArchivedState,
          it: [0, [0]],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectCardConnection, <-- Assigned later to avoid potential circular dependency.
    },
    progress: {
      // nt: ProjectProgress, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    state: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerCanClose: {},
    viewerCanReopen: {},
    viewerCanUpdate: {},
  },
}

const ProjectCard: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    column: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
    content: {
      // nt: ProjectCardItem, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    id: {},
    isArchived: {},
    note: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    state: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const ProjectCardConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectCardEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectCardEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectColumn: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cards: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        archivedStates: {
          nt: ProjectCardArchivedState,
          it: [0, [0]],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectCardConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    name: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    purpose: {},
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const ProjectColumnConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectColumnEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectColumnEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectProgress: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    doneCount: {},
    donePercentage: {},
    enabled: {},
    inProgressCount: {},
    inProgressPercentage: {},
    todoCount: {},
    todoPercentage: {},
  },
}

const ProjectV2: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    field: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    fields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConfigurationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    items: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2ItemOrder,
          it: [0],
        },
      },
      // nt: ProjectV2ItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    number: {},
    owner: {
      // nt: ProjectV2Owner, <-- Assigned later to avoid potential circular dependency.
    },
    public: {},
    readme: {},
    repositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    shortDescription: {},
    statusUpdates: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2StatusOrder,
          it: [0],
        },
      },
      // nt: ProjectV2StatusUpdateConnection, <-- Assigned later to avoid potential circular dependency.
    },
    teams: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: TeamOrder,
          it: [0],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    template: {},
    title: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    view: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2View, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanClose: {},
    viewerCanReopen: {},
    viewerCanUpdate: {},
    views: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2ViewOrder,
          it: [0],
        },
      },
      // nt: ProjectV2ViewConnection, <-- Assigned later to avoid potential circular dependency.
    },
    workflow: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2Workflow, <-- Assigned later to avoid potential circular dependency.
    },
    workflows: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2WorkflowOrder,
          it: [0],
        },
      },
      // nt: ProjectV2WorkflowConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ActorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2ActorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2Actor, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2ActorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2Actor, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2Connection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2Edge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2Edge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2Field: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    dataType: {},
    databaseId: {},
    id: {},
    name: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2FieldConfigurationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2FieldConfigurationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2FieldConfigurationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2FieldConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2FieldEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2Field, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2FieldEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2Field, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2Item: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    content: {
      // nt: ProjectV2ItemContent, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    fieldValueByName: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: ProjectV2ItemFieldValue, <-- Assigned later to avoid potential circular dependency.
    },
    fieldValues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2ItemFieldValueOrder,
          it: [0],
        },
      },
      // nt: ProjectV2ItemFieldValueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    isArchived: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    type: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2ItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2ItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldDateValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    date: {
      nt: Date,
    },
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemFieldIterationValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    duration: {},
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    iterationId: {},
    startDate: {
      nt: Date,
    },
    title: {},
    titleHTML: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemFieldLabelValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldMilestoneValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    milestone: {
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldNumberValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    number: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemFieldPullRequestValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: PullRequestOrder,
          it: [0],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldRepositoryValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldReviewerValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    reviewers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: RequestedReviewerConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldSingleSelectValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    color: {},
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    description: {},
    descriptionHTML: {},
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    nameHTML: {},
    optionId: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemFieldTextValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
    text: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2ItemFieldUserValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    users: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ItemFieldValueConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2ItemFieldValueEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2ItemFieldValue, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2ItemFieldValueEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2ItemFieldValue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2IterationField: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    configuration: {
      // nt: ProjectV2IterationFieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    dataType: {},
    databaseId: {},
    id: {},
    name: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2IterationFieldConfiguration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    completedIterations: {
      // nt: ProjectV2IterationFieldIteration, <-- Assigned later to avoid potential circular dependency.
    },
    duration: {},
    iterations: {
      // nt: ProjectV2IterationFieldIteration, <-- Assigned later to avoid potential circular dependency.
    },
    startDay: {},
  },
}

const ProjectV2IterationFieldIteration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    duration: {},
    id: {},
    startDate: {
      nt: Date,
    },
    title: {},
    titleHTML: {},
  },
}

const ProjectV2SingleSelectField: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    dataType: {},
    databaseId: {},
    id: {},
    name: {},
    options: {
      a: {
        names: {
          nt: String,
          it: [0, [1]],
        },
      },
      // nt: ProjectV2SingleSelectFieldOption, <-- Assigned later to avoid potential circular dependency.
    },
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2SingleSelectFieldOption: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    color: {},
    description: {},
    descriptionHTML: {},
    id: {},
    name: {},
    nameHTML: {},
  },
}

const ProjectV2SortBy: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    direction: {},
    field: {
      // nt: ProjectV2Field, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2SortByConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2SortByEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2SortBy, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2SortByEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2SortBy, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2SortByField: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    direction: {},
    field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2SortByFieldConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2SortByFieldEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2SortByField, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2SortByFieldEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2SortByField, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2StatusUpdate: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    startDate: {
      nt: Date,
    },
    status: {},
    targetDate: {
      nt: Date,
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2StatusUpdateConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2StatusUpdateEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2StatusUpdate, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2StatusUpdateEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2StatusUpdate, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2View: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    fields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConfigurationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    filter: {},
    fullDatabaseId: {
      nt: BigInt,
    },
    groupBy: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConnection, <-- Assigned later to avoid potential circular dependency.
    },
    groupByFields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConfigurationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    layout: {},
    name: {},
    number: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    sortBy: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2SortByConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sortByFields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2SortByFieldConnection, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
    verticalGroupBy: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConnection, <-- Assigned later to avoid potential circular dependency.
    },
    verticalGroupByFields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConfigurationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    visibleFields: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2FieldOrder,
          it: [0],
        },
      },
      // nt: ProjectV2FieldConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2ViewConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2ViewEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2View, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2ViewEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2View, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ProjectV2Workflow: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    enabled: {},
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    name: {},
    number: {},
    project: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const ProjectV2WorkflowConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ProjectV2WorkflowEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ProjectV2Workflow, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ProjectV2WorkflowEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ProjectV2Workflow, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PropertyTargetDefinition: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    propertyValues: {},
    source: {},
  },
}

const PublicKey: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    accessedAt: {
      nt: DateTime,
    },
    createdAt: {
      nt: DateTime,
    },
    fingerprint: {},
    id: {},
    isReadOnly: {},
    key: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const PublicKeyConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PublicKeyEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PublicKey, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PublicKeyEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PublicKey, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PublishSponsorsTierPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    activeLockReason: {},
    additions: {},
    assignees: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    autoMergeRequest: {
      // nt: AutoMergeRequest, <-- Assigned later to avoid potential circular dependency.
    },
    baseRef: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    baseRefName: {},
    baseRefOid: {
      nt: GitObjectID,
    },
    baseRepository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    canBeRebased: {},
    changedFiles: {},
    checksResourcePath: {
      nt: URI,
    },
    checksUrl: {
      nt: URI,
    },
    closed: {},
    closedAt: {
      nt: DateTime,
    },
    closingIssuesReferences: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        userLinkedOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueCommentOrder,
          it: [0],
        },
      },
      // nt: IssueCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestCommitConnection, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    deletions: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    files: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestChangedFileConnection, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    headRef: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    headRefName: {},
    headRefOid: {
      nt: GitObjectID,
    },
    headRepository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    headRepositoryOwner: {
      // nt: RepositoryOwner, <-- Assigned later to avoid potential circular dependency.
    },
    hovercard: {
      a: {
        includeNotificationContexts: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Hovercard, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isCrossRepository: {},
    isDraft: {},
    isInMergeQueue: {},
    isMergeQueueEnabled: {},
    isReadByViewer: {},
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LabelOrder,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
    lastEditedAt: {
      nt: DateTime,
    },
    latestOpinionatedReviews: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        writersOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: PullRequestReviewConnection, <-- Assigned later to avoid potential circular dependency.
    },
    latestReviews: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewConnection, <-- Assigned later to avoid potential circular dependency.
    },
    locked: {},
    maintainerCanModify: {},
    mergeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    mergeQueue: {
      // nt: MergeQueue, <-- Assigned later to avoid potential circular dependency.
    },
    mergeQueueEntry: {
      // nt: MergeQueueEntry, <-- Assigned later to avoid potential circular dependency.
    },
    mergeStateStatus: {},
    mergeable: {},
    merged: {},
    mergedAt: {
      nt: DateTime,
    },
    mergedBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    milestone: {
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
    number: {},
    participants: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    permalink: {
      nt: URI,
    },
    potentialMergeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    projectCards: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        archivedStates: {
          nt: ProjectCardArchivedState,
          it: [0, [0]],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectCardConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeArchived: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2ItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    revertResourcePath: {
      nt: URI,
    },
    revertUrl: {
      nt: URI,
    },
    reviewDecision: {},
    reviewRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ReviewRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    reviewThreads: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewThreadConnection, <-- Assigned later to avoid potential circular dependency.
    },
    reviews: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        author: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        states: {
          nt: PullRequestReviewState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestReviewConnection, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    statusCheckRollup: {
      // nt: StatusCheckRollup, <-- Assigned later to avoid potential circular dependency.
    },
    suggestedReviewers: {
      // nt: SuggestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
    timeline: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: PullRequestTimelineConnection, <-- Assigned later to avoid potential circular dependency.
    },
    timelineItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        itemTypes: {
          nt: PullRequestTimelineItemsItemType,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
        skip: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestTimelineItemsConnection, <-- Assigned later to avoid potential circular dependency.
    },
    title: {},
    titleHTML: {
      nt: HTML,
    },
    totalCommentsCount: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanApplySuggestion: {},
    viewerCanClose: {},
    viewerCanDeleteHeadRef: {},
    viewerCanDisableAutoMerge: {},
    viewerCanEditFiles: {},
    viewerCanEnableAutoMerge: {},
    viewerCanLabel: {},
    viewerCanMergeAsAdmin: {},
    viewerCanReact: {},
    viewerCanReopen: {},
    viewerCanSubscribe: {},
    viewerCanUpdate: {},
    viewerCanUpdateBranch: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
    viewerLatestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    viewerLatestReviewRequest: {
      // nt: ReviewRequest, <-- Assigned later to avoid potential circular dependency.
    },
    viewerMergeBodyText: {
      a: {
        mergeType: {
          nt: PullRequestMergeMethod,
          it: [0],
        },
      },
    },
    viewerMergeHeadlineText: {
      a: {
        mergeType: {
          nt: PullRequestMergeMethod,
          it: [0],
        },
      },
    },
    viewerSubscription: {},
  },
}

const PullRequestChangedFile: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    additions: {},
    changeType: {},
    deletions: {},
    path: {},
    viewerViewedState: {},
  },
}

const PullRequestChangedFileConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestChangedFileEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestChangedFile, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestChangedFileEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestChangedFile, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestCommit: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const PullRequestCommitCommentThread: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    path: {},
    position: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestCommitConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestCommitEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestCommit, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestCommitEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestCommit, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestContributionsByRepository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedPullRequestContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allowedMergeMethods: {},
    dismissStaleReviewsOnPush: {},
    requireCodeOwnerReview: {},
    requireLastPushApproval: {},
    requiredApprovingReviewCount: {},
    requiredReviewThreadResolution: {},
  },
}

const PullRequestReview: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    authorCanPushToRepository: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    includesCreatedEdit: {},
    isMinimized: {},
    lastEditedAt: {
      nt: DateTime,
    },
    minimizedReason: {},
    onBehalfOf: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    publishedAt: {
      nt: DateTime,
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    state: {},
    submittedAt: {
      nt: DateTime,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMinimize: {},
    viewerCanReact: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const PullRequestReviewComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    diffHunk: {},
    draftedAt: {
      nt: DateTime,
    },
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    fullDatabaseId: {
      nt: BigInt,
    },
    id: {},
    includesCreatedEdit: {},
    isMinimized: {},
    lastEditedAt: {
      nt: DateTime,
    },
    line: {},
    minimizedReason: {},
    originalCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    originalLine: {},
    originalPosition: {},
    originalStartLine: {},
    outdated: {},
    path: {},
    position: {},
    publishedAt: {
      nt: DateTime,
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    replyTo: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    startLine: {},
    state: {},
    subjectType: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanMinimize: {},
    viewerCanReact: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const PullRequestReviewCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestReviewCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestReviewCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestReviewConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestReviewEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestReviewContributionsByRepository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contributions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ContributionOrder,
          it: [0],
        },
      },
      // nt: CreatedPullRequestReviewContributionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestReviewEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestReviewThread: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        skip: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    diffSide: {},
    id: {},
    isCollapsed: {},
    isOutdated: {},
    isResolved: {},
    line: {},
    originalLine: {},
    originalStartLine: {},
    path: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resolvedBy: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    startDiffSide: {},
    startLine: {},
    subjectType: {},
    viewerCanReply: {},
    viewerCanResolve: {},
    viewerCanUnresolve: {},
  },
}

const PullRequestReviewThreadConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestReviewThreadEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestReviewThread, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestReviewThreadEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestReviewThread, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestRevisionMarker: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    lastSeenCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestTemplate: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    filename: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestThread: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        skip: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PullRequestReviewCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    diffSide: {},
    id: {},
    isCollapsed: {},
    isOutdated: {},
    isResolved: {},
    line: {},
    path: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resolvedBy: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    startDiffSide: {},
    startLine: {},
    subjectType: {},
    viewerCanReply: {},
    viewerCanResolve: {},
    viewerCanUnresolve: {},
  },
}

const PullRequestTimelineConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestTimelineItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PullRequestTimelineItem, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PullRequestTimelineItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestTimelineItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PullRequestTimelineItemsConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PullRequestTimelineItemsEdge, <-- Assigned later to avoid potential circular dependency.
    },
    filteredCount: {},
    nodes: {
      // nt: PullRequestTimelineItems, <-- Assigned later to avoid potential circular dependency.
    },
    pageCount: {},
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const PullRequestTimelineItemsEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PullRequestTimelineItems, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Push: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    nextSha: {
      nt: GitObjectID,
    },
    permalink: {
      nt: URI,
    },
    previousSha: {
      nt: GitObjectID,
    },
    pusher: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const PushAllowance: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: PushAllowanceActor, <-- Assigned later to avoid potential circular dependency.
    },
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const PushAllowanceConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: PushAllowanceEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: PushAllowance, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const PushAllowanceEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: PushAllowance, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RateLimit: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cost: {},
    limit: {},
    nodeCount: {},
    remaining: {},
    resetAt: {
      nt: DateTime,
    },
    used: {},
  },
}

const ReactingUserConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReactingUserEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReactingUserEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    reactedAt: {
      nt: DateTime,
    },
  },
}

const Reaction: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    content: {},
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    reactable: {
      // nt: Reactable, <-- Assigned later to avoid potential circular dependency.
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReactionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReactionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Reaction, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    viewerHasReacted: {},
  },
}

const ReactionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Reaction, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReactionGroup: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    content: {},
    createdAt: {
      nt: DateTime,
    },
    reactors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ReactorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: Reactable, <-- Assigned later to avoid potential circular dependency.
    },
    users: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ReactingUserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerHasReacted: {},
  },
}

const ReactorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReactorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Reactor, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReactorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Reactor, <-- Assigned later to avoid potential circular dependency.
    },
    reactedAt: {
      nt: DateTime,
    },
  },
}

const ReadyForReviewEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
  },
}

const Ref: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    associatedPullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    compare: {
      a: {
        headRef: {
          nt: String,
          it: [1],
        },
      },
      // nt: Comparison, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    name: {},
    prefix: {},
    refUpdateRule: {
      // nt: RefUpdateRule, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    rules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryRuleOrder,
          it: [0],
        },
      },
      // nt: RepositoryRuleConnection, <-- Assigned later to avoid potential circular dependency.
    },
    target: {
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RefConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RefEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RefEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RefNameConditionTarget: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    exclude: {},
    include: {},
  },
}

const RefUpdateRule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allowsDeletions: {},
    allowsForcePushes: {},
    blocksCreations: {},
    pattern: {},
    requiredApprovingReviewCount: {},
    requiredStatusCheckContexts: {},
    requiresCodeOwnerReviews: {},
    requiresConversationResolution: {},
    requiresLinearHistory: {},
    requiresSignatures: {},
    viewerAllowedToDismissReviews: {},
    viewerCanPush: {},
  },
}

const ReferencedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    commitRepository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isCrossRepository: {},
    isDirectReference: {},
    subject: {
      // nt: ReferencedSubject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    identityProvider: {
      // nt: EnterpriseIdentityProvider, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RegenerateVerifiableDomainTokenPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    verificationToken: {},
  },
}

const RejectDeploymentsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    deployments: {
      // nt: Deployment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Release: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    description: {},
    descriptionHTML: {
      nt: HTML,
    },
    id: {},
    isDraft: {},
    isLatest: {},
    isPrerelease: {},
    mentions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    name: {},
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    releaseAssets: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        name: {
          nt: String,
          it: [0],
        },
      },
      // nt: ReleaseAssetConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    shortDescriptionHTML: {
      a: {
        limit: {
          nt: Int,
          it: [0],
        },
      },
      nt: HTML,
    },
    tag: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    tagCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    tagName: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerCanReact: {},
  },
}

const ReleaseAsset: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    contentType: {},
    createdAt: {
      nt: DateTime,
    },
    downloadCount: {},
    downloadUrl: {
      nt: URI,
    },
    id: {},
    name: {},
    release: {
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
    size: {},
    updatedAt: {
      nt: DateTime,
    },
    uploadedBy: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
  },
}

const ReleaseAssetConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReleaseAssetEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ReleaseAsset, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReleaseAssetEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ReleaseAsset, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReleaseConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReleaseEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReleaseEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveAssigneesFromAssignablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    assignable: {
      // nt: Assignable, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const RemoveEnterpriseAdminPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    admin: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveEnterpriseIdentityProviderPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    identityProvider: {
      // nt: EnterpriseIdentityProvider, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveEnterpriseMemberPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveEnterpriseOrganizationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveEnterpriseSupportEntitlementPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
  },
}

const RemoveLabelsFromLabelablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    labelable: {
      // nt: Labelable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveOutsideCollaboratorPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    removedUser: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveReactionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    reaction: {
      // nt: Reaction, <-- Assigned later to avoid potential circular dependency.
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {
      // nt: Reactable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveStarPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    starrable: {
      // nt: Starrable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveSubIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    subIssue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemoveUpvotePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    subject: {
      // nt: Votable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RemovedFromMergeQueueEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    beforeCommit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    enqueuer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    mergeQueue: {
      // nt: MergeQueue, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    reason: {},
  },
}

const RemovedFromProjectEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectColumnName: {},
  },
}

const RenamedTitleEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    currentTitle: {},
    id: {},
    previousTitle: {},
    subject: {
      // nt: RenamedTitleSubject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReopenDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReopenIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReopenPullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReopenedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    closable: {
      // nt: Closable, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    stateReason: {},
  },
}

const ReorderEnvironmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepoAccessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoAddMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoAddTopicAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    topic: {
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
    topicName: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoArchivedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoChangeMergeSettingAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isEnabled: {},
    mergeType: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigDisableAnonymousGitAccessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigDisableCollaboratorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigDisableContributorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigDisableSockpuppetDisallowedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigEnableAnonymousGitAccessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigEnableCollaboratorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigEnableContributorsOnlyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigEnableSockpuppetDisallowedAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigLockAnonymousGitAccessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoConfigUnlockAnonymousGitAccessAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepoCreateAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    forkParentName: {},
    forkSourceName: {},
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoDestroyAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoRemoveMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
    visibility: {},
  },
}

const RepoRemoveTopicAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    topic: {
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
    topicName: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const Repository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    allowUpdateBranch: {},
    archivedAt: {
      nt: DateTime,
    },
    assignableUsers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    autoMergeAllowed: {},
    branchProtectionRules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: BranchProtectionRuleConnection, <-- Assigned later to avoid potential circular dependency.
    },
    codeOfConduct: {
      // nt: CodeOfConduct, <-- Assigned later to avoid potential circular dependency.
    },
    codeowners: {
      a: {
        refName: {
          nt: String,
          it: [0],
        },
      },
      // nt: RepositoryCodeowners, <-- Assigned later to avoid potential circular dependency.
    },
    collaborators: {
      a: {
        affiliation: {
          nt: CollaboratorAffiliation,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        login: {
          nt: String,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: RepositoryCollaboratorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commitComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    contactLinks: {
      // nt: RepositoryContactLink, <-- Assigned later to avoid potential circular dependency.
    },
    contributingGuidelines: {
      // nt: ContributingGuidelines, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    defaultBranchRef: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    deleteBranchOnMerge: {},
    dependencyGraphManifests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        dependenciesAfter: {
          nt: String,
          it: [0],
        },
        dependenciesFirst: {
          nt: Int,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        withDependencies: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: DependencyGraphManifestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    deployKeys: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeployKeyConnection, <-- Assigned later to avoid potential circular dependency.
    },
    deployments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        environments: {
          nt: String,
          it: [0, [1]],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DeploymentOrder,
          it: [0],
        },
      },
      // nt: DeploymentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    description: {},
    descriptionHTML: {
      nt: HTML,
    },
    discussion: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
    discussionCategories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterByAssignable: {
          nt: Boolean,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DiscussionCategoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    discussionCategory: {
      a: {
        slug: {
          nt: String,
          it: [1],
        },
      },
      // nt: DiscussionCategory, <-- Assigned later to avoid potential circular dependency.
    },
    discussions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        answered: {
          nt: Boolean,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        categoryId: {
          nt: ID,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DiscussionOrder,
          it: [0],
        },
        states: {
          nt: DiscussionState,
          it: [0, [1]],
        },
      },
      // nt: DiscussionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    diskUsage: {},
    environment: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
    environments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        names: {
          nt: String,
          it: [0, [1]],
        },
        orderBy: {
          nt: Environments,
          it: [0],
        },
        pinnedEnvironmentFilter: {
          nt: EnvironmentPinnedFilterField,
          it: [0],
        },
      },
      // nt: EnvironmentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    forkCount: {},
    forkingAllowed: {},
    forks: {
      a: {
        affiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssuesEnabled: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        ownerAffiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    fundingLinks: {
      // nt: FundingLink, <-- Assigned later to avoid potential circular dependency.
    },
    hasDiscussionsEnabled: {},
    hasIssuesEnabled: {},
    hasProjectsEnabled: {},
    hasSponsorshipsEnabled: {},
    hasVulnerabilityAlertsEnabled: {},
    hasWikiEnabled: {},
    homepageUrl: {
      nt: URI,
    },
    id: {},
    interactionAbility: {
      // nt: RepositoryInteractionAbility, <-- Assigned later to avoid potential circular dependency.
    },
    isArchived: {},
    isBlankIssuesEnabled: {},
    isDisabled: {},
    isEmpty: {},
    isFork: {},
    isInOrganization: {},
    isLocked: {},
    isMirror: {},
    isPrivate: {},
    isSecurityPolicyEnabled: {},
    isTemplate: {},
    isUserConfigurationRepository: {},
    issue: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
    issueOrPullRequest: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    issueTemplates: {
      // nt: IssueTemplate, <-- Assigned later to avoid potential circular dependency.
    },
    issues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: IssueFilters,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: IssueState,
          it: [0, [1]],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    label: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
    labels: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LabelOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: LabelConnection, <-- Assigned later to avoid potential circular dependency.
    },
    languages: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: LanguageOrder,
          it: [0],
        },
      },
      // nt: LanguageConnection, <-- Assigned later to avoid potential circular dependency.
    },
    latestRelease: {
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
    licenseInfo: {
      // nt: License, <-- Assigned later to avoid potential circular dependency.
    },
    lockReason: {},
    mentionableUsers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    mergeCommitAllowed: {},
    mergeCommitMessage: {},
    mergeCommitTitle: {},
    mergeQueue: {
      a: {
        branch: {
          nt: String,
          it: [0],
        },
      },
      // nt: MergeQueue, <-- Assigned later to avoid potential circular dependency.
    },
    milestone: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Milestone, <-- Assigned later to avoid potential circular dependency.
    },
    milestones: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: MilestoneOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        states: {
          nt: MilestoneState,
          it: [0, [1]],
        },
      },
      // nt: MilestoneConnection, <-- Assigned later to avoid potential circular dependency.
    },
    mirrorUrl: {
      nt: URI,
    },
    name: {},
    nameWithOwner: {},
    object: {
      a: {
        expression: {
          nt: String,
          it: [0],
        },
        oid: {
          nt: GitObjectID,
          it: [0],
        },
      },
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
    openGraphImageUrl: {
      nt: URI,
    },
    owner: {
      // nt: RepositoryOwner, <-- Assigned later to avoid potential circular dependency.
    },
    packages: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        names: {
          nt: String,
          it: [0, [0]],
        },
        orderBy: {
          nt: PackageOrder,
          it: [0],
        },
        packageType: {
          nt: PackageType,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: PackageConnection, <-- Assigned later to avoid potential circular dependency.
    },
    parent: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedDiscussions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PinnedDiscussionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedEnvironments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: PinnedEnvironmentOrder,
          it: [0],
        },
      },
      // nt: PinnedEnvironmentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedIssues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PinnedIssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    planFeatures: {
      // nt: RepositoryPlanFeatures, <-- Assigned later to avoid potential circular dependency.
    },
    primaryLanguage: {
      // nt: Language, <-- Assigned later to avoid potential circular dependency.
    },
    project: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectOrder,
          it: [0],
        },
        search: {
          nt: String,
          it: [0],
        },
        states: {
          nt: ProjectState,
          it: [0, [1]],
        },
      },
      // nt: ProjectConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectsResourcePath: {
      nt: URI,
    },
    projectsUrl: {
      nt: URI,
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequest: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestTemplates: {
      // nt: PullRequestTemplate, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pushedAt: {
      nt: DateTime,
    },
    rebaseMergeAllowed: {},
    recentProjects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    ref: {
      a: {
        qualifiedName: {
          nt: String,
          it: [1],
        },
      },
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
    refs: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        direction: {
          nt: OrderDirection,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RefOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        refPrefix: {
          nt: String,
          it: [1],
        },
      },
      // nt: RefConnection, <-- Assigned later to avoid potential circular dependency.
    },
    release: {
      a: {
        tagName: {
          nt: String,
          it: [1],
        },
      },
      // nt: Release, <-- Assigned later to avoid potential circular dependency.
    },
    releases: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReleaseOrder,
          it: [0],
        },
      },
      // nt: ReleaseConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryTopics: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: RepositoryTopicConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    ruleset: {
      a: {
        databaseId: {
          nt: Int,
          it: [1],
        },
        includeParents: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
    rulesets: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeParents: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        targets: {
          nt: RepositoryRulesetTarget,
          it: [0, [1]],
        },
      },
      // nt: RepositoryRulesetConnection, <-- Assigned later to avoid potential circular dependency.
    },
    securityPolicyUrl: {
      nt: URI,
    },
    shortDescriptionHTML: {
      a: {
        limit: {
          nt: Int,
          it: [0],
        },
      },
      nt: HTML,
    },
    squashMergeAllowed: {},
    squashMergeCommitMessage: {},
    squashMergeCommitTitle: {},
    squashPrTitleUsedAsDefault: {},
    sshUrl: {
      nt: GitSSHRemote,
    },
    stargazerCount: {},
    stargazers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: StarOrder,
          it: [0],
        },
      },
      // nt: StargazerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    submodules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: SubmoduleConnection, <-- Assigned later to avoid potential circular dependency.
    },
    tempCloneToken: {},
    templateRepository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    usesCustomOpenGraphImage: {},
    viewerCanAdminister: {},
    viewerCanCreateProjects: {},
    viewerCanSubscribe: {},
    viewerCanUpdateTopics: {},
    viewerDefaultCommitEmail: {},
    viewerDefaultMergeMethod: {},
    viewerHasStarred: {},
    viewerPermission: {},
    viewerPossibleCommitEmails: {},
    viewerSubscription: {},
    visibility: {},
    vulnerabilityAlert: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: RepositoryVulnerabilityAlert, <-- Assigned later to avoid potential circular dependency.
    },
    vulnerabilityAlerts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        dependencyScopes: {
          nt: RepositoryVulnerabilityAlertDependencyScope,
          it: [0, [1]],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        states: {
          nt: RepositoryVulnerabilityAlertState,
          it: [0, [1]],
        },
      },
      // nt: RepositoryVulnerabilityAlertConnection, <-- Assigned later to avoid potential circular dependency.
    },
    watchers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserConnection, <-- Assigned later to avoid potential circular dependency.
    },
    webCommitSignoffRequired: {},
  },
}

const RepositoryCodeowners: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    errors: {
      // nt: RepositoryCodeownersError, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryCodeownersError: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    column: {},
    kind: {},
    line: {},
    message: {},
    path: {},
    source: {},
    suggestion: {},
  },
}

const RepositoryCollaboratorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryCollaboratorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryCollaboratorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    permission: {},
    permissionSources: {
      // nt: PermissionSource, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    totalDiskUsage: {},
  },
}

const RepositoryContactLink: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    about: {},
    name: {},
    url: {
      nt: URI,
    },
  },
}

const RepositoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryIdConditionTarget: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    repositoryIds: {},
  },
}

const RepositoryInteractionAbility: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    expiresAt: {
      nt: DateTime,
    },
    limit: {},
    origin: {},
  },
}

const RepositoryInvitation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    email: {},
    id: {},
    invitee: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    inviter: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    permalink: {
      nt: URI,
    },
    permission: {},
    repository: {
      // nt: RepositoryInfo, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryInvitationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryInvitationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryInvitationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryInvitation, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryMigration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    continueOnError: {},
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    failureReason: {},
    id: {},
    migrationLogUrl: {
      nt: URI,
    },
    migrationSource: {
      // nt: MigrationSource, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    sourceUrl: {
      nt: URI,
    },
    state: {},
    warningsCount: {},
  },
}

const RepositoryMigrationConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryMigrationEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryMigration, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryMigrationEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryMigration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryNameConditionTarget: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    exclude: {},
    include: {},
    protected: {},
  },
}

const RepositoryPlanFeatures: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    codeowners: {},
    draftPullRequests: {},
    maximumAssignees: {},
    maximumManualReviewRequests: {},
    teamReviewRequests: {},
  },
}

const RepositoryPropertyConditionTarget: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    exclude: {
      // nt: PropertyTargetDefinition, <-- Assigned later to avoid potential circular dependency.
    },
    include: {
      // nt: PropertyTargetDefinition, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryRule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    parameters: {
      // nt: RuleParameters, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryRuleset: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
    type: {},
  },
}

const RepositoryRuleConditions: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    refName: {
      // nt: RefNameConditionTarget, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryId: {
      // nt: RepositoryIdConditionTarget, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {
      // nt: RepositoryNameConditionTarget, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryProperty: {
      // nt: RepositoryPropertyConditionTarget, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryRuleConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryRuleEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryRule, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryRuleEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryRule, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryRuleset: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    bypassActors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: RepositoryRulesetBypassActorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    conditions: {
      // nt: RepositoryRuleConditions, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    enforcement: {},
    id: {},
    name: {},
    rules: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        type: {
          nt: RepositoryRuleType,
          it: [0],
        },
      },
      // nt: RepositoryRuleConnection, <-- Assigned later to avoid potential circular dependency.
    },
    source: {
      // nt: RuleSource, <-- Assigned later to avoid potential circular dependency.
    },
    target: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const RepositoryRulesetBypassActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: BypassActor, <-- Assigned later to avoid potential circular dependency.
    },
    bypassMode: {},
    deployKey: {},
    enterpriseOwner: {},
    id: {},
    organizationAdmin: {},
    repositoryRoleDatabaseId: {},
    repositoryRoleName: {},
    repositoryRuleset: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryRulesetBypassActorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryRulesetBypassActorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryRulesetBypassActor, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryRulesetBypassActorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryRulesetBypassActor, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryRulesetConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryRulesetEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryRulesetEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryTopic: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    resourcePath: {
      nt: URI,
    },
    topic: {
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
  },
}

const RepositoryTopicConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryTopicEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryTopic, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryTopicEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryTopic, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RepositoryVisibilityChangeDisableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepositoryVisibilityChangeEnableAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    enterpriseResourcePath: {
      nt: URI,
    },
    enterpriseSlug: {},
    enterpriseUrl: {
      nt: URI,
    },
    id: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const RepositoryVulnerabilityAlert: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    autoDismissedAt: {
      nt: DateTime,
    },
    createdAt: {
      nt: DateTime,
    },
    dependabotUpdate: {
      // nt: DependabotUpdate, <-- Assigned later to avoid potential circular dependency.
    },
    dependencyScope: {},
    dismissComment: {},
    dismissReason: {},
    dismissedAt: {
      nt: DateTime,
    },
    dismisser: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    fixedAt: {
      nt: DateTime,
    },
    id: {},
    number: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    securityAdvisory: {
      // nt: SecurityAdvisory, <-- Assigned later to avoid potential circular dependency.
    },
    securityVulnerability: {
      // nt: SecurityVulnerability, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    vulnerableManifestFilename: {},
    vulnerableManifestPath: {},
    vulnerableRequirements: {},
  },
}

const RepositoryVulnerabilityAlertConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RepositoryVulnerabilityAlertEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RepositoryVulnerabilityAlert, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RepositoryVulnerabilityAlertEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RepositoryVulnerabilityAlert, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReprioritizeSubIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RequestReviewsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    requestedReviewersEdge: {
      // nt: UserEdge, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RequestedReviewerConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: RequestedReviewerEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: RequestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const RequestedReviewerEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: RequestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RequiredDeploymentsParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    requiredDeploymentEnvironments: {},
  },
}

const RequiredStatusCheckDescription: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    app: {
      // nt: App, <-- Assigned later to avoid potential circular dependency.
    },
    context: {},
  },
}

const RequiredStatusChecksParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    doNotEnforceOnCreate: {},
    requiredStatusChecks: {
      // nt: StatusCheckConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
    strictRequiredStatusChecksPolicy: {},
  },
}

const RerequestCheckSuitePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkSuite: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const ResolveReviewThreadPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    thread: {
      // nt: PullRequestReviewThread, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RestrictedContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isRestricted: {},
    occurredAt: {
      nt: DateTime,
    },
    resourcePath: {
      nt: URI,
    },
    url: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RetireSponsorsTierPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RevertPullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    revertPullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewDismissalAllowance: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: ReviewDismissalAllowanceActor, <-- Assigned later to avoid potential circular dependency.
    },
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
  },
}

const ReviewDismissalAllowanceConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReviewDismissalAllowanceEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ReviewDismissalAllowance, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReviewDismissalAllowanceEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ReviewDismissalAllowance, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewDismissedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    dismissalMessage: {},
    dismissalMessageHTML: {},
    id: {},
    previousReviewState: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequestCommit: {
      // nt: PullRequestCommit, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    review: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
  },
}

const ReviewRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    asCodeOwner: {},
    databaseId: {},
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    requestedReviewer: {
      // nt: RequestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewRequestConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: ReviewRequestEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: ReviewRequest, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const ReviewRequestEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: ReviewRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewRequestRemovedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    requestedReviewer: {
      // nt: RequestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewRequestedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    requestedReviewer: {
      // nt: RequestedReviewer, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ReviewStatusHovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    message: {},
    octicon: {},
    reviewDecision: {},
  },
}

const RevokeEnterpriseOrganizationsMigratorRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const RevokeMigratorRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    success: {},
  },
}

const SavedReply: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    databaseId: {},
    id: {},
    title: {},
    user: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SavedReplyConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SavedReplyEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SavedReply, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SavedReplyEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SavedReply, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SearchResultItemConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    codeCount: {},
    discussionCount: {},
    edges: {
      // nt: SearchResultItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    issueCount: {},
    nodes: {
      // nt: SearchResultItem, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryCount: {},
    userCount: {},
    wikiCount: {},
  },
}

const SearchResultItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SearchResultItem, <-- Assigned later to avoid potential circular dependency.
    },
    textMatches: {
      // nt: TextMatch, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SecurityAdvisory: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    classification: {},
    cvss: {
      // nt: CVSS, <-- Assigned later to avoid potential circular dependency.
    },
    cvssSeverities: {
      // nt: CvssSeverities, <-- Assigned later to avoid potential circular dependency.
    },
    cwes: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CWEConnection, <-- Assigned later to avoid potential circular dependency.
    },
    databaseId: {},
    description: {},
    epss: {
      // nt: EPSS, <-- Assigned later to avoid potential circular dependency.
    },
    ghsaId: {},
    id: {},
    identifiers: {
      // nt: SecurityAdvisoryIdentifier, <-- Assigned later to avoid potential circular dependency.
    },
    notificationsPermalink: {
      nt: URI,
    },
    origin: {},
    permalink: {
      nt: URI,
    },
    publishedAt: {
      nt: DateTime,
    },
    references: {
      // nt: SecurityAdvisoryReference, <-- Assigned later to avoid potential circular dependency.
    },
    severity: {},
    summary: {},
    updatedAt: {
      nt: DateTime,
    },
    vulnerabilities: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        classifications: {
          nt: SecurityAdvisoryClassification,
          it: [0, [1]],
        },
        ecosystem: {
          nt: SecurityAdvisoryEcosystem,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SecurityVulnerabilityOrder,
          it: [0],
        },
        package: {
          nt: String,
          it: [0],
        },
        severities: {
          nt: SecurityAdvisorySeverity,
          it: [0, [1]],
        },
      },
      // nt: SecurityVulnerabilityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    withdrawnAt: {
      nt: DateTime,
    },
  },
}

const SecurityAdvisoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SecurityAdvisoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SecurityAdvisory, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SecurityAdvisoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SecurityAdvisory, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SecurityAdvisoryIdentifier: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    type: {},
    value: {},
  },
}

const SecurityAdvisoryPackage: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ecosystem: {},
    name: {},
  },
}

const SecurityAdvisoryPackageVersion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    identifier: {},
  },
}

const SecurityAdvisoryReference: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    url: {
      nt: URI,
    },
  },
}

const SecurityVulnerability: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    advisory: {
      // nt: SecurityAdvisory, <-- Assigned later to avoid potential circular dependency.
    },
    firstPatchedVersion: {
      // nt: SecurityAdvisoryPackageVersion, <-- Assigned later to avoid potential circular dependency.
    },
    package: {
      // nt: SecurityAdvisoryPackage, <-- Assigned later to avoid potential circular dependency.
    },
    severity: {},
    updatedAt: {
      nt: DateTime,
    },
    vulnerableVersionRange: {},
  },
}

const SecurityVulnerabilityConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SecurityVulnerabilityEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SecurityVulnerability, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SecurityVulnerabilityEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SecurityVulnerability, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SetEnterpriseIdentityProviderPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    identityProvider: {
      // nt: EnterpriseIdentityProvider, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SetOrganizationInteractionLimitPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SetRepositoryInteractionLimitPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SetUserInteractionLimitPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SmimeSignature: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    email: {},
    isValid: {},
    payload: {},
    signature: {},
    signer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    verifiedAt: {
      nt: DateTime,
    },
    wasSignedByGitHub: {},
  },
}

const SocialAccount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    displayName: {},
    provider: {},
    url: {
      nt: URI,
    },
  },
}

const SocialAccountConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SocialAccountEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SocialAccount, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SocialAccountEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SocialAccount, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorAndLifetimeValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    amountInCents: {},
    formattedAmount: {},
    sponsor: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorable: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorAndLifetimeValueConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorAndLifetimeValueEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SponsorAndLifetimeValue, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorAndLifetimeValueEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SponsorAndLifetimeValue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Sponsor, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Sponsor, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorableItemConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorableItemEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SponsorableItem, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorableItemEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SponsorableItem, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorsActivity: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    currentPrivacyLevel: {},
    id: {},
    paymentSource: {},
    previousSponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
    sponsor: {
      // nt: Sponsor, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorable: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorsTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
    timestamp: {
      nt: DateTime,
    },
    viaBulkSponsorship: {},
  },
}

const SponsorsActivityConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorsActivityEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SponsorsActivity, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorsActivityEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SponsorsActivity, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorsGoal: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    description: {},
    kind: {},
    percentComplete: {},
    targetValue: {},
    title: {},
  },
}

const SponsorsListing: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    activeGoal: {
      // nt: SponsorsGoal, <-- Assigned later to avoid potential circular dependency.
    },
    activeStripeConnectAccount: {
      // nt: StripeConnectAccount, <-- Assigned later to avoid potential circular dependency.
    },
    billingCountryOrRegion: {},
    contactEmailAddress: {},
    createdAt: {
      nt: DateTime,
    },
    dashboardResourcePath: {
      nt: URI,
    },
    dashboardUrl: {
      nt: URI,
    },
    featuredItems: {
      a: {
        featureableTypes: {
          nt: SponsorsListingFeaturedItemFeatureableType,
          it: [0, [1]],
        },
      },
      // nt: SponsorsListingFeaturedItem, <-- Assigned later to avoid potential circular dependency.
    },
    fiscalHost: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    fullDescription: {},
    fullDescriptionHTML: {
      nt: HTML,
    },
    id: {},
    isPublic: {},
    name: {},
    nextPayoutDate: {
      nt: Date,
    },
    residenceCountryOrRegion: {},
    resourcePath: {
      nt: URI,
    },
    shortDescription: {},
    slug: {},
    sponsorable: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
    tiers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeUnpublished: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorsTierOrder,
          it: [0],
        },
      },
      // nt: SponsorsTierConnection, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
  },
}

const SponsorsListingFeaturedItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    description: {},
    featureable: {
      // nt: SponsorsListingFeatureableItem, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    position: {},
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const SponsorsTier: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    adminInfo: {
      // nt: SponsorsTierAdminInfo, <-- Assigned later to avoid potential circular dependency.
    },
    closestLesserValueTier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    description: {},
    descriptionHTML: {
      nt: HTML,
    },
    id: {},
    isCustomAmount: {},
    isOneTime: {},
    monthlyPriceInCents: {},
    monthlyPriceInDollars: {},
    name: {},
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
  },
}

const SponsorsTierAdminInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isDraft: {},
    isPublished: {},
    isRetired: {},
    sponsorships: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includePrivate: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorshipOrder,
          it: [0],
        },
      },
      // nt: SponsorshipConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorsTierConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorsTierEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorsTierEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Sponsorship: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isActive: {},
    isOneTimePayment: {},
    isSponsorOptedIntoEmail: {},
    maintainer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    paymentSource: {},
    privacyLevel: {},
    sponsor: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorEntity: {
      // nt: Sponsor, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorable: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
    tier: {
      // nt: SponsorsTier, <-- Assigned later to avoid potential circular dependency.
    },
    tierSelectedAt: {
      nt: DateTime,
    },
  },
}

const SponsorshipConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorshipEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
    totalRecurringMonthlyPriceInCents: {},
    totalRecurringMonthlyPriceInDollars: {},
  },
}

const SponsorshipEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SponsorshipNewsletter: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    body: {},
    createdAt: {
      nt: DateTime,
    },
    id: {},
    isPublished: {},
    sponsorable: {
      // nt: Sponsorable, <-- Assigned later to avoid potential circular dependency.
    },
    subject: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const SponsorshipNewsletterConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SponsorshipNewsletterEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: SponsorshipNewsletter, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SponsorshipNewsletterEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: SponsorshipNewsletter, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SshSignature: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    email: {},
    isValid: {},
    keyFingerprint: {},
    payload: {},
    signature: {},
    signer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    verifiedAt: {
      nt: DateTime,
    },
    wasSignedByGitHub: {},
  },
}

const StargazerConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: StargazerEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const StargazerEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    starredAt: {
      nt: DateTime,
    },
  },
}

const StarredRepositoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: StarredRepositoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    isOverLimit: {},
    nodes: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const StarredRepositoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    starredAt: {
      nt: DateTime,
    },
  },
}

const StartOrganizationMigrationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    orgMigration: {
      // nt: OrganizationMigration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const StartRepositoryMigrationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repositoryMigration: {
      // nt: RepositoryMigration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Status: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    combinedContexts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: StatusCheckRollupContextConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    context: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: StatusContext, <-- Assigned later to avoid potential circular dependency.
    },
    contexts: {
      // nt: StatusContext, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    state: {},
  },
}

const StatusCheckConfiguration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    context: {},
    integrationId: {},
  },
}

const StatusCheckRollup: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    contexts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: StatusCheckRollupContextConnection, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    state: {},
  },
}

const StatusCheckRollupContextConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkRunCount: {},
    checkRunCountsByState: {
      // nt: CheckRunStateCount, <-- Assigned later to avoid potential circular dependency.
    },
    edges: {
      // nt: StatusCheckRollupContextEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: StatusCheckRollupContext, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    statusContextCount: {},
    statusContextCountsByState: {
      // nt: StatusContextStateCount, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const StatusCheckRollupContextEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: StatusCheckRollupContext, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const StatusContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    commit: {
      // nt: Commit, <-- Assigned later to avoid potential circular dependency.
    },
    context: {},
    createdAt: {
      nt: DateTime,
    },
    creator: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    description: {},
    id: {},
    isRequired: {
      a: {
        pullRequestId: {
          nt: ID,
          it: [0],
        },
        pullRequestNumber: {
          nt: Int,
          it: [0],
        },
      },
    },
    state: {},
    targetUrl: {
      nt: URI,
    },
  },
}

const StatusContextStateCount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    count: {},
    state: {},
  },
}

const StripeConnectAccount: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    accountId: {},
    billingCountryOrRegion: {},
    countryOrRegion: {},
    isActive: {},
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
    stripeDashboardUrl: {
      nt: URI,
    },
  },
}

const SubIssueAddedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    subIssue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SubIssueRemovedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    subIssue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SubIssuesSummary: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    completed: {},
    percentCompleted: {},
    total: {},
  },
}

const SubmitPullRequestReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Submodule: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    branch: {},
    gitUrl: {
      nt: URI,
    },
    name: {},
    nameRaw: {
      nt: Base64String,
    },
    path: {},
    pathRaw: {
      nt: Base64String,
    },
    subprojectCommitOid: {
      nt: GitObjectID,
    },
  },
}

const SubmoduleConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: SubmoduleEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Submodule, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const SubmoduleEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Submodule, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SubscribedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    subscribable: {
      // nt: Subscribable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const SuggestedReviewer: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    isAuthor: {},
    isCommenter: {},
    reviewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Tag: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    abbreviatedOid: {},
    commitResourcePath: {
      nt: URI,
    },
    commitUrl: {
      nt: URI,
    },
    id: {},
    message: {},
    name: {},
    oid: {
      nt: GitObjectID,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    tagger: {
      // nt: GitActor, <-- Assigned later to avoid potential circular dependency.
    },
    target: {
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TagNamePatternParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    name: {},
    negate: {},
    operator: {},
    pattern: {},
  },
}

const Team: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ancestors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    childTeams: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        immediateOnly: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: TeamOrder,
          it: [0],
        },
        userLogins: {
          nt: String,
          it: [0, [1]],
        },
      },
      // nt: TeamConnection, <-- Assigned later to avoid potential circular dependency.
    },
    combinedSlug: {},
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    description: {},
    discussion: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
    discussions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        isPinned: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: TeamDiscussionOrder,
          it: [0],
        },
      },
      // nt: TeamDiscussionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    discussionsResourcePath: {
      nt: URI,
    },
    discussionsUrl: {
      nt: URI,
    },
    editTeamResourcePath: {
      nt: URI,
    },
    editTeamUrl: {
      nt: URI,
    },
    id: {},
    invitations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: OrganizationInvitationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    memberStatuses: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: UserStatusOrder,
          it: [0],
        },
      },
      // nt: UserStatusConnection, <-- Assigned later to avoid potential circular dependency.
    },
    members: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        membership: {
          nt: TeamMembershipType,
          it: [0],
        },
        orderBy: {
          nt: TeamMemberOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
        role: {
          nt: TeamMemberRole,
          it: [0],
        },
      },
      // nt: TeamMemberConnection, <-- Assigned later to avoid potential circular dependency.
    },
    membersResourcePath: {
      nt: URI,
    },
    membersUrl: {
      nt: URI,
    },
    name: {},
    newTeamResourcePath: {
      nt: URI,
    },
    newTeamUrl: {
      nt: URI,
    },
    notificationSetting: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    parentTeam: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    privacy: {},
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: ProjectV2Filters,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    repositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: TeamRepositoryOrder,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: TeamRepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoriesResourcePath: {
      nt: URI,
    },
    repositoriesUrl: {
      nt: URI,
    },
    resourcePath: {
      nt: URI,
    },
    reviewRequestDelegationAlgorithm: {},
    reviewRequestDelegationEnabled: {},
    reviewRequestDelegationMemberCount: {},
    reviewRequestDelegationNotifyTeam: {},
    slug: {},
    teamsResourcePath: {
      nt: URI,
    },
    teamsUrl: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    viewerCanAdminister: {},
    viewerCanSubscribe: {},
    viewerSubscription: {},
  },
}

const TeamAddMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isLdapMapped: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const TeamAddRepositoryAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isLdapMapped: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const TeamChangeParentTeamAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isLdapMapped: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    parentTeam: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    parentTeamName: {},
    parentTeamNameWas: {},
    parentTeamResourcePath: {
      nt: URI,
    },
    parentTeamUrl: {
      nt: URI,
    },
    parentTeamWas: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    parentTeamWasResourcePath: {
      nt: URI,
    },
    parentTeamWasUrl: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const TeamConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: TeamEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const TeamDiscussion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    bodyVersion: {},
    comments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        fromComment: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: TeamDiscussionCommentOrder,
          it: [0],
        },
      },
      // nt: TeamDiscussionCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    commentsResourcePath: {
      nt: URI,
    },
    commentsUrl: {
      nt: URI,
    },
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    isPinned: {},
    isPrivate: {},
    lastEditedAt: {
      nt: DateTime,
    },
    number: {},
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    title: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanPin: {},
    viewerCanReact: {},
    viewerCanSubscribe: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
    viewerSubscription: {},
  },
}

const TeamDiscussionComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    author: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    authorAssociation: {},
    body: {},
    bodyHTML: {
      nt: HTML,
    },
    bodyText: {},
    bodyVersion: {},
    createdAt: {
      nt: DateTime,
    },
    createdViaEmail: {},
    databaseId: {},
    discussion: {
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    includesCreatedEdit: {},
    lastEditedAt: {
      nt: DateTime,
    },
    number: {},
    publishedAt: {
      nt: DateTime,
    },
    reactionGroups: {
      // nt: ReactionGroup, <-- Assigned later to avoid potential circular dependency.
    },
    reactions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        content: {
          nt: ReactionContent,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ReactionOrder,
          it: [0],
        },
      },
      // nt: ReactionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userContentEdits: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserContentEditConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerCanDelete: {},
    viewerCanReact: {},
    viewerCanUpdate: {},
    viewerCannotUpdateReasons: {},
    viewerDidAuthor: {},
  },
}

const TeamDiscussionCommentConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: TeamDiscussionCommentEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: TeamDiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const TeamDiscussionCommentEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: TeamDiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TeamDiscussionConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: TeamDiscussionEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const TeamDiscussionEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TeamEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TeamMemberConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: TeamMemberEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const TeamMemberEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    memberAccessResourcePath: {
      nt: URI,
    },
    memberAccessUrl: {
      nt: URI,
    },
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    role: {},
  },
}

const TeamRemoveMemberAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isLdapMapped: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const TeamRemoveRepositoryAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    action: {},
    actor: {
      // nt: AuditEntryActor, <-- Assigned later to avoid potential circular dependency.
    },
    actorIp: {},
    actorLocation: {
      // nt: ActorLocation, <-- Assigned later to avoid potential circular dependency.
    },
    actorLogin: {},
    actorResourcePath: {
      nt: URI,
    },
    actorUrl: {
      nt: URI,
    },
    createdAt: {
      nt: PreciseDateTime,
    },
    id: {},
    isLdapMapped: {},
    operationType: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationName: {},
    organizationResourcePath: {
      nt: URI,
    },
    organizationUrl: {
      nt: URI,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryName: {},
    repositoryResourcePath: {
      nt: URI,
    },
    repositoryUrl: {
      nt: URI,
    },
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
    teamName: {},
    teamResourcePath: {
      nt: URI,
    },
    teamUrl: {
      nt: URI,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    userLogin: {},
    userResourcePath: {
      nt: URI,
    },
    userUrl: {
      nt: URI,
    },
  },
}

const TeamRepositoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: TeamRepositoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const TeamRepositoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    permission: {},
  },
}

const TextMatch: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    fragment: {},
    highlights: {
      // nt: TextMatchHighlight, <-- Assigned later to avoid potential circular dependency.
    },
    property: {},
  },
}

const TextMatchHighlight: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    beginIndice: {},
    endIndice: {},
    text: {},
  },
}

const Topic: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    name: {},
    relatedTopics: {
      a: {
        first: {
          nt: Int,
          it: [0],
        },
      },
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
    repositories: {
      a: {
        affiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssuesEnabled: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        ownerAffiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
        sponsorableOnly: {
          nt: Boolean,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    stargazerCount: {},
    stargazers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: StarOrder,
          it: [0],
        },
      },
      // nt: StargazerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    viewerHasStarred: {},
  },
}

const TransferEnterpriseOrganizationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TransferIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TransferredEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    fromRepository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Tree: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    abbreviatedOid: {},
    commitResourcePath: {
      nt: URI,
    },
    commitUrl: {
      nt: URI,
    },
    entries: {
      // nt: TreeEntry, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    oid: {
      nt: GitObjectID,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const TreeEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    extension: {},
    isGenerated: {},
    language: {
      // nt: Language, <-- Assigned later to avoid potential circular dependency.
    },
    lineCount: {},
    mode: {},
    name: {},
    nameRaw: {
      nt: Base64String,
    },
    object: {
      // nt: GitObject, <-- Assigned later to avoid potential circular dependency.
    },
    oid: {
      nt: GitObjectID,
    },
    path: {},
    pathRaw: {
      nt: Base64String,
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    size: {},
    submodule: {
      // nt: Submodule, <-- Assigned later to avoid potential circular dependency.
    },
    type: {},
  },
}

const UnarchiveProjectV2ItemPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnarchiveRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnassignedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    assignable: {
      // nt: Assignable, <-- Assigned later to avoid potential circular dependency.
    },
    assignee: {
      // nt: Assignee, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnfollowOrganizationPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnfollowUserPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnknownSignature: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    email: {},
    isValid: {},
    payload: {},
    signature: {},
    signer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    verifiedAt: {
      nt: DateTime,
    },
    wasSignedByGitHub: {},
  },
}

const UnlabeledEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    label: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
    labelable: {
      // nt: Labelable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnlinkProjectV2FromRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnlinkProjectV2FromTeamPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnlinkRepositoryFromProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnlockLockablePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    unlockedRecord: {
      // nt: Lockable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnlockedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    lockable: {
      // nt: Lockable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnmarkDiscussionCommentAsAnswerPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnmarkFileAsViewedPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnmarkIssueAsDuplicatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    duplicate: {
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnmarkProjectV2AsTemplatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnmarkedAsDuplicateEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    canonical: {
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    duplicate: {
      // nt: IssueOrPullRequest, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    isCrossRepository: {},
  },
}

const UnminimizeCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    unminimizedComment: {
      // nt: Minimizable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnpinIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    id: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnpinnedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnresolveReviewThreadPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    thread: {
      // nt: PullRequestReviewThread, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UnsubscribedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    id: {},
    subscribable: {
      // nt: Subscribable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateBranchProtectionRulePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    branchProtectionRule: {
      // nt: BranchProtectionRule, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const UpdateCheckRunPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkRun: {
      // nt: CheckRun, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
  },
}

const UpdateCheckSuitePreferencesPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    comment: {
      // nt: DiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    discussion: {
      // nt: Discussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateEnterpriseAdministratorRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
  },
}

const UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseDeployKeySettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject =
  {
    f: {
      clientMutationId: {},
      enterprise: {
        // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
      },
      message: {},
    },
  }

const UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanMakePurchasesSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseOrganizationProjectsSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseOwnerOrganizationRolePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
  },
}

const UpdateEnterpriseProfilePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateEnterpriseRepositoryProjectsSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseTeamDiscussionsSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload:
  $$Utilities.SchemaDrivenDataMap.OutputObject = {
    f: {
      clientMutationId: {},
      enterprise: {
        // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
      },
      message: {},
    },
  }

const UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    enterprise: {
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    message: {},
  },
}

const UpdateEnvironmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    environment: {
      // nt: Environment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateIpAllowListEnabledSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: IpAllowListOwner, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateIpAllowListEntryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ipAllowListEntry: {
      // nt: IpAllowListEntry, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateIpAllowListForInstalledAppsEnabledSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: IpAllowListOwner, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateIssueCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    issueComment: {
      // nt: IssueComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    issue: {
      // nt: Issue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateLabelPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    label: {
      // nt: Label, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateNotificationRestrictionSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    owner: {
      // nt: VerifiableDomainOwner, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateOrganizationWebCommitSignoffSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    updateAllowsFetchAndMerge: {},
  },
}

const UpdatePatreonSponsorabilityPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectCardPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectCard: {
      // nt: ProjectCard, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectColumnPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectColumn: {
      // nt: ProjectColumn, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    project: {
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2CollaboratorsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    collaborators: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2ActorConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2DraftIssuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    draftIssue: {
      // nt: DraftIssue, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2FieldPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2Field: {
      // nt: ProjectV2FieldConfiguration, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2ItemFieldValuePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2Item: {
      // nt: ProjectV2Item, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2ItemPositionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    items: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2ItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2Payload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    projectV2: {
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateProjectV2StatusUpdatePayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    statusUpdate: {
      // nt: ProjectV2StatusUpdate, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdatePullRequestBranchPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdatePullRequestPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    clientMutationId: {},
    pullRequest: {
      // nt: PullRequest, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdatePullRequestReviewCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReviewComment: {
      // nt: PullRequestReviewComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdatePullRequestReviewPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    pullRequestReview: {
      // nt: PullRequestReview, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateRefPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ref: {
      // nt: Ref, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateRefsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
  },
}

const UpdateRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateRepositoryRulesetPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    ruleset: {
      // nt: RepositoryRuleset, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateRepositoryWebCommitSignoffSettingPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    message: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateSponsorshipPreferencesPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    sponsorship: {
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateSubscriptionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    subscribable: {
      // nt: Subscribable, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateTeamDiscussionCommentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    teamDiscussionComment: {
      // nt: TeamDiscussionComment, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateTeamDiscussionPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    teamDiscussion: {
      // nt: TeamDiscussion, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateTeamReviewAssignmentPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    team: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateTeamsRepositoryPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    teams: {
      // nt: Team, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateTopicsPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    invalidTopicNames: {},
    repository: {
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateUserListPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    list: {
      // nt: UserList, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UpdateUserListsForItemPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    item: {
      // nt: UserListItems, <-- Assigned later to avoid potential circular dependency.
    },
    lists: {
      // nt: UserList, <-- Assigned later to avoid potential circular dependency.
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const User: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    anyPinnableItems: {
      a: {
        type: {
          nt: PinnableItemType,
          it: [0],
        },
      },
    },
    avatarUrl: {
      a: {
        size: {
          nt: Int,
          it: [0],
        },
      },
      nt: URI,
    },
    bio: {},
    bioHTML: {
      nt: HTML,
    },
    canReceiveOrganizationEmailsWhenNotificationsRestricted: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
    },
    commitComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: CommitCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    company: {},
    companyHTML: {
      nt: HTML,
    },
    contributionsCollection: {
      a: {
        from: {
          nt: DateTime,
          it: [0],
        },
        organizationID: {
          nt: ID,
          it: [0],
        },
        to: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: ContributionsCollection, <-- Assigned later to avoid potential circular dependency.
    },
    copilotEndpoints: {
      // nt: CopilotEndpoints, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    email: {},
    enterprises: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        membershipType: {
          nt: EnterpriseMembershipType,
          it: [0],
        },
        orderBy: {
          nt: EnterpriseOrder,
          it: [0],
        },
      },
      // nt: EnterpriseConnection, <-- Assigned later to avoid potential circular dependency.
    },
    estimatedNextSponsorsPayoutInCents: {},
    followers: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: FollowerConnection, <-- Assigned later to avoid potential circular dependency.
    },
    following: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: FollowingConnection, <-- Assigned later to avoid potential circular dependency.
    },
    gist: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Gist, <-- Assigned later to avoid potential circular dependency.
    },
    gistComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: GistCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    gists: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: GistOrder,
          it: [0],
        },
        privacy: {
          nt: GistPrivacy,
          it: [0],
        },
      },
      // nt: GistConnection, <-- Assigned later to avoid potential circular dependency.
    },
    hasSponsorsListing: {},
    hovercard: {
      a: {
        primarySubjectId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: Hovercard, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    interactionAbility: {
      // nt: RepositoryInteractionAbility, <-- Assigned later to avoid potential circular dependency.
    },
    isBountyHunter: {},
    isCampusExpert: {},
    isDeveloperProgramMember: {},
    isEmployee: {},
    isFollowingViewer: {},
    isGitHubStar: {},
    isHireable: {},
    isSiteAdmin: {},
    isSponsoredBy: {
      a: {
        accountLogin: {
          nt: String,
          it: [1],
        },
      },
    },
    isSponsoringViewer: {},
    isViewer: {},
    issueComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueCommentOrder,
          it: [0],
        },
      },
      // nt: IssueCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    issues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        filterBy: {
          nt: IssueFilters,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: IssueState,
          it: [0, [1]],
        },
      },
      // nt: IssueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    itemShowcase: {
      // nt: ProfileItemShowcase, <-- Assigned later to avoid potential circular dependency.
    },
    lifetimeReceivedSponsorshipValues: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorAndLifetimeValueOrder,
          it: [0],
        },
      },
      // nt: SponsorAndLifetimeValueConnection, <-- Assigned later to avoid potential circular dependency.
    },
    lists: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserListConnection, <-- Assigned later to avoid potential circular dependency.
    },
    location: {},
    login: {},
    monthlyEstimatedSponsorsIncomeInCents: {},
    name: {},
    organization: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    organizationVerifiedDomainEmails: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
    },
    organizations: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: OrganizationOrder,
          it: [0],
        },
      },
      // nt: OrganizationConnection, <-- Assigned later to avoid potential circular dependency.
    },
    packages: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        names: {
          nt: String,
          it: [0, [0]],
        },
        orderBy: {
          nt: PackageOrder,
          it: [0],
        },
        packageType: {
          nt: PackageType,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: PackageConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnableItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        types: {
          nt: PinnableItemType,
          it: [0, [1]],
        },
      },
      // nt: PinnableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedItems: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        types: {
          nt: PinnableItemType,
          it: [0, [1]],
        },
      },
      // nt: PinnableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pinnedItemsRemaining: {},
    project: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: Project, <-- Assigned later to avoid potential circular dependency.
    },
    projectV2: {
      a: {
        number: {
          nt: Int,
          it: [1],
        },
      },
      // nt: ProjectV2, <-- Assigned later to avoid potential circular dependency.
    },
    projects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: ProjectOrder,
          it: [0],
        },
        search: {
          nt: String,
          it: [0],
        },
        states: {
          nt: ProjectState,
          it: [0, [1]],
        },
      },
      // nt: ProjectConnection, <-- Assigned later to avoid potential circular dependency.
    },
    projectsResourcePath: {
      nt: URI,
    },
    projectsUrl: {
      nt: URI,
    },
    projectsV2: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        minPermissionLevel: {
          nt: ProjectV2PermissionLevel,
          it: [0],
        },
        orderBy: {
          nt: ProjectV2Order,
          it: [0],
        },
        query: {
          nt: String,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    pronouns: {},
    publicKeys: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: PublicKeyConnection, <-- Assigned later to avoid potential circular dependency.
    },
    pullRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        baseRefName: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        headRefName: {
          nt: String,
          it: [0],
        },
        labels: {
          nt: String,
          it: [0, [1]],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: IssueOrder,
          it: [0],
        },
        states: {
          nt: PullRequestState,
          it: [0, [1]],
        },
      },
      // nt: PullRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    recentProjects: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: ProjectV2Connection, <-- Assigned later to avoid potential circular dependency.
    },
    repositories: {
      a: {
        affiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssuesEnabled: {
          nt: Boolean,
          it: [0],
        },
        isArchived: {
          nt: Boolean,
          it: [0],
        },
        isFork: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        ownerAffiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoriesContributedTo: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        contributionTypes: {
          nt: RepositoryContributionType,
          it: [0, [0]],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssues: {
          nt: Boolean,
          it: [0],
        },
        includeUserRepositories: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      a: {
        followRenames: {
          nt: Boolean,
          it: [0],
        },
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryDiscussionComments: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        onlyAnswers: {
          nt: Boolean,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: DiscussionCommentConnection, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryDiscussions: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        answered: {
          nt: Boolean,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: DiscussionOrder,
          it: [0],
        },
        repositoryId: {
          nt: ID,
          it: [0],
        },
        states: {
          nt: DiscussionState,
          it: [0, [1]],
        },
      },
      // nt: DiscussionConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    savedReplies: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SavedReplyOrder,
          it: [0],
        },
      },
      // nt: SavedReplyConnection, <-- Assigned later to avoid potential circular dependency.
    },
    socialAccounts: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: SocialAccountConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsoring: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorOrder,
          it: [0],
        },
      },
      // nt: SponsorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsors: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorOrder,
          it: [0],
        },
        tierId: {
          nt: ID,
          it: [0],
        },
      },
      // nt: SponsorConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorsActivities: {
      a: {
        actions: {
          nt: SponsorsActivityAction,
          it: [0, [1]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includeAsSponsor: {
          nt: Boolean,
          it: [0],
        },
        includePrivate: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorsActivityOrder,
          it: [0],
        },
        period: {
          nt: SponsorsActivityPeriod,
          it: [0],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
        until: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: SponsorsActivityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorsListing: {
      // nt: SponsorsListing, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipForViewerAsSponsor: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipForViewerAsSponsorable: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: Sponsorship, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipNewsletters: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorshipNewsletterOrder,
          it: [0],
        },
      },
      // nt: SponsorshipNewsletterConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipsAsMaintainer: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        includePrivate: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SponsorshipOrder,
          it: [0],
        },
      },
      // nt: SponsorshipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorshipsAsSponsor: {
      a: {
        activeOnly: {
          nt: Boolean,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        maintainerLogins: {
          nt: String,
          it: [0, [1]],
        },
        orderBy: {
          nt: SponsorshipOrder,
          it: [0],
        },
      },
      // nt: SponsorshipConnection, <-- Assigned later to avoid potential circular dependency.
    },
    starredRepositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: StarOrder,
          it: [0],
        },
        ownedByViewer: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: StarredRepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    status: {
      // nt: UserStatus, <-- Assigned later to avoid potential circular dependency.
    },
    suggestedListNames: {
      // nt: UserListSuggestion, <-- Assigned later to avoid potential circular dependency.
    },
    topRepositories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [1],
        },
        since: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    totalSponsorshipAmountAsSponsorInCents: {
      a: {
        since: {
          nt: DateTime,
          it: [0],
        },
        sponsorableLogins: {
          nt: String,
          it: [0, [1]],
        },
        until: {
          nt: DateTime,
          it: [0],
        },
      },
    },
    twitterUsername: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    userViewType: {},
    viewerCanChangePinnedItems: {},
    viewerCanCreateProjects: {},
    viewerCanFollow: {},
    viewerCanSponsor: {},
    viewerIsFollowing: {},
    viewerIsSponsoring: {},
    watching: {
      a: {
        affiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        hasIssuesEnabled: {
          nt: Boolean,
          it: [0],
        },
        isLocked: {
          nt: Boolean,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: RepositoryOrder,
          it: [0],
        },
        ownerAffiliations: {
          nt: RepositoryAffiliation,
          it: [0, [0]],
        },
        privacy: {
          nt: RepositoryPrivacy,
          it: [0],
        },
        visibility: {
          nt: RepositoryVisibility,
          it: [0],
        },
      },
      // nt: RepositoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    websiteUrl: {
      nt: URI,
    },
  },
}

const UserBlockedEvent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    actor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    blockDuration: {},
    createdAt: {
      nt: DateTime,
    },
    id: {},
    subject: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserContentEdit: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    deletedAt: {
      nt: DateTime,
    },
    deletedBy: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    diff: {},
    editedAt: {
      nt: DateTime,
    },
    editor: {
      // nt: Actor, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    updatedAt: {
      nt: DateTime,
    },
  },
}

const UserContentEditConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserContentEditEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: UserContentEdit, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserContentEditEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: UserContentEdit, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserEmailMetadata: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    primary: {},
    type: {},
    value: {},
  },
}

const UserList: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    description: {},
    id: {},
    isPrivate: {},
    items: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: UserListItemsConnection, <-- Assigned later to avoid potential circular dependency.
    },
    lastAddedAt: {
      nt: DateTime,
    },
    name: {},
    slug: {},
    updatedAt: {
      nt: DateTime,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserListConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserListEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: UserList, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserListEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: UserList, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserListItemsConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserListItemsEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: UserListItems, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserListItemsEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: UserListItems, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserListSuggestion: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    name: {},
  },
}

const UserNamespaceRepository: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    name: {},
    nameWithOwner: {},
    owner: {
      // nt: RepositoryOwner, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      // nt: RepositoryInfo, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserNamespaceRepositoryConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserNamespaceRepositoryEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: UserNamespaceRepository, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserNamespaceRepositoryEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: UserNamespaceRepository, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserStatus: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    emoji: {},
    emojiHTML: {
      nt: HTML,
    },
    expiresAt: {
      nt: DateTime,
    },
    id: {},
    indicatesLimitedAvailability: {},
    message: {},
    organization: {
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    updatedAt: {
      nt: DateTime,
    },
    user: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const UserStatusConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: UserStatusEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: UserStatus, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const UserStatusEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: UserStatus, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const VerifiableDomain: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    dnsHostName: {
      nt: URI,
    },
    domain: {
      nt: URI,
    },
    hasFoundHostName: {},
    hasFoundVerificationToken: {},
    id: {},
    isApproved: {},
    isRequiredForPolicyEnforcement: {},
    isVerified: {},
    owner: {
      // nt: VerifiableDomainOwner, <-- Assigned later to avoid potential circular dependency.
    },
    punycodeEncodedDomain: {
      nt: URI,
    },
    tokenExpirationTime: {
      nt: DateTime,
    },
    updatedAt: {
      nt: DateTime,
    },
    verificationToken: {},
  },
}

const VerifiableDomainConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: VerifiableDomainEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: VerifiableDomain, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const VerifiableDomainEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: VerifiableDomain, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const VerifyVerifiableDomainPayload: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    clientMutationId: {},
    domain: {
      // nt: VerifiableDomain, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const ViewerHovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    message: {},
    octicon: {},
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Workflow: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    id: {},
    name: {},
    resourcePath: {
      nt: URI,
    },
    runs: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: WorkflowRunOrder,
          it: [0],
        },
      },
      // nt: WorkflowRunConnection, <-- Assigned later to avoid potential circular dependency.
    },
    state: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
  },
}

const WorkflowFileReference: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    path: {},
    ref: {},
    repositoryId: {},
    sha: {},
  },
}

const WorkflowRun: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    checkSuite: {
      // nt: CheckSuite, <-- Assigned later to avoid potential circular dependency.
    },
    createdAt: {
      nt: DateTime,
    },
    databaseId: {},
    deploymentReviews: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentReviewConnection, <-- Assigned later to avoid potential circular dependency.
    },
    event: {},
    file: {
      // nt: WorkflowRunFile, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    pendingDeploymentRequests: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
      },
      // nt: DeploymentRequestConnection, <-- Assigned later to avoid potential circular dependency.
    },
    resourcePath: {
      nt: URI,
    },
    runNumber: {},
    updatedAt: {
      nt: DateTime,
    },
    url: {
      nt: URI,
    },
    workflow: {
      // nt: Workflow, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const WorkflowRunConnection: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    edges: {
      // nt: WorkflowRunEdge, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      // nt: WorkflowRun, <-- Assigned later to avoid potential circular dependency.
    },
    pageInfo: {
      // nt: PageInfo, <-- Assigned later to avoid potential circular dependency.
    },
    totalCount: {},
  },
}

const WorkflowRunEdge: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    cursor: {},
    node: {
      // nt: WorkflowRun, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const WorkflowRunFile: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    id: {},
    path: {},
    repositoryFileUrl: {
      nt: URI,
    },
    repositoryName: {
      nt: URI,
    },
    resourcePath: {
      nt: URI,
    },
    run: {
      // nt: WorkflowRun, <-- Assigned later to avoid potential circular dependency.
    },
    url: {
      nt: URI,
    },
    viewerCanPushRepository: {},
    viewerCanReadRepository: {},
  },
}

const WorkflowsParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    doNotEnforceOnCreate: {},
    workflows: {
      // nt: WorkflowFileReference, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

const Actor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...EnterpriseUserAccount.f,
    ...Mannequin.f,
    ...Organization.f,
    ...User.f,
  },
}

const AnnouncementBannerI: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Enterprise.f,
    ...Organization.f,
  },
}

const Assignable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const AuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...MembersCanDeleteReposClearAuditEntry.f,
    ...MembersCanDeleteReposDisableAuditEntry.f,
    ...MembersCanDeleteReposEnableAuditEntry.f,
    ...OauthApplicationCreateAuditEntry.f,
    ...OrgAddBillingManagerAuditEntry.f,
    ...OrgAddMemberAuditEntry.f,
    ...OrgBlockUserAuditEntry.f,
    ...OrgConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...OrgConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...OrgCreateAuditEntry.f,
    ...OrgDisableOauthAppRestrictionsAuditEntry.f,
    ...OrgDisableSamlAuditEntry.f,
    ...OrgDisableTwoFactorRequirementAuditEntry.f,
    ...OrgEnableOauthAppRestrictionsAuditEntry.f,
    ...OrgEnableSamlAuditEntry.f,
    ...OrgEnableTwoFactorRequirementAuditEntry.f,
    ...OrgInviteMemberAuditEntry.f,
    ...OrgInviteToBusinessAuditEntry.f,
    ...OrgOauthAppAccessApprovedAuditEntry.f,
    ...OrgOauthAppAccessBlockedAuditEntry.f,
    ...OrgOauthAppAccessDeniedAuditEntry.f,
    ...OrgOauthAppAccessRequestedAuditEntry.f,
    ...OrgOauthAppAccessUnblockedAuditEntry.f,
    ...OrgRemoveBillingManagerAuditEntry.f,
    ...OrgRemoveMemberAuditEntry.f,
    ...OrgRemoveOutsideCollaboratorAuditEntry.f,
    ...OrgRestoreMemberAuditEntry.f,
    ...OrgUnblockUserAuditEntry.f,
    ...OrgUpdateDefaultRepositoryPermissionAuditEntry.f,
    ...OrgUpdateMemberAuditEntry.f,
    ...OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f,
    ...OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...RepoAccessAuditEntry.f,
    ...RepoAddMemberAuditEntry.f,
    ...RepoAddTopicAuditEntry.f,
    ...RepoArchivedAuditEntry.f,
    ...RepoChangeMergeSettingAuditEntry.f,
    ...RepoConfigDisableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigDisableContributorsOnlyAuditEntry.f,
    ...RepoConfigDisableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigEnableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigEnableContributorsOnlyAuditEntry.f,
    ...RepoConfigEnableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigLockAnonymousGitAccessAuditEntry.f,
    ...RepoConfigUnlockAnonymousGitAccessAuditEntry.f,
    ...RepoCreateAuditEntry.f,
    ...RepoDestroyAuditEntry.f,
    ...RepoRemoveMemberAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
    ...RepositoryVisibilityChangeDisableAuditEntry.f,
    ...RepositoryVisibilityChangeEnableAuditEntry.f,
    ...TeamAddMemberAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamChangeParentTeamAuditEntry.f,
    ...TeamRemoveMemberAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
  },
}

const Closable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Discussion.f,
    ...Issue.f,
    ...Milestone.f,
    ...Project.f,
    ...ProjectV2.f,
    ...PullRequest.f,
  },
}

const Comment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...Discussion.f,
    ...DiscussionComment.f,
    ...GistComment.f,
    ...Issue.f,
    ...IssueComment.f,
    ...PullRequest.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
  },
}

const Contribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CreatedCommitContribution.f,
    ...CreatedIssueContribution.f,
    ...CreatedPullRequestContribution.f,
    ...CreatedPullRequestReviewContribution.f,
    ...CreatedRepositoryContribution.f,
    ...JoinedGitHubContribution.f,
    ...RestrictedContribution.f,
  },
}

const Deletable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...Discussion.f,
    ...DiscussionComment.f,
    ...GistComment.f,
    ...Issue.f,
    ...IssueComment.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
  },
}

const EnterpriseAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...MembersCanDeleteReposClearAuditEntry.f,
    ...MembersCanDeleteReposDisableAuditEntry.f,
    ...MembersCanDeleteReposEnableAuditEntry.f,
    ...OrgInviteToBusinessAuditEntry.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...RepositoryVisibilityChangeDisableAuditEntry.f,
    ...RepositoryVisibilityChangeEnableAuditEntry.f,
  },
}

const GitObject: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Blob.f,
    ...Commit.f,
    ...Tag.f,
    ...Tree.f,
  },
}

const GitSignature: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...GpgSignature.f,
    ...SmimeSignature.f,
    ...SshSignature.f,
    ...UnknownSignature.f,
  },
}

const HovercardContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...OrganizationTeamsHovercardContext.f,
    ...OrganizationsHovercardContext.f,
    ...ViewerHovercardContext.f,
  },
}

const Labelable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Discussion.f,
    ...Issue.f,
    ...PullRequest.f,
  },
}

const Lockable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Discussion.f,
    ...Issue.f,
    ...PullRequest.f,
  },
}

const MemberStatusable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...Team.f,
  },
}

const Migration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...RepositoryMigration.f,
  },
}

const Minimizable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...DiscussionComment.f,
    ...GistComment.f,
    ...IssueComment.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
  },
}

const Node: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...AddedToMergeQueueEvent.f,
    ...AddedToProjectEvent.f,
    ...App.f,
    ...AssignedEvent.f,
    ...AutoMergeDisabledEvent.f,
    ...AutoMergeEnabledEvent.f,
    ...AutoRebaseEnabledEvent.f,
    ...AutoSquashEnabledEvent.f,
    ...AutomaticBaseChangeFailedEvent.f,
    ...AutomaticBaseChangeSucceededEvent.f,
    ...BaseRefChangedEvent.f,
    ...BaseRefDeletedEvent.f,
    ...BaseRefForcePushedEvent.f,
    ...Blob.f,
    ...Bot.f,
    ...BranchProtectionRule.f,
    ...BypassForcePushAllowance.f,
    ...BypassPullRequestAllowance.f,
    ...CheckRun.f,
    ...CheckSuite.f,
    ...ClosedEvent.f,
    ...CodeOfConduct.f,
    ...CommentDeletedEvent.f,
    ...Commit.f,
    ...CommitComment.f,
    ...CommitCommentThread.f,
    ...Comparison.f,
    ...ConnectedEvent.f,
    ...ConvertToDraftEvent.f,
    ...ConvertedNoteToIssueEvent.f,
    ...ConvertedToDiscussionEvent.f,
    ...CrossReferencedEvent.f,
    ...DemilestonedEvent.f,
    ...DependencyGraphManifest.f,
    ...DeployKey.f,
    ...DeployedEvent.f,
    ...Deployment.f,
    ...DeploymentEnvironmentChangedEvent.f,
    ...DeploymentReview.f,
    ...DeploymentStatus.f,
    ...DisconnectedEvent.f,
    ...Discussion.f,
    ...DiscussionCategory.f,
    ...DiscussionComment.f,
    ...DiscussionPoll.f,
    ...DiscussionPollOption.f,
    ...DraftIssue.f,
    ...Enterprise.f,
    ...EnterpriseAdministratorInvitation.f,
    ...EnterpriseIdentityProvider.f,
    ...EnterpriseMemberInvitation.f,
    ...EnterpriseServerInstallation.f,
    ...EnterpriseServerUserAccount.f,
    ...EnterpriseServerUserAccountEmail.f,
    ...EnterpriseServerUserAccountsUpload.f,
    ...EnterpriseUserAccount.f,
    ...Environment.f,
    ...ExternalIdentity.f,
    ...Gist.f,
    ...GistComment.f,
    ...HeadRefDeletedEvent.f,
    ...HeadRefForcePushedEvent.f,
    ...HeadRefRestoredEvent.f,
    ...IpAllowListEntry.f,
    ...Issue.f,
    ...IssueComment.f,
    ...Label.f,
    ...LabeledEvent.f,
    ...License.f,
    ...LinkedBranch.f,
    ...LockedEvent.f,
    ...Mannequin.f,
    ...MarkedAsDuplicateEvent.f,
    ...MarketplaceCategory.f,
    ...MarketplaceListing.f,
    ...MemberFeatureRequestNotification.f,
    ...MembersCanDeleteReposClearAuditEntry.f,
    ...MembersCanDeleteReposDisableAuditEntry.f,
    ...MembersCanDeleteReposEnableAuditEntry.f,
    ...MentionedEvent.f,
    ...MergeQueue.f,
    ...MergeQueueEntry.f,
    ...MergedEvent.f,
    ...MigrationSource.f,
    ...Milestone.f,
    ...MilestonedEvent.f,
    ...MovedColumnsInProjectEvent.f,
    ...OIDCProvider.f,
    ...OauthApplicationCreateAuditEntry.f,
    ...OrgAddBillingManagerAuditEntry.f,
    ...OrgAddMemberAuditEntry.f,
    ...OrgBlockUserAuditEntry.f,
    ...OrgConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...OrgConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...OrgCreateAuditEntry.f,
    ...OrgDisableOauthAppRestrictionsAuditEntry.f,
    ...OrgDisableSamlAuditEntry.f,
    ...OrgDisableTwoFactorRequirementAuditEntry.f,
    ...OrgEnableOauthAppRestrictionsAuditEntry.f,
    ...OrgEnableSamlAuditEntry.f,
    ...OrgEnableTwoFactorRequirementAuditEntry.f,
    ...OrgInviteMemberAuditEntry.f,
    ...OrgInviteToBusinessAuditEntry.f,
    ...OrgOauthAppAccessApprovedAuditEntry.f,
    ...OrgOauthAppAccessBlockedAuditEntry.f,
    ...OrgOauthAppAccessDeniedAuditEntry.f,
    ...OrgOauthAppAccessRequestedAuditEntry.f,
    ...OrgOauthAppAccessUnblockedAuditEntry.f,
    ...OrgRemoveBillingManagerAuditEntry.f,
    ...OrgRemoveMemberAuditEntry.f,
    ...OrgRemoveOutsideCollaboratorAuditEntry.f,
    ...OrgRestoreMemberAuditEntry.f,
    ...OrgUnblockUserAuditEntry.f,
    ...OrgUpdateDefaultRepositoryPermissionAuditEntry.f,
    ...OrgUpdateMemberAuditEntry.f,
    ...OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f,
    ...OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f,
    ...Organization.f,
    ...OrganizationIdentityProvider.f,
    ...OrganizationInvitation.f,
    ...OrganizationMigration.f,
    ...Package.f,
    ...PackageFile.f,
    ...PackageTag.f,
    ...PackageVersion.f,
    ...ParentIssueAddedEvent.f,
    ...ParentIssueRemovedEvent.f,
    ...PinnedDiscussion.f,
    ...PinnedEnvironment.f,
    ...PinnedEvent.f,
    ...PinnedIssue.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...Project.f,
    ...ProjectCard.f,
    ...ProjectColumn.f,
    ...ProjectV2.f,
    ...ProjectV2Field.f,
    ...ProjectV2Item.f,
    ...ProjectV2ItemFieldDateValue.f,
    ...ProjectV2ItemFieldIterationValue.f,
    ...ProjectV2ItemFieldNumberValue.f,
    ...ProjectV2ItemFieldSingleSelectValue.f,
    ...ProjectV2ItemFieldTextValue.f,
    ...ProjectV2IterationField.f,
    ...ProjectV2SingleSelectField.f,
    ...ProjectV2StatusUpdate.f,
    ...ProjectV2View.f,
    ...ProjectV2Workflow.f,
    ...PublicKey.f,
    ...PullRequest.f,
    ...PullRequestCommit.f,
    ...PullRequestCommitCommentThread.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...PullRequestReviewThread.f,
    ...PullRequestThread.f,
    ...Push.f,
    ...PushAllowance.f,
    ...Reaction.f,
    ...ReadyForReviewEvent.f,
    ...Ref.f,
    ...ReferencedEvent.f,
    ...Release.f,
    ...ReleaseAsset.f,
    ...RemovedFromMergeQueueEvent.f,
    ...RemovedFromProjectEvent.f,
    ...RenamedTitleEvent.f,
    ...ReopenedEvent.f,
    ...RepoAccessAuditEntry.f,
    ...RepoAddMemberAuditEntry.f,
    ...RepoAddTopicAuditEntry.f,
    ...RepoArchivedAuditEntry.f,
    ...RepoChangeMergeSettingAuditEntry.f,
    ...RepoConfigDisableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigDisableContributorsOnlyAuditEntry.f,
    ...RepoConfigDisableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigEnableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigEnableContributorsOnlyAuditEntry.f,
    ...RepoConfigEnableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigLockAnonymousGitAccessAuditEntry.f,
    ...RepoConfigUnlockAnonymousGitAccessAuditEntry.f,
    ...RepoCreateAuditEntry.f,
    ...RepoDestroyAuditEntry.f,
    ...RepoRemoveMemberAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
    ...Repository.f,
    ...RepositoryInvitation.f,
    ...RepositoryMigration.f,
    ...RepositoryRule.f,
    ...RepositoryRuleset.f,
    ...RepositoryRulesetBypassActor.f,
    ...RepositoryTopic.f,
    ...RepositoryVisibilityChangeDisableAuditEntry.f,
    ...RepositoryVisibilityChangeEnableAuditEntry.f,
    ...RepositoryVulnerabilityAlert.f,
    ...ReviewDismissalAllowance.f,
    ...ReviewDismissedEvent.f,
    ...ReviewRequest.f,
    ...ReviewRequestRemovedEvent.f,
    ...ReviewRequestedEvent.f,
    ...SavedReply.f,
    ...SecurityAdvisory.f,
    ...SponsorsActivity.f,
    ...SponsorsListing.f,
    ...SponsorsListingFeaturedItem.f,
    ...SponsorsTier.f,
    ...Sponsorship.f,
    ...SponsorshipNewsletter.f,
    ...Status.f,
    ...StatusCheckRollup.f,
    ...StatusContext.f,
    ...SubIssueAddedEvent.f,
    ...SubIssueRemovedEvent.f,
    ...SubscribedEvent.f,
    ...Tag.f,
    ...Team.f,
    ...TeamAddMemberAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamChangeParentTeamAuditEntry.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
    ...TeamRemoveMemberAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
    ...Topic.f,
    ...TransferredEvent.f,
    ...Tree.f,
    ...UnassignedEvent.f,
    ...UnlabeledEvent.f,
    ...UnlockedEvent.f,
    ...UnmarkedAsDuplicateEvent.f,
    ...UnpinnedEvent.f,
    ...UnsubscribedEvent.f,
    ...User.f,
    ...UserBlockedEvent.f,
    ...UserContentEdit.f,
    ...UserList.f,
    ...UserNamespaceRepository.f,
    ...UserStatus.f,
    ...VerifiableDomain.f,
    ...Workflow.f,
    ...WorkflowRun.f,
    ...WorkflowRunFile.f,
  },
}

const OauthApplicationAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...OauthApplicationCreateAuditEntry.f,
    ...OrgOauthAppAccessApprovedAuditEntry.f,
    ...OrgOauthAppAccessBlockedAuditEntry.f,
    ...OrgOauthAppAccessDeniedAuditEntry.f,
    ...OrgOauthAppAccessRequestedAuditEntry.f,
    ...OrgOauthAppAccessUnblockedAuditEntry.f,
  },
}

const OrganizationAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...MembersCanDeleteReposClearAuditEntry.f,
    ...MembersCanDeleteReposDisableAuditEntry.f,
    ...MembersCanDeleteReposEnableAuditEntry.f,
    ...OauthApplicationCreateAuditEntry.f,
    ...OrgAddBillingManagerAuditEntry.f,
    ...OrgAddMemberAuditEntry.f,
    ...OrgBlockUserAuditEntry.f,
    ...OrgConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...OrgConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...OrgCreateAuditEntry.f,
    ...OrgDisableOauthAppRestrictionsAuditEntry.f,
    ...OrgDisableSamlAuditEntry.f,
    ...OrgDisableTwoFactorRequirementAuditEntry.f,
    ...OrgEnableOauthAppRestrictionsAuditEntry.f,
    ...OrgEnableSamlAuditEntry.f,
    ...OrgEnableTwoFactorRequirementAuditEntry.f,
    ...OrgInviteMemberAuditEntry.f,
    ...OrgInviteToBusinessAuditEntry.f,
    ...OrgOauthAppAccessApprovedAuditEntry.f,
    ...OrgOauthAppAccessBlockedAuditEntry.f,
    ...OrgOauthAppAccessDeniedAuditEntry.f,
    ...OrgOauthAppAccessRequestedAuditEntry.f,
    ...OrgOauthAppAccessUnblockedAuditEntry.f,
    ...OrgRemoveBillingManagerAuditEntry.f,
    ...OrgRemoveMemberAuditEntry.f,
    ...OrgRemoveOutsideCollaboratorAuditEntry.f,
    ...OrgRestoreMemberAuditEntry.f,
    ...OrgRestoreMemberMembershipOrganizationAuditEntryData.f,
    ...OrgUnblockUserAuditEntry.f,
    ...OrgUpdateDefaultRepositoryPermissionAuditEntry.f,
    ...OrgUpdateMemberAuditEntry.f,
    ...OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f,
    ...OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...RepoAccessAuditEntry.f,
    ...RepoAddMemberAuditEntry.f,
    ...RepoAddTopicAuditEntry.f,
    ...RepoArchivedAuditEntry.f,
    ...RepoChangeMergeSettingAuditEntry.f,
    ...RepoConfigDisableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigDisableContributorsOnlyAuditEntry.f,
    ...RepoConfigDisableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigEnableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigEnableContributorsOnlyAuditEntry.f,
    ...RepoConfigEnableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigLockAnonymousGitAccessAuditEntry.f,
    ...RepoConfigUnlockAnonymousGitAccessAuditEntry.f,
    ...RepoCreateAuditEntry.f,
    ...RepoDestroyAuditEntry.f,
    ...RepoRemoveMemberAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
    ...RepositoryVisibilityChangeDisableAuditEntry.f,
    ...RepositoryVisibilityChangeEnableAuditEntry.f,
    ...TeamAddMemberAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamChangeParentTeamAuditEntry.f,
    ...TeamRemoveMemberAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
  },
}

const PackageOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...Repository.f,
    ...User.f,
  },
}

const ProfileOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const ProjectOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...Repository.f,
    ...User.f,
  },
}

const ProjectV2FieldCommon: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...ProjectV2Field.f,
    ...ProjectV2IterationField.f,
    ...ProjectV2SingleSelectField.f,
  },
}

const ProjectV2ItemFieldValueCommon: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...ProjectV2ItemFieldDateValue.f,
    ...ProjectV2ItemFieldIterationValue.f,
    ...ProjectV2ItemFieldNumberValue.f,
    ...ProjectV2ItemFieldSingleSelectValue.f,
    ...ProjectV2ItemFieldTextValue.f,
  },
}

const ProjectV2Owner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...Organization.f,
    ...PullRequest.f,
    ...User.f,
  },
}

const ProjectV2Recent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...Repository.f,
    ...User.f,
  },
}

const Reactable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...Discussion.f,
    ...DiscussionComment.f,
    ...Issue.f,
    ...IssueComment.f,
    ...PullRequest.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...Release.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
  },
}

const RepositoryAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...OrgRestoreMemberMembershipRepositoryAuditEntryData.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...RepoAccessAuditEntry.f,
    ...RepoAddMemberAuditEntry.f,
    ...RepoAddTopicAuditEntry.f,
    ...RepoArchivedAuditEntry.f,
    ...RepoChangeMergeSettingAuditEntry.f,
    ...RepoConfigDisableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigDisableContributorsOnlyAuditEntry.f,
    ...RepoConfigDisableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigEnableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigEnableContributorsOnlyAuditEntry.f,
    ...RepoConfigEnableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigLockAnonymousGitAccessAuditEntry.f,
    ...RepoConfigUnlockAnonymousGitAccessAuditEntry.f,
    ...RepoCreateAuditEntry.f,
    ...RepoDestroyAuditEntry.f,
    ...RepoRemoveMemberAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
  },
}

const RepositoryDiscussionAuthor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const RepositoryDiscussionCommentAuthor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const RepositoryInfo: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Repository.f,
  },
}

const RepositoryNode: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...CommitCommentThread.f,
    ...DependabotUpdate.f,
    ...Discussion.f,
    ...DiscussionCategory.f,
    ...Issue.f,
    ...IssueComment.f,
    ...PinnedDiscussion.f,
    ...PullRequest.f,
    ...PullRequestCommitCommentThread.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...RepositoryVulnerabilityAlert.f,
  },
}

const RepositoryOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const RequirableByPullRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CheckRun.f,
    ...StatusContext.f,
  },
}

const Sponsorable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const Starrable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Gist.f,
    ...Repository.f,
    ...Topic.f,
  },
}

const Subscribable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Commit.f,
    ...Discussion.f,
    ...Issue.f,
    ...PullRequest.f,
    ...Repository.f,
    ...Team.f,
    ...TeamDiscussion.f,
  },
}

const SubscribableThread: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
  },
}

const TeamAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...OrgRestoreMemberMembershipTeamAuditEntryData.f,
    ...TeamAddMemberAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamChangeParentTeamAuditEntry.f,
    ...TeamRemoveMemberAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
  },
}

const TopicAuditEntryData: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...RepoAddTopicAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
  },
}

const UniformResourceLocatable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...CheckRun.f,
    ...ClosedEvent.f,
    ...Commit.f,
    ...ConvertToDraftEvent.f,
    ...CrossReferencedEvent.f,
    ...Gist.f,
    ...Issue.f,
    ...Mannequin.f,
    ...MergedEvent.f,
    ...Milestone.f,
    ...Organization.f,
    ...PullRequest.f,
    ...PullRequestCommit.f,
    ...ReadyForReviewEvent.f,
    ...Release.f,
    ...Repository.f,
    ...RepositoryTopic.f,
    ...ReviewDismissedEvent.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
    ...User.f,
    ...Workflow.f,
    ...WorkflowRun.f,
    ...WorkflowRunFile.f,
  },
}

const Updatable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...Discussion.f,
    ...DiscussionComment.f,
    ...GistComment.f,
    ...Issue.f,
    ...IssueComment.f,
    ...Project.f,
    ...ProjectV2.f,
    ...PullRequest.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
  },
}

const UpdatableComment: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CommitComment.f,
    ...DiscussionComment.f,
    ...GistComment.f,
    ...Issue.f,
    ...IssueComment.f,
    ...PullRequest.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...TeamDiscussion.f,
    ...TeamDiscussionComment.f,
  },
}

const Votable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Discussion.f,
    ...DiscussionComment.f,
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

const Assignee: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...Mannequin.f,
    ...Organization.f,
    ...User.f,
  },
}

const AuditEntryActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...Organization.f,
    ...User.f,
  },
}

const BranchActorAllowanceActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Team.f,
    ...User.f,
  },
}

const BypassActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Team.f,
  },
}

const Claimable: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Mannequin.f,
    ...User.f,
  },
}

const Closer: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Commit.f,
    ...ProjectV2.f,
    ...PullRequest.f,
  },
}

const CreatedIssueOrRestrictedContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CreatedIssueContribution.f,
    ...RestrictedContribution.f,
  },
}

const CreatedPullRequestOrRestrictedContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CreatedPullRequestContribution.f,
    ...RestrictedContribution.f,
  },
}

const CreatedRepositoryOrRestrictedContribution: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CreatedRepositoryContribution.f,
    ...RestrictedContribution.f,
  },
}

const DeploymentReviewer: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Team.f,
    ...User.f,
  },
}

const EnterpriseMember: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...EnterpriseUserAccount.f,
    ...User.f,
  },
}

const IpAllowListOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Enterprise.f,
    ...Organization.f,
  },
}

const IssueOrPullRequest: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const IssueTimelineItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...AssignedEvent.f,
    ...ClosedEvent.f,
    ...Commit.f,
    ...CrossReferencedEvent.f,
    ...DemilestonedEvent.f,
    ...IssueComment.f,
    ...LabeledEvent.f,
    ...LockedEvent.f,
    ...MilestonedEvent.f,
    ...ReferencedEvent.f,
    ...RenamedTitleEvent.f,
    ...ReopenedEvent.f,
    ...SubscribedEvent.f,
    ...TransferredEvent.f,
    ...UnassignedEvent.f,
    ...UnlabeledEvent.f,
    ...UnlockedEvent.f,
    ...UnsubscribedEvent.f,
    ...UserBlockedEvent.f,
  },
}

const IssueTimelineItems: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...AddedToProjectEvent.f,
    ...AssignedEvent.f,
    ...ClosedEvent.f,
    ...CommentDeletedEvent.f,
    ...ConnectedEvent.f,
    ...ConvertedNoteToIssueEvent.f,
    ...ConvertedToDiscussionEvent.f,
    ...CrossReferencedEvent.f,
    ...DemilestonedEvent.f,
    ...DisconnectedEvent.f,
    ...IssueComment.f,
    ...LabeledEvent.f,
    ...LockedEvent.f,
    ...MarkedAsDuplicateEvent.f,
    ...MentionedEvent.f,
    ...MilestonedEvent.f,
    ...MovedColumnsInProjectEvent.f,
    ...ParentIssueAddedEvent.f,
    ...ParentIssueRemovedEvent.f,
    ...PinnedEvent.f,
    ...ReferencedEvent.f,
    ...RemovedFromProjectEvent.f,
    ...RenamedTitleEvent.f,
    ...ReopenedEvent.f,
    ...SubIssueAddedEvent.f,
    ...SubIssueRemovedEvent.f,
    ...SubscribedEvent.f,
    ...TransferredEvent.f,
    ...UnassignedEvent.f,
    ...UnlabeledEvent.f,
    ...UnlockedEvent.f,
    ...UnmarkedAsDuplicateEvent.f,
    ...UnpinnedEvent.f,
    ...UnsubscribedEvent.f,
    ...UserBlockedEvent.f,
  },
}

const MilestoneItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const OrgRestoreMemberAuditEntryMembership: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...OrgRestoreMemberMembershipOrganizationAuditEntryData.f,
    ...OrgRestoreMemberMembershipRepositoryAuditEntryData.f,
    ...OrgRestoreMemberMembershipTeamAuditEntryData.f,
  },
}

const OrganizationAuditEntry: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...MembersCanDeleteReposClearAuditEntry.f,
    ...MembersCanDeleteReposDisableAuditEntry.f,
    ...MembersCanDeleteReposEnableAuditEntry.f,
    ...OauthApplicationCreateAuditEntry.f,
    ...OrgAddBillingManagerAuditEntry.f,
    ...OrgAddMemberAuditEntry.f,
    ...OrgBlockUserAuditEntry.f,
    ...OrgConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...OrgConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...OrgCreateAuditEntry.f,
    ...OrgDisableOauthAppRestrictionsAuditEntry.f,
    ...OrgDisableSamlAuditEntry.f,
    ...OrgDisableTwoFactorRequirementAuditEntry.f,
    ...OrgEnableOauthAppRestrictionsAuditEntry.f,
    ...OrgEnableSamlAuditEntry.f,
    ...OrgEnableTwoFactorRequirementAuditEntry.f,
    ...OrgInviteMemberAuditEntry.f,
    ...OrgInviteToBusinessAuditEntry.f,
    ...OrgOauthAppAccessApprovedAuditEntry.f,
    ...OrgOauthAppAccessBlockedAuditEntry.f,
    ...OrgOauthAppAccessDeniedAuditEntry.f,
    ...OrgOauthAppAccessRequestedAuditEntry.f,
    ...OrgOauthAppAccessUnblockedAuditEntry.f,
    ...OrgRemoveBillingManagerAuditEntry.f,
    ...OrgRemoveMemberAuditEntry.f,
    ...OrgRemoveOutsideCollaboratorAuditEntry.f,
    ...OrgRestoreMemberAuditEntry.f,
    ...OrgUnblockUserAuditEntry.f,
    ...OrgUpdateDefaultRepositoryPermissionAuditEntry.f,
    ...OrgUpdateMemberAuditEntry.f,
    ...OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f,
    ...OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f,
    ...PrivateRepositoryForkingDisableAuditEntry.f,
    ...PrivateRepositoryForkingEnableAuditEntry.f,
    ...RepoAccessAuditEntry.f,
    ...RepoAddMemberAuditEntry.f,
    ...RepoAddTopicAuditEntry.f,
    ...RepoArchivedAuditEntry.f,
    ...RepoChangeMergeSettingAuditEntry.f,
    ...RepoConfigDisableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigDisableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigDisableContributorsOnlyAuditEntry.f,
    ...RepoConfigDisableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigEnableAnonymousGitAccessAuditEntry.f,
    ...RepoConfigEnableCollaboratorsOnlyAuditEntry.f,
    ...RepoConfigEnableContributorsOnlyAuditEntry.f,
    ...RepoConfigEnableSockpuppetDisallowedAuditEntry.f,
    ...RepoConfigLockAnonymousGitAccessAuditEntry.f,
    ...RepoConfigUnlockAnonymousGitAccessAuditEntry.f,
    ...RepoCreateAuditEntry.f,
    ...RepoDestroyAuditEntry.f,
    ...RepoRemoveMemberAuditEntry.f,
    ...RepoRemoveTopicAuditEntry.f,
    ...RepositoryVisibilityChangeDisableAuditEntry.f,
    ...RepositoryVisibilityChangeEnableAuditEntry.f,
    ...TeamAddMemberAuditEntry.f,
    ...TeamAddRepositoryAuditEntry.f,
    ...TeamChangeParentTeamAuditEntry.f,
    ...TeamRemoveMemberAuditEntry.f,
    ...TeamRemoveRepositoryAuditEntry.f,
  },
}

const OrganizationOrUser: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const PermissionGranter: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...Repository.f,
    ...Team.f,
  },
}

const PinnableItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Gist.f,
    ...Repository.f,
  },
}

const ProjectCardItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const ProjectV2Actor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Team.f,
    ...User.f,
  },
}

const ProjectV2FieldConfiguration: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...ProjectV2Field.f,
    ...ProjectV2IterationField.f,
    ...ProjectV2SingleSelectField.f,
  },
}

const ProjectV2ItemContent: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...DraftIssue.f,
    ...Issue.f,
    ...PullRequest.f,
  },
}

const ProjectV2ItemFieldValue: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...ProjectV2ItemFieldDateValue.f,
    ...ProjectV2ItemFieldIterationValue.f,
    ...ProjectV2ItemFieldLabelValue.f,
    ...ProjectV2ItemFieldMilestoneValue.f,
    ...ProjectV2ItemFieldNumberValue.f,
    ...ProjectV2ItemFieldPullRequestValue.f,
    ...ProjectV2ItemFieldRepositoryValue.f,
    ...ProjectV2ItemFieldReviewerValue.f,
    ...ProjectV2ItemFieldSingleSelectValue.f,
    ...ProjectV2ItemFieldTextValue.f,
    ...ProjectV2ItemFieldUserValue.f,
  },
}

const PullRequestTimelineItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...AssignedEvent.f,
    ...BaseRefDeletedEvent.f,
    ...BaseRefForcePushedEvent.f,
    ...ClosedEvent.f,
    ...Commit.f,
    ...CommitCommentThread.f,
    ...CrossReferencedEvent.f,
    ...DemilestonedEvent.f,
    ...DeployedEvent.f,
    ...DeploymentEnvironmentChangedEvent.f,
    ...HeadRefDeletedEvent.f,
    ...HeadRefForcePushedEvent.f,
    ...HeadRefRestoredEvent.f,
    ...IssueComment.f,
    ...LabeledEvent.f,
    ...LockedEvent.f,
    ...MergedEvent.f,
    ...MilestonedEvent.f,
    ...PullRequestReview.f,
    ...PullRequestReviewComment.f,
    ...PullRequestReviewThread.f,
    ...ReferencedEvent.f,
    ...RenamedTitleEvent.f,
    ...ReopenedEvent.f,
    ...ReviewDismissedEvent.f,
    ...ReviewRequestRemovedEvent.f,
    ...ReviewRequestedEvent.f,
    ...SubscribedEvent.f,
    ...UnassignedEvent.f,
    ...UnlabeledEvent.f,
    ...UnlockedEvent.f,
    ...UnsubscribedEvent.f,
    ...UserBlockedEvent.f,
  },
}

const PullRequestTimelineItems: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...AddedToMergeQueueEvent.f,
    ...AddedToProjectEvent.f,
    ...AssignedEvent.f,
    ...AutoMergeDisabledEvent.f,
    ...AutoMergeEnabledEvent.f,
    ...AutoRebaseEnabledEvent.f,
    ...AutoSquashEnabledEvent.f,
    ...AutomaticBaseChangeFailedEvent.f,
    ...AutomaticBaseChangeSucceededEvent.f,
    ...BaseRefChangedEvent.f,
    ...BaseRefDeletedEvent.f,
    ...BaseRefForcePushedEvent.f,
    ...ClosedEvent.f,
    ...CommentDeletedEvent.f,
    ...ConnectedEvent.f,
    ...ConvertToDraftEvent.f,
    ...ConvertedNoteToIssueEvent.f,
    ...ConvertedToDiscussionEvent.f,
    ...CrossReferencedEvent.f,
    ...DemilestonedEvent.f,
    ...DeployedEvent.f,
    ...DeploymentEnvironmentChangedEvent.f,
    ...DisconnectedEvent.f,
    ...HeadRefDeletedEvent.f,
    ...HeadRefForcePushedEvent.f,
    ...HeadRefRestoredEvent.f,
    ...IssueComment.f,
    ...LabeledEvent.f,
    ...LockedEvent.f,
    ...MarkedAsDuplicateEvent.f,
    ...MentionedEvent.f,
    ...MergedEvent.f,
    ...MilestonedEvent.f,
    ...MovedColumnsInProjectEvent.f,
    ...ParentIssueAddedEvent.f,
    ...ParentIssueRemovedEvent.f,
    ...PinnedEvent.f,
    ...PullRequestCommit.f,
    ...PullRequestCommitCommentThread.f,
    ...PullRequestReview.f,
    ...PullRequestReviewThread.f,
    ...PullRequestRevisionMarker.f,
    ...ReadyForReviewEvent.f,
    ...ReferencedEvent.f,
    ...RemovedFromMergeQueueEvent.f,
    ...RemovedFromProjectEvent.f,
    ...RenamedTitleEvent.f,
    ...ReopenedEvent.f,
    ...ReviewDismissedEvent.f,
    ...ReviewRequestRemovedEvent.f,
    ...ReviewRequestedEvent.f,
    ...SubIssueAddedEvent.f,
    ...SubIssueRemovedEvent.f,
    ...SubscribedEvent.f,
    ...TransferredEvent.f,
    ...UnassignedEvent.f,
    ...UnlabeledEvent.f,
    ...UnlockedEvent.f,
    ...UnmarkedAsDuplicateEvent.f,
    ...UnpinnedEvent.f,
    ...UnsubscribedEvent.f,
    ...UserBlockedEvent.f,
  },
}

const PushAllowanceActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Team.f,
    ...User.f,
  },
}

const Reactor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...Mannequin.f,
    ...Organization.f,
    ...User.f,
  },
}

const ReferencedSubject: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const RenamedTitleSubject: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Issue.f,
    ...PullRequest.f,
  },
}

const RequestedReviewer: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Bot.f,
    ...Mannequin.f,
    ...Team.f,
    ...User.f,
  },
}

const ReviewDismissalAllowanceActor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Team.f,
    ...User.f,
  },
}

const RuleParameters: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {},
}

const RuleSource: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Enterprise.f,
    ...Organization.f,
    ...Repository.f,
  },
}

const SearchResultItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...App.f,
    ...Discussion.f,
    ...Issue.f,
    ...MarketplaceListing.f,
    ...Organization.f,
    ...PullRequest.f,
    ...Repository.f,
    ...User.f,
  },
}

const Sponsor: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const SponsorableItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Organization.f,
    ...User.f,
  },
}

const SponsorsListingFeatureableItem: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Repository.f,
    ...User.f,
  },
}

const StatusCheckRollupContext: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...CheckRun.f,
    ...StatusContext.f,
  },
}

const UserListItems: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Repository.f,
  },
}

const VerifiableDomainOwner: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    ...Enterprise.f,
    ...Organization.f,
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

const Query: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    codeOfConduct: {
      a: {
        key: {
          nt: String,
          it: [1],
        },
      },
      // nt: CodeOfConduct, <-- Assigned later to avoid potential circular dependency.
    },
    codesOfConduct: {
      // nt: CodeOfConduct, <-- Assigned later to avoid potential circular dependency.
    },
    enterprise: {
      a: {
        invitationToken: {
          nt: String,
          it: [0],
        },
        slug: {
          nt: String,
          it: [1],
        },
      },
      // nt: Enterprise, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseAdministratorInvitation: {
      a: {
        enterpriseSlug: {
          nt: String,
          it: [1],
        },
        role: {
          nt: EnterpriseAdministratorRole,
          it: [1],
        },
        userLogin: {
          nt: String,
          it: [1],
        },
      },
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseAdministratorInvitationByToken: {
      a: {
        invitationToken: {
          nt: String,
          it: [1],
        },
      },
      // nt: EnterpriseAdministratorInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseMemberInvitation: {
      a: {
        enterpriseSlug: {
          nt: String,
          it: [1],
        },
        userLogin: {
          nt: String,
          it: [1],
        },
      },
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    enterpriseMemberInvitationByToken: {
      a: {
        invitationToken: {
          nt: String,
          it: [1],
        },
      },
      // nt: EnterpriseMemberInvitation, <-- Assigned later to avoid potential circular dependency.
    },
    id: {},
    license: {
      a: {
        key: {
          nt: String,
          it: [1],
        },
      },
      // nt: License, <-- Assigned later to avoid potential circular dependency.
    },
    licenses: {
      // nt: License, <-- Assigned later to avoid potential circular dependency.
    },
    marketplaceCategories: {
      a: {
        excludeEmpty: {
          nt: Boolean,
          it: [0],
        },
        excludeSubcategories: {
          nt: Boolean,
          it: [0],
        },
        includeCategories: {
          nt: String,
          it: [0, [1]],
        },
      },
      // nt: MarketplaceCategory, <-- Assigned later to avoid potential circular dependency.
    },
    marketplaceCategory: {
      a: {
        slug: {
          nt: String,
          it: [1],
        },
        useTopicAliases: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: MarketplaceCategory, <-- Assigned later to avoid potential circular dependency.
    },
    marketplaceListing: {
      a: {
        slug: {
          nt: String,
          it: [1],
        },
      },
      // nt: MarketplaceListing, <-- Assigned later to avoid potential circular dependency.
    },
    marketplaceListings: {
      a: {
        adminId: {
          nt: ID,
          it: [0],
        },
        after: {
          nt: String,
          it: [0],
        },
        allStates: {
          nt: Boolean,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        categorySlug: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        organizationId: {
          nt: ID,
          it: [0],
        },
        primaryCategoryOnly: {
          nt: Boolean,
          it: [0],
        },
        slugs: {
          nt: String,
          it: [0, [0]],
        },
        useTopicAliases: {
          nt: Boolean,
          it: [0],
        },
        viewerCanAdmin: {
          nt: Boolean,
          it: [0],
        },
        withFreeTrialsOnly: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: MarketplaceListingConnection, <-- Assigned later to avoid potential circular dependency.
    },
    meta: {
      // nt: GitHubMetadata, <-- Assigned later to avoid potential circular dependency.
    },
    node: {
      a: {
        id: {
          nt: ID,
          it: [1],
        },
      },
      // nt: Node, <-- Assigned later to avoid potential circular dependency.
    },
    nodes: {
      a: {
        ids: {
          nt: ID,
          it: [1, [1]],
        },
      },
      // nt: Node, <-- Assigned later to avoid potential circular dependency.
    },
    organization: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
      // nt: Organization, <-- Assigned later to avoid potential circular dependency.
    },
    rateLimit: {
      a: {
        dryRun: {
          nt: Boolean,
          it: [0],
        },
      },
      // nt: RateLimit, <-- Assigned later to avoid potential circular dependency.
    },
    relay: {
      // nt: Query, <-- Assigned later to avoid potential circular dependency.
    },
    repository: {
      a: {
        followRenames: {
          nt: Boolean,
          it: [0],
        },
        name: {
          nt: String,
          it: [1],
        },
        owner: {
          nt: String,
          it: [1],
        },
      },
      // nt: Repository, <-- Assigned later to avoid potential circular dependency.
    },
    repositoryOwner: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
      // nt: RepositoryOwner, <-- Assigned later to avoid potential circular dependency.
    },
    resource: {
      a: {
        url: {
          nt: URI,
          it: [1],
        },
      },
      // nt: UniformResourceLocatable, <-- Assigned later to avoid potential circular dependency.
    },
    search: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        query: {
          nt: String,
          it: [1],
        },
        type: {
          nt: SearchType,
          it: [1],
        },
      },
      // nt: SearchResultItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    securityAdvisories: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        classifications: {
          nt: SecurityAdvisoryClassification,
          it: [0, [1]],
        },
        epssPercentage: {
          nt: Float,
          it: [0],
        },
        epssPercentile: {
          nt: Float,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        identifier: {
          nt: SecurityAdvisoryIdentifierFilter,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SecurityAdvisoryOrder,
          it: [0],
        },
        publishedSince: {
          nt: DateTime,
          it: [0],
        },
        updatedSince: {
          nt: DateTime,
          it: [0],
        },
      },
      // nt: SecurityAdvisoryConnection, <-- Assigned later to avoid potential circular dependency.
    },
    securityAdvisory: {
      a: {
        ghsaId: {
          nt: String,
          it: [1],
        },
      },
      // nt: SecurityAdvisory, <-- Assigned later to avoid potential circular dependency.
    },
    securityVulnerabilities: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        classifications: {
          nt: SecurityAdvisoryClassification,
          it: [0, [1]],
        },
        ecosystem: {
          nt: SecurityAdvisoryEcosystem,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        orderBy: {
          nt: SecurityVulnerabilityOrder,
          it: [0],
        },
        package: {
          nt: String,
          it: [0],
        },
        severities: {
          nt: SecurityAdvisorySeverity,
          it: [0, [1]],
        },
      },
      // nt: SecurityVulnerabilityConnection, <-- Assigned later to avoid potential circular dependency.
    },
    sponsorables: {
      a: {
        after: {
          nt: String,
          it: [0],
        },
        before: {
          nt: String,
          it: [0],
        },
        dependencyEcosystem: {
          nt: SecurityAdvisoryEcosystem,
          it: [0],
        },
        ecosystem: {
          nt: DependencyGraphEcosystem,
          it: [0],
        },
        first: {
          nt: Int,
          it: [0],
        },
        last: {
          nt: Int,
          it: [0],
        },
        onlyDependencies: {
          nt: Boolean,
          it: [0],
        },
        orderBy: {
          nt: SponsorableOrder,
          it: [0],
        },
        orgLoginForDependencies: {
          nt: String,
          it: [0],
        },
      },
      // nt: SponsorableItemConnection, <-- Assigned later to avoid potential circular dependency.
    },
    topic: {
      a: {
        name: {
          nt: String,
          it: [1],
        },
      },
      // nt: Topic, <-- Assigned later to avoid potential circular dependency.
    },
    user: {
      a: {
        login: {
          nt: String,
          it: [1],
        },
      },
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
    viewer: {
      // nt: User, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

const Mutation: $$Utilities.SchemaDrivenDataMap.OutputObject = {
  f: {
    abortQueuedMigrations: {
      a: {
        input: {
          nt: AbortQueuedMigrationsInput,
          it: [1],
        },
      },
      // nt: AbortQueuedMigrationsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    abortRepositoryMigration: {
      a: {
        input: {
          nt: AbortRepositoryMigrationInput,
          it: [1],
        },
      },
      // nt: AbortRepositoryMigrationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    acceptEnterpriseAdministratorInvitation: {
      a: {
        input: {
          nt: AcceptEnterpriseAdministratorInvitationInput,
          it: [1],
        },
      },
      // nt: AcceptEnterpriseAdministratorInvitationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    acceptEnterpriseMemberInvitation: {
      a: {
        input: {
          nt: AcceptEnterpriseMemberInvitationInput,
          it: [1],
        },
      },
      // nt: AcceptEnterpriseMemberInvitationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    acceptTopicSuggestion: {
      a: {
        input: {
          nt: AcceptTopicSuggestionInput,
          it: [1],
        },
      },
      // nt: AcceptTopicSuggestionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    accessUserNamespaceRepository: {
      a: {
        input: {
          nt: AccessUserNamespaceRepositoryInput,
          it: [1],
        },
      },
      // nt: AccessUserNamespaceRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addAssigneesToAssignable: {
      a: {
        input: {
          nt: AddAssigneesToAssignableInput,
          it: [1],
        },
      },
      // nt: AddAssigneesToAssignablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addComment: {
      a: {
        input: {
          nt: AddCommentInput,
          it: [1],
        },
      },
      // nt: AddCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addDiscussionComment: {
      a: {
        input: {
          nt: AddDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: AddDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addDiscussionPollVote: {
      a: {
        input: {
          nt: AddDiscussionPollVoteInput,
          it: [1],
        },
      },
      // nt: AddDiscussionPollVotePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addEnterpriseOrganizationMember: {
      a: {
        input: {
          nt: AddEnterpriseOrganizationMemberInput,
          it: [1],
        },
      },
      // nt: AddEnterpriseOrganizationMemberPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addEnterpriseSupportEntitlement: {
      a: {
        input: {
          nt: AddEnterpriseSupportEntitlementInput,
          it: [1],
        },
      },
      // nt: AddEnterpriseSupportEntitlementPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addLabelsToLabelable: {
      a: {
        input: {
          nt: AddLabelsToLabelableInput,
          it: [1],
        },
      },
      // nt: AddLabelsToLabelablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addProjectCard: {
      a: {
        input: {
          nt: AddProjectCardInput,
          it: [1],
        },
      },
      // nt: AddProjectCardPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addProjectColumn: {
      a: {
        input: {
          nt: AddProjectColumnInput,
          it: [1],
        },
      },
      // nt: AddProjectColumnPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addProjectV2DraftIssue: {
      a: {
        input: {
          nt: AddProjectV2DraftIssueInput,
          it: [1],
        },
      },
      // nt: AddProjectV2DraftIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addProjectV2ItemById: {
      a: {
        input: {
          nt: AddProjectV2ItemByIdInput,
          it: [1],
        },
      },
      // nt: AddProjectV2ItemByIdPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addPullRequestReview: {
      a: {
        input: {
          nt: AddPullRequestReviewInput,
          it: [1],
        },
      },
      // nt: AddPullRequestReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addPullRequestReviewComment: {
      a: {
        input: {
          nt: AddPullRequestReviewCommentInput,
          it: [1],
        },
      },
      // nt: AddPullRequestReviewCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addPullRequestReviewThread: {
      a: {
        input: {
          nt: AddPullRequestReviewThreadInput,
          it: [1],
        },
      },
      // nt: AddPullRequestReviewThreadPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addPullRequestReviewThreadReply: {
      a: {
        input: {
          nt: AddPullRequestReviewThreadReplyInput,
          it: [1],
        },
      },
      // nt: AddPullRequestReviewThreadReplyPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addReaction: {
      a: {
        input: {
          nt: AddReactionInput,
          it: [1],
        },
      },
      // nt: AddReactionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addStar: {
      a: {
        input: {
          nt: AddStarInput,
          it: [1],
        },
      },
      // nt: AddStarPayload, <-- Assigned later to avoid potential circular dependency.
    },
    addSubIssue: {
      a: {
        input: {
          nt: AddSubIssueInput,
          it: [1],
        },
      },
      // nt: AddSubIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addUpvote: {
      a: {
        input: {
          nt: AddUpvoteInput,
          it: [1],
        },
      },
      // nt: AddUpvotePayload, <-- Assigned later to avoid potential circular dependency.
    },
    addVerifiableDomain: {
      a: {
        input: {
          nt: AddVerifiableDomainInput,
          it: [1],
        },
      },
      // nt: AddVerifiableDomainPayload, <-- Assigned later to avoid potential circular dependency.
    },
    approveDeployments: {
      a: {
        input: {
          nt: ApproveDeploymentsInput,
          it: [1],
        },
      },
      // nt: ApproveDeploymentsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    approveVerifiableDomain: {
      a: {
        input: {
          nt: ApproveVerifiableDomainInput,
          it: [1],
        },
      },
      // nt: ApproveVerifiableDomainPayload, <-- Assigned later to avoid potential circular dependency.
    },
    archiveProjectV2Item: {
      a: {
        input: {
          nt: ArchiveProjectV2ItemInput,
          it: [1],
        },
      },
      // nt: ArchiveProjectV2ItemPayload, <-- Assigned later to avoid potential circular dependency.
    },
    archiveRepository: {
      a: {
        input: {
          nt: ArchiveRepositoryInput,
          it: [1],
        },
      },
      // nt: ArchiveRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    cancelEnterpriseAdminInvitation: {
      a: {
        input: {
          nt: CancelEnterpriseAdminInvitationInput,
          it: [1],
        },
      },
      // nt: CancelEnterpriseAdminInvitationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    cancelEnterpriseMemberInvitation: {
      a: {
        input: {
          nt: CancelEnterpriseMemberInvitationInput,
          it: [1],
        },
      },
      // nt: CancelEnterpriseMemberInvitationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    cancelSponsorship: {
      a: {
        input: {
          nt: CancelSponsorshipInput,
          it: [1],
        },
      },
      // nt: CancelSponsorshipPayload, <-- Assigned later to avoid potential circular dependency.
    },
    changeUserStatus: {
      a: {
        input: {
          nt: ChangeUserStatusInput,
          it: [1],
        },
      },
      // nt: ChangeUserStatusPayload, <-- Assigned later to avoid potential circular dependency.
    },
    clearLabelsFromLabelable: {
      a: {
        input: {
          nt: ClearLabelsFromLabelableInput,
          it: [1],
        },
      },
      // nt: ClearLabelsFromLabelablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    clearProjectV2ItemFieldValue: {
      a: {
        input: {
          nt: ClearProjectV2ItemFieldValueInput,
          it: [1],
        },
      },
      // nt: ClearProjectV2ItemFieldValuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    cloneProject: {
      a: {
        input: {
          nt: CloneProjectInput,
          it: [1],
        },
      },
      // nt: CloneProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    cloneTemplateRepository: {
      a: {
        input: {
          nt: CloneTemplateRepositoryInput,
          it: [1],
        },
      },
      // nt: CloneTemplateRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    closeDiscussion: {
      a: {
        input: {
          nt: CloseDiscussionInput,
          it: [1],
        },
      },
      // nt: CloseDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    closeIssue: {
      a: {
        input: {
          nt: CloseIssueInput,
          it: [1],
        },
      },
      // nt: CloseIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    closePullRequest: {
      a: {
        input: {
          nt: ClosePullRequestInput,
          it: [1],
        },
      },
      // nt: ClosePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    convertProjectCardNoteToIssue: {
      a: {
        input: {
          nt: ConvertProjectCardNoteToIssueInput,
          it: [1],
        },
      },
      // nt: ConvertProjectCardNoteToIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    convertProjectV2DraftIssueItemToIssue: {
      a: {
        input: {
          nt: ConvertProjectV2DraftIssueItemToIssueInput,
          it: [1],
        },
      },
      // nt: ConvertProjectV2DraftIssueItemToIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    convertPullRequestToDraft: {
      a: {
        input: {
          nt: ConvertPullRequestToDraftInput,
          it: [1],
        },
      },
      // nt: ConvertPullRequestToDraftPayload, <-- Assigned later to avoid potential circular dependency.
    },
    copyProjectV2: {
      a: {
        input: {
          nt: CopyProjectV2Input,
          it: [1],
        },
      },
      // nt: CopyProjectV2Payload, <-- Assigned later to avoid potential circular dependency.
    },
    createAttributionInvitation: {
      a: {
        input: {
          nt: CreateAttributionInvitationInput,
          it: [1],
        },
      },
      // nt: CreateAttributionInvitationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createBranchProtectionRule: {
      a: {
        input: {
          nt: CreateBranchProtectionRuleInput,
          it: [1],
        },
      },
      // nt: CreateBranchProtectionRulePayload, <-- Assigned later to avoid potential circular dependency.
    },
    createCheckRun: {
      a: {
        input: {
          nt: CreateCheckRunInput,
          it: [1],
        },
      },
      // nt: CreateCheckRunPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createCheckSuite: {
      a: {
        input: {
          nt: CreateCheckSuiteInput,
          it: [1],
        },
      },
      // nt: CreateCheckSuitePayload, <-- Assigned later to avoid potential circular dependency.
    },
    createCommitOnBranch: {
      a: {
        input: {
          nt: CreateCommitOnBranchInput,
          it: [1],
        },
      },
      // nt: CreateCommitOnBranchPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createDeployment: {
      a: {
        input: {
          nt: CreateDeploymentInput,
          it: [1],
        },
      },
      // nt: CreateDeploymentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createDeploymentStatus: {
      a: {
        input: {
          nt: CreateDeploymentStatusInput,
          it: [1],
        },
      },
      // nt: CreateDeploymentStatusPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createDiscussion: {
      a: {
        input: {
          nt: CreateDiscussionInput,
          it: [1],
        },
      },
      // nt: CreateDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createEnterpriseOrganization: {
      a: {
        input: {
          nt: CreateEnterpriseOrganizationInput,
          it: [1],
        },
      },
      // nt: CreateEnterpriseOrganizationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createEnvironment: {
      a: {
        input: {
          nt: CreateEnvironmentInput,
          it: [1],
        },
      },
      // nt: CreateEnvironmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createIpAllowListEntry: {
      a: {
        input: {
          nt: CreateIpAllowListEntryInput,
          it: [1],
        },
      },
      // nt: CreateIpAllowListEntryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createIssue: {
      a: {
        input: {
          nt: CreateIssueInput,
          it: [1],
        },
      },
      // nt: CreateIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    createLabel: {
      a: {
        input: {
          nt: CreateLabelInput,
          it: [1],
        },
      },
      // nt: CreateLabelPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createLinkedBranch: {
      a: {
        input: {
          nt: CreateLinkedBranchInput,
          it: [1],
        },
      },
      // nt: CreateLinkedBranchPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createMigrationSource: {
      a: {
        input: {
          nt: CreateMigrationSourceInput,
          it: [1],
        },
      },
      // nt: CreateMigrationSourcePayload, <-- Assigned later to avoid potential circular dependency.
    },
    createProject: {
      a: {
        input: {
          nt: CreateProjectInput,
          it: [1],
        },
      },
      // nt: CreateProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createProjectV2: {
      a: {
        input: {
          nt: CreateProjectV2Input,
          it: [1],
        },
      },
      // nt: CreateProjectV2Payload, <-- Assigned later to avoid potential circular dependency.
    },
    createProjectV2Field: {
      a: {
        input: {
          nt: CreateProjectV2FieldInput,
          it: [1],
        },
      },
      // nt: CreateProjectV2FieldPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createProjectV2StatusUpdate: {
      a: {
        input: {
          nt: CreateProjectV2StatusUpdateInput,
          it: [1],
        },
      },
      // nt: CreateProjectV2StatusUpdatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    createPullRequest: {
      a: {
        input: {
          nt: CreatePullRequestInput,
          it: [1],
        },
      },
      // nt: CreatePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createRef: {
      a: {
        input: {
          nt: CreateRefInput,
          it: [1],
        },
      },
      // nt: CreateRefPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createRepository: {
      a: {
        input: {
          nt: CreateRepositoryInput,
          it: [1],
        },
      },
      // nt: CreateRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createRepositoryRuleset: {
      a: {
        input: {
          nt: CreateRepositoryRulesetInput,
          it: [1],
        },
      },
      // nt: CreateRepositoryRulesetPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createSponsorsListing: {
      a: {
        input: {
          nt: CreateSponsorsListingInput,
          it: [1],
        },
      },
      // nt: CreateSponsorsListingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createSponsorsTier: {
      a: {
        input: {
          nt: CreateSponsorsTierInput,
          it: [1],
        },
      },
      // nt: CreateSponsorsTierPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createSponsorship: {
      a: {
        input: {
          nt: CreateSponsorshipInput,
          it: [1],
        },
      },
      // nt: CreateSponsorshipPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createSponsorships: {
      a: {
        input: {
          nt: CreateSponsorshipsInput,
          it: [1],
        },
      },
      // nt: CreateSponsorshipsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createTeamDiscussion: {
      a: {
        input: {
          nt: CreateTeamDiscussionInput,
          it: [1],
        },
      },
      // nt: CreateTeamDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createTeamDiscussionComment: {
      a: {
        input: {
          nt: CreateTeamDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: CreateTeamDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    createUserList: {
      a: {
        input: {
          nt: CreateUserListInput,
          it: [1],
        },
      },
      // nt: CreateUserListPayload, <-- Assigned later to avoid potential circular dependency.
    },
    declineTopicSuggestion: {
      a: {
        input: {
          nt: DeclineTopicSuggestionInput,
          it: [1],
        },
      },
      // nt: DeclineTopicSuggestionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteBranchProtectionRule: {
      a: {
        input: {
          nt: DeleteBranchProtectionRuleInput,
          it: [1],
        },
      },
      // nt: DeleteBranchProtectionRulePayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteDeployment: {
      a: {
        input: {
          nt: DeleteDeploymentInput,
          it: [1],
        },
      },
      // nt: DeleteDeploymentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteDiscussion: {
      a: {
        input: {
          nt: DeleteDiscussionInput,
          it: [1],
        },
      },
      // nt: DeleteDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteDiscussionComment: {
      a: {
        input: {
          nt: DeleteDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: DeleteDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteEnvironment: {
      a: {
        input: {
          nt: DeleteEnvironmentInput,
          it: [1],
        },
      },
      // nt: DeleteEnvironmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteIpAllowListEntry: {
      a: {
        input: {
          nt: DeleteIpAllowListEntryInput,
          it: [1],
        },
      },
      // nt: DeleteIpAllowListEntryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteIssue: {
      a: {
        input: {
          nt: DeleteIssueInput,
          it: [1],
        },
      },
      // nt: DeleteIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteIssueComment: {
      a: {
        input: {
          nt: DeleteIssueCommentInput,
          it: [1],
        },
      },
      // nt: DeleteIssueCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteLabel: {
      a: {
        input: {
          nt: DeleteLabelInput,
          it: [1],
        },
      },
      // nt: DeleteLabelPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteLinkedBranch: {
      a: {
        input: {
          nt: DeleteLinkedBranchInput,
          it: [1],
        },
      },
      // nt: DeleteLinkedBranchPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deletePackageVersion: {
      a: {
        input: {
          nt: DeletePackageVersionInput,
          it: [1],
        },
      },
      // nt: DeletePackageVersionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProject: {
      a: {
        input: {
          nt: DeleteProjectInput,
          it: [1],
        },
      },
      // nt: DeleteProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectCard: {
      a: {
        input: {
          nt: DeleteProjectCardInput,
          it: [1],
        },
      },
      // nt: DeleteProjectCardPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectColumn: {
      a: {
        input: {
          nt: DeleteProjectColumnInput,
          it: [1],
        },
      },
      // nt: DeleteProjectColumnPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectV2: {
      a: {
        input: {
          nt: DeleteProjectV2Input,
          it: [1],
        },
      },
      // nt: DeleteProjectV2Payload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectV2Field: {
      a: {
        input: {
          nt: DeleteProjectV2FieldInput,
          it: [1],
        },
      },
      // nt: DeleteProjectV2FieldPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectV2Item: {
      a: {
        input: {
          nt: DeleteProjectV2ItemInput,
          it: [1],
        },
      },
      // nt: DeleteProjectV2ItemPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectV2StatusUpdate: {
      a: {
        input: {
          nt: DeleteProjectV2StatusUpdateInput,
          it: [1],
        },
      },
      // nt: DeleteProjectV2StatusUpdatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteProjectV2Workflow: {
      a: {
        input: {
          nt: DeleteProjectV2WorkflowInput,
          it: [1],
        },
      },
      // nt: DeleteProjectV2WorkflowPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deletePullRequestReview: {
      a: {
        input: {
          nt: DeletePullRequestReviewInput,
          it: [1],
        },
      },
      // nt: DeletePullRequestReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deletePullRequestReviewComment: {
      a: {
        input: {
          nt: DeletePullRequestReviewCommentInput,
          it: [1],
        },
      },
      // nt: DeletePullRequestReviewCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteRef: {
      a: {
        input: {
          nt: DeleteRefInput,
          it: [1],
        },
      },
      // nt: DeleteRefPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteRepositoryRuleset: {
      a: {
        input: {
          nt: DeleteRepositoryRulesetInput,
          it: [1],
        },
      },
      // nt: DeleteRepositoryRulesetPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteTeamDiscussion: {
      a: {
        input: {
          nt: DeleteTeamDiscussionInput,
          it: [1],
        },
      },
      // nt: DeleteTeamDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteTeamDiscussionComment: {
      a: {
        input: {
          nt: DeleteTeamDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: DeleteTeamDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteUserList: {
      a: {
        input: {
          nt: DeleteUserListInput,
          it: [1],
        },
      },
      // nt: DeleteUserListPayload, <-- Assigned later to avoid potential circular dependency.
    },
    deleteVerifiableDomain: {
      a: {
        input: {
          nt: DeleteVerifiableDomainInput,
          it: [1],
        },
      },
      // nt: DeleteVerifiableDomainPayload, <-- Assigned later to avoid potential circular dependency.
    },
    dequeuePullRequest: {
      a: {
        input: {
          nt: DequeuePullRequestInput,
          it: [1],
        },
      },
      // nt: DequeuePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    disablePullRequestAutoMerge: {
      a: {
        input: {
          nt: DisablePullRequestAutoMergeInput,
          it: [1],
        },
      },
      // nt: DisablePullRequestAutoMergePayload, <-- Assigned later to avoid potential circular dependency.
    },
    dismissPullRequestReview: {
      a: {
        input: {
          nt: DismissPullRequestReviewInput,
          it: [1],
        },
      },
      // nt: DismissPullRequestReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    dismissRepositoryVulnerabilityAlert: {
      a: {
        input: {
          nt: DismissRepositoryVulnerabilityAlertInput,
          it: [1],
        },
      },
      // nt: DismissRepositoryVulnerabilityAlertPayload, <-- Assigned later to avoid potential circular dependency.
    },
    enablePullRequestAutoMerge: {
      a: {
        input: {
          nt: EnablePullRequestAutoMergeInput,
          it: [1],
        },
      },
      // nt: EnablePullRequestAutoMergePayload, <-- Assigned later to avoid potential circular dependency.
    },
    enqueuePullRequest: {
      a: {
        input: {
          nt: EnqueuePullRequestInput,
          it: [1],
        },
      },
      // nt: EnqueuePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    followOrganization: {
      a: {
        input: {
          nt: FollowOrganizationInput,
          it: [1],
        },
      },
      // nt: FollowOrganizationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    followUser: {
      a: {
        input: {
          nt: FollowUserInput,
          it: [1],
        },
      },
      // nt: FollowUserPayload, <-- Assigned later to avoid potential circular dependency.
    },
    grantEnterpriseOrganizationsMigratorRole: {
      a: {
        input: {
          nt: GrantEnterpriseOrganizationsMigratorRoleInput,
          it: [1],
        },
      },
      // nt: GrantEnterpriseOrganizationsMigratorRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    grantMigratorRole: {
      a: {
        input: {
          nt: GrantMigratorRoleInput,
          it: [1],
        },
      },
      // nt: GrantMigratorRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    importProject: {
      a: {
        input: {
          nt: ImportProjectInput,
          it: [1],
        },
      },
      // nt: ImportProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    inviteEnterpriseAdmin: {
      a: {
        input: {
          nt: InviteEnterpriseAdminInput,
          it: [1],
        },
      },
      // nt: InviteEnterpriseAdminPayload, <-- Assigned later to avoid potential circular dependency.
    },
    inviteEnterpriseMember: {
      a: {
        input: {
          nt: InviteEnterpriseMemberInput,
          it: [1],
        },
      },
      // nt: InviteEnterpriseMemberPayload, <-- Assigned later to avoid potential circular dependency.
    },
    linkProjectV2ToRepository: {
      a: {
        input: {
          nt: LinkProjectV2ToRepositoryInput,
          it: [1],
        },
      },
      // nt: LinkProjectV2ToRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    linkProjectV2ToTeam: {
      a: {
        input: {
          nt: LinkProjectV2ToTeamInput,
          it: [1],
        },
      },
      // nt: LinkProjectV2ToTeamPayload, <-- Assigned later to avoid potential circular dependency.
    },
    linkRepositoryToProject: {
      a: {
        input: {
          nt: LinkRepositoryToProjectInput,
          it: [1],
        },
      },
      // nt: LinkRepositoryToProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    lockLockable: {
      a: {
        input: {
          nt: LockLockableInput,
          it: [1],
        },
      },
      // nt: LockLockablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    markDiscussionCommentAsAnswer: {
      a: {
        input: {
          nt: MarkDiscussionCommentAsAnswerInput,
          it: [1],
        },
      },
      // nt: MarkDiscussionCommentAsAnswerPayload, <-- Assigned later to avoid potential circular dependency.
    },
    markFileAsViewed: {
      a: {
        input: {
          nt: MarkFileAsViewedInput,
          it: [1],
        },
      },
      // nt: MarkFileAsViewedPayload, <-- Assigned later to avoid potential circular dependency.
    },
    markProjectV2AsTemplate: {
      a: {
        input: {
          nt: MarkProjectV2AsTemplateInput,
          it: [1],
        },
      },
      // nt: MarkProjectV2AsTemplatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    markPullRequestReadyForReview: {
      a: {
        input: {
          nt: MarkPullRequestReadyForReviewInput,
          it: [1],
        },
      },
      // nt: MarkPullRequestReadyForReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    mergeBranch: {
      a: {
        input: {
          nt: MergeBranchInput,
          it: [1],
        },
      },
      // nt: MergeBranchPayload, <-- Assigned later to avoid potential circular dependency.
    },
    mergePullRequest: {
      a: {
        input: {
          nt: MergePullRequestInput,
          it: [1],
        },
      },
      // nt: MergePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    minimizeComment: {
      a: {
        input: {
          nt: MinimizeCommentInput,
          it: [1],
        },
      },
      // nt: MinimizeCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    moveProjectCard: {
      a: {
        input: {
          nt: MoveProjectCardInput,
          it: [1],
        },
      },
      // nt: MoveProjectCardPayload, <-- Assigned later to avoid potential circular dependency.
    },
    moveProjectColumn: {
      a: {
        input: {
          nt: MoveProjectColumnInput,
          it: [1],
        },
      },
      // nt: MoveProjectColumnPayload, <-- Assigned later to avoid potential circular dependency.
    },
    pinEnvironment: {
      a: {
        input: {
          nt: PinEnvironmentInput,
          it: [1],
        },
      },
      // nt: PinEnvironmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    pinIssue: {
      a: {
        input: {
          nt: PinIssueInput,
          it: [1],
        },
      },
      // nt: PinIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    publishSponsorsTier: {
      a: {
        input: {
          nt: PublishSponsorsTierInput,
          it: [1],
        },
      },
      // nt: PublishSponsorsTierPayload, <-- Assigned later to avoid potential circular dependency.
    },
    regenerateEnterpriseIdentityProviderRecoveryCodes: {
      a: {
        input: {
          nt: RegenerateEnterpriseIdentityProviderRecoveryCodesInput,
          it: [1],
        },
      },
      // nt: RegenerateEnterpriseIdentityProviderRecoveryCodesPayload, <-- Assigned later to avoid potential circular dependency.
    },
    regenerateVerifiableDomainToken: {
      a: {
        input: {
          nt: RegenerateVerifiableDomainTokenInput,
          it: [1],
        },
      },
      // nt: RegenerateVerifiableDomainTokenPayload, <-- Assigned later to avoid potential circular dependency.
    },
    rejectDeployments: {
      a: {
        input: {
          nt: RejectDeploymentsInput,
          it: [1],
        },
      },
      // nt: RejectDeploymentsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeAssigneesFromAssignable: {
      a: {
        input: {
          nt: RemoveAssigneesFromAssignableInput,
          it: [1],
        },
      },
      // nt: RemoveAssigneesFromAssignablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeEnterpriseAdmin: {
      a: {
        input: {
          nt: RemoveEnterpriseAdminInput,
          it: [1],
        },
      },
      // nt: RemoveEnterpriseAdminPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeEnterpriseIdentityProvider: {
      a: {
        input: {
          nt: RemoveEnterpriseIdentityProviderInput,
          it: [1],
        },
      },
      // nt: RemoveEnterpriseIdentityProviderPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeEnterpriseMember: {
      a: {
        input: {
          nt: RemoveEnterpriseMemberInput,
          it: [1],
        },
      },
      // nt: RemoveEnterpriseMemberPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeEnterpriseOrganization: {
      a: {
        input: {
          nt: RemoveEnterpriseOrganizationInput,
          it: [1],
        },
      },
      // nt: RemoveEnterpriseOrganizationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeEnterpriseSupportEntitlement: {
      a: {
        input: {
          nt: RemoveEnterpriseSupportEntitlementInput,
          it: [1],
        },
      },
      // nt: RemoveEnterpriseSupportEntitlementPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeLabelsFromLabelable: {
      a: {
        input: {
          nt: RemoveLabelsFromLabelableInput,
          it: [1],
        },
      },
      // nt: RemoveLabelsFromLabelablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeOutsideCollaborator: {
      a: {
        input: {
          nt: RemoveOutsideCollaboratorInput,
          it: [1],
        },
      },
      // nt: RemoveOutsideCollaboratorPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeReaction: {
      a: {
        input: {
          nt: RemoveReactionInput,
          it: [1],
        },
      },
      // nt: RemoveReactionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeStar: {
      a: {
        input: {
          nt: RemoveStarInput,
          it: [1],
        },
      },
      // nt: RemoveStarPayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeSubIssue: {
      a: {
        input: {
          nt: RemoveSubIssueInput,
          it: [1],
        },
      },
      // nt: RemoveSubIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    removeUpvote: {
      a: {
        input: {
          nt: RemoveUpvoteInput,
          it: [1],
        },
      },
      // nt: RemoveUpvotePayload, <-- Assigned later to avoid potential circular dependency.
    },
    reopenDiscussion: {
      a: {
        input: {
          nt: ReopenDiscussionInput,
          it: [1],
        },
      },
      // nt: ReopenDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    reopenIssue: {
      a: {
        input: {
          nt: ReopenIssueInput,
          it: [1],
        },
      },
      // nt: ReopenIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    reopenPullRequest: {
      a: {
        input: {
          nt: ReopenPullRequestInput,
          it: [1],
        },
      },
      // nt: ReopenPullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    reorderEnvironment: {
      a: {
        input: {
          nt: ReorderEnvironmentInput,
          it: [1],
        },
      },
      // nt: ReorderEnvironmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    reprioritizeSubIssue: {
      a: {
        input: {
          nt: ReprioritizeSubIssueInput,
          it: [1],
        },
      },
      // nt: ReprioritizeSubIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    requestReviews: {
      a: {
        input: {
          nt: RequestReviewsInput,
          it: [1],
        },
      },
      // nt: RequestReviewsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    rerequestCheckSuite: {
      a: {
        input: {
          nt: RerequestCheckSuiteInput,
          it: [1],
        },
      },
      // nt: RerequestCheckSuitePayload, <-- Assigned later to avoid potential circular dependency.
    },
    resolveReviewThread: {
      a: {
        input: {
          nt: ResolveReviewThreadInput,
          it: [1],
        },
      },
      // nt: ResolveReviewThreadPayload, <-- Assigned later to avoid potential circular dependency.
    },
    retireSponsorsTier: {
      a: {
        input: {
          nt: RetireSponsorsTierInput,
          it: [1],
        },
      },
      // nt: RetireSponsorsTierPayload, <-- Assigned later to avoid potential circular dependency.
    },
    revertPullRequest: {
      a: {
        input: {
          nt: RevertPullRequestInput,
          it: [1],
        },
      },
      // nt: RevertPullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    revokeEnterpriseOrganizationsMigratorRole: {
      a: {
        input: {
          nt: RevokeEnterpriseOrganizationsMigratorRoleInput,
          it: [1],
        },
      },
      // nt: RevokeEnterpriseOrganizationsMigratorRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    revokeMigratorRole: {
      a: {
        input: {
          nt: RevokeMigratorRoleInput,
          it: [1],
        },
      },
      // nt: RevokeMigratorRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    setEnterpriseIdentityProvider: {
      a: {
        input: {
          nt: SetEnterpriseIdentityProviderInput,
          it: [1],
        },
      },
      // nt: SetEnterpriseIdentityProviderPayload, <-- Assigned later to avoid potential circular dependency.
    },
    setOrganizationInteractionLimit: {
      a: {
        input: {
          nt: SetOrganizationInteractionLimitInput,
          it: [1],
        },
      },
      // nt: SetOrganizationInteractionLimitPayload, <-- Assigned later to avoid potential circular dependency.
    },
    setRepositoryInteractionLimit: {
      a: {
        input: {
          nt: SetRepositoryInteractionLimitInput,
          it: [1],
        },
      },
      // nt: SetRepositoryInteractionLimitPayload, <-- Assigned later to avoid potential circular dependency.
    },
    setUserInteractionLimit: {
      a: {
        input: {
          nt: SetUserInteractionLimitInput,
          it: [1],
        },
      },
      // nt: SetUserInteractionLimitPayload, <-- Assigned later to avoid potential circular dependency.
    },
    startOrganizationMigration: {
      a: {
        input: {
          nt: StartOrganizationMigrationInput,
          it: [1],
        },
      },
      // nt: StartOrganizationMigrationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    startRepositoryMigration: {
      a: {
        input: {
          nt: StartRepositoryMigrationInput,
          it: [1],
        },
      },
      // nt: StartRepositoryMigrationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    submitPullRequestReview: {
      a: {
        input: {
          nt: SubmitPullRequestReviewInput,
          it: [1],
        },
      },
      // nt: SubmitPullRequestReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    transferEnterpriseOrganization: {
      a: {
        input: {
          nt: TransferEnterpriseOrganizationInput,
          it: [1],
        },
      },
      // nt: TransferEnterpriseOrganizationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    transferIssue: {
      a: {
        input: {
          nt: TransferIssueInput,
          it: [1],
        },
      },
      // nt: TransferIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    unarchiveProjectV2Item: {
      a: {
        input: {
          nt: UnarchiveProjectV2ItemInput,
          it: [1],
        },
      },
      // nt: UnarchiveProjectV2ItemPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unarchiveRepository: {
      a: {
        input: {
          nt: UnarchiveRepositoryInput,
          it: [1],
        },
      },
      // nt: UnarchiveRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unfollowOrganization: {
      a: {
        input: {
          nt: UnfollowOrganizationInput,
          it: [1],
        },
      },
      // nt: UnfollowOrganizationPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unfollowUser: {
      a: {
        input: {
          nt: UnfollowUserInput,
          it: [1],
        },
      },
      // nt: UnfollowUserPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unlinkProjectV2FromRepository: {
      a: {
        input: {
          nt: UnlinkProjectV2FromRepositoryInput,
          it: [1],
        },
      },
      // nt: UnlinkProjectV2FromRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unlinkProjectV2FromTeam: {
      a: {
        input: {
          nt: UnlinkProjectV2FromTeamInput,
          it: [1],
        },
      },
      // nt: UnlinkProjectV2FromTeamPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unlinkRepositoryFromProject: {
      a: {
        input: {
          nt: UnlinkRepositoryFromProjectInput,
          it: [1],
        },
      },
      // nt: UnlinkRepositoryFromProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unlockLockable: {
      a: {
        input: {
          nt: UnlockLockableInput,
          it: [1],
        },
      },
      // nt: UnlockLockablePayload, <-- Assigned later to avoid potential circular dependency.
    },
    unmarkDiscussionCommentAsAnswer: {
      a: {
        input: {
          nt: UnmarkDiscussionCommentAsAnswerInput,
          it: [1],
        },
      },
      // nt: UnmarkDiscussionCommentAsAnswerPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unmarkFileAsViewed: {
      a: {
        input: {
          nt: UnmarkFileAsViewedInput,
          it: [1],
        },
      },
      // nt: UnmarkFileAsViewedPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unmarkIssueAsDuplicate: {
      a: {
        input: {
          nt: UnmarkIssueAsDuplicateInput,
          it: [1],
        },
      },
      // nt: UnmarkIssueAsDuplicatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    unmarkProjectV2AsTemplate: {
      a: {
        input: {
          nt: UnmarkProjectV2AsTemplateInput,
          it: [1],
        },
      },
      // nt: UnmarkProjectV2AsTemplatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    unminimizeComment: {
      a: {
        input: {
          nt: UnminimizeCommentInput,
          it: [1],
        },
      },
      // nt: UnminimizeCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    unpinIssue: {
      a: {
        input: {
          nt: UnpinIssueInput,
          it: [1],
        },
      },
      // nt: UnpinIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    unresolveReviewThread: {
      a: {
        input: {
          nt: UnresolveReviewThreadInput,
          it: [1],
        },
      },
      // nt: UnresolveReviewThreadPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateBranchProtectionRule: {
      a: {
        input: {
          nt: UpdateBranchProtectionRuleInput,
          it: [1],
        },
      },
      // nt: UpdateBranchProtectionRulePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateCheckRun: {
      a: {
        input: {
          nt: UpdateCheckRunInput,
          it: [1],
        },
      },
      // nt: UpdateCheckRunPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateCheckSuitePreferences: {
      a: {
        input: {
          nt: UpdateCheckSuitePreferencesInput,
          it: [1],
        },
      },
      // nt: UpdateCheckSuitePreferencesPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateDiscussion: {
      a: {
        input: {
          nt: UpdateDiscussionInput,
          it: [1],
        },
      },
      // nt: UpdateDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateDiscussionComment: {
      a: {
        input: {
          nt: UpdateDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: UpdateDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseAdministratorRole: {
      a: {
        input: {
          nt: UpdateEnterpriseAdministratorRoleInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseAdministratorRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseAllowPrivateRepositoryForkingSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseDefaultRepositoryPermissionSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseDefaultRepositoryPermissionSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseDefaultRepositoryPermissionSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseDeployKeySetting: {
      a: {
        input: {
          nt: UpdateEnterpriseDeployKeySettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseDeployKeySettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanCreateRepositoriesSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanDeleteIssuesSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanDeleteIssuesSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanDeleteIssuesSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanDeleteRepositoriesSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanInviteCollaboratorsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanMakePurchasesSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanMakePurchasesSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanMakePurchasesSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanUpdateProtectedBranchesSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseMembersCanViewDependencyInsightsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseOrganizationProjectsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseOrganizationProjectsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseOrganizationProjectsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseOwnerOrganizationRole: {
      a: {
        input: {
          nt: UpdateEnterpriseOwnerOrganizationRoleInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseOwnerOrganizationRolePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseProfile: {
      a: {
        input: {
          nt: UpdateEnterpriseProfileInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseProfilePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseRepositoryProjectsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseRepositoryProjectsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseRepositoryProjectsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseTeamDiscussionsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseTeamDiscussionsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseTeamDiscussionsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseTwoFactorAuthenticationDisallowedMethodsSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnterpriseTwoFactorAuthenticationRequiredSetting: {
      a: {
        input: {
          nt: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput,
          it: [1],
        },
      },
      // nt: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateEnvironment: {
      a: {
        input: {
          nt: UpdateEnvironmentInput,
          it: [1],
        },
      },
      // nt: UpdateEnvironmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateIpAllowListEnabledSetting: {
      a: {
        input: {
          nt: UpdateIpAllowListEnabledSettingInput,
          it: [1],
        },
      },
      // nt: UpdateIpAllowListEnabledSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateIpAllowListEntry: {
      a: {
        input: {
          nt: UpdateIpAllowListEntryInput,
          it: [1],
        },
      },
      // nt: UpdateIpAllowListEntryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateIpAllowListForInstalledAppsEnabledSetting: {
      a: {
        input: {
          nt: UpdateIpAllowListForInstalledAppsEnabledSettingInput,
          it: [1],
        },
      },
      // nt: UpdateIpAllowListForInstalledAppsEnabledSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateIssue: {
      a: {
        input: {
          nt: UpdateIssueInput,
          it: [1],
        },
      },
      // nt: UpdateIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateIssueComment: {
      a: {
        input: {
          nt: UpdateIssueCommentInput,
          it: [1],
        },
      },
      // nt: UpdateIssueCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateLabel: {
      a: {
        input: {
          nt: UpdateLabelInput,
          it: [1],
        },
      },
      // nt: UpdateLabelPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateNotificationRestrictionSetting: {
      a: {
        input: {
          nt: UpdateNotificationRestrictionSettingInput,
          it: [1],
        },
      },
      // nt: UpdateNotificationRestrictionSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateOrganizationAllowPrivateRepositoryForkingSetting: {
      a: {
        input: {
          nt: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput,
          it: [1],
        },
      },
      // nt: UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateOrganizationWebCommitSignoffSetting: {
      a: {
        input: {
          nt: UpdateOrganizationWebCommitSignoffSettingInput,
          it: [1],
        },
      },
      // nt: UpdateOrganizationWebCommitSignoffSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updatePatreonSponsorability: {
      a: {
        input: {
          nt: UpdatePatreonSponsorabilityInput,
          it: [1],
        },
      },
      // nt: UpdatePatreonSponsorabilityPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProject: {
      a: {
        input: {
          nt: UpdateProjectInput,
          it: [1],
        },
      },
      // nt: UpdateProjectPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectCard: {
      a: {
        input: {
          nt: UpdateProjectCardInput,
          it: [1],
        },
      },
      // nt: UpdateProjectCardPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectColumn: {
      a: {
        input: {
          nt: UpdateProjectColumnInput,
          it: [1],
        },
      },
      // nt: UpdateProjectColumnPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2: {
      a: {
        input: {
          nt: UpdateProjectV2Input,
          it: [1],
        },
      },
      // nt: UpdateProjectV2Payload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2Collaborators: {
      a: {
        input: {
          nt: UpdateProjectV2CollaboratorsInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2CollaboratorsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2DraftIssue: {
      a: {
        input: {
          nt: UpdateProjectV2DraftIssueInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2DraftIssuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2Field: {
      a: {
        input: {
          nt: UpdateProjectV2FieldInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2FieldPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2ItemFieldValue: {
      a: {
        input: {
          nt: UpdateProjectV2ItemFieldValueInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2ItemFieldValuePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2ItemPosition: {
      a: {
        input: {
          nt: UpdateProjectV2ItemPositionInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2ItemPositionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateProjectV2StatusUpdate: {
      a: {
        input: {
          nt: UpdateProjectV2StatusUpdateInput,
          it: [1],
        },
      },
      // nt: UpdateProjectV2StatusUpdatePayload, <-- Assigned later to avoid potential circular dependency.
    },
    updatePullRequest: {
      a: {
        input: {
          nt: UpdatePullRequestInput,
          it: [1],
        },
      },
      // nt: UpdatePullRequestPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updatePullRequestBranch: {
      a: {
        input: {
          nt: UpdatePullRequestBranchInput,
          it: [1],
        },
      },
      // nt: UpdatePullRequestBranchPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updatePullRequestReview: {
      a: {
        input: {
          nt: UpdatePullRequestReviewInput,
          it: [1],
        },
      },
      // nt: UpdatePullRequestReviewPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updatePullRequestReviewComment: {
      a: {
        input: {
          nt: UpdatePullRequestReviewCommentInput,
          it: [1],
        },
      },
      // nt: UpdatePullRequestReviewCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateRef: {
      a: {
        input: {
          nt: UpdateRefInput,
          it: [1],
        },
      },
      // nt: UpdateRefPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateRefs: {
      a: {
        input: {
          nt: UpdateRefsInput,
          it: [1],
        },
      },
      // nt: UpdateRefsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateRepository: {
      a: {
        input: {
          nt: UpdateRepositoryInput,
          it: [1],
        },
      },
      // nt: UpdateRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateRepositoryRuleset: {
      a: {
        input: {
          nt: UpdateRepositoryRulesetInput,
          it: [1],
        },
      },
      // nt: UpdateRepositoryRulesetPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateRepositoryWebCommitSignoffSetting: {
      a: {
        input: {
          nt: UpdateRepositoryWebCommitSignoffSettingInput,
          it: [1],
        },
      },
      // nt: UpdateRepositoryWebCommitSignoffSettingPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateSponsorshipPreferences: {
      a: {
        input: {
          nt: UpdateSponsorshipPreferencesInput,
          it: [1],
        },
      },
      // nt: UpdateSponsorshipPreferencesPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateSubscription: {
      a: {
        input: {
          nt: UpdateSubscriptionInput,
          it: [1],
        },
      },
      // nt: UpdateSubscriptionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateTeamDiscussion: {
      a: {
        input: {
          nt: UpdateTeamDiscussionInput,
          it: [1],
        },
      },
      // nt: UpdateTeamDiscussionPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateTeamDiscussionComment: {
      a: {
        input: {
          nt: UpdateTeamDiscussionCommentInput,
          it: [1],
        },
      },
      // nt: UpdateTeamDiscussionCommentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateTeamReviewAssignment: {
      a: {
        input: {
          nt: UpdateTeamReviewAssignmentInput,
          it: [1],
        },
      },
      // nt: UpdateTeamReviewAssignmentPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateTeamsRepository: {
      a: {
        input: {
          nt: UpdateTeamsRepositoryInput,
          it: [1],
        },
      },
      // nt: UpdateTeamsRepositoryPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateTopics: {
      a: {
        input: {
          nt: UpdateTopicsInput,
          it: [1],
        },
      },
      // nt: UpdateTopicsPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateUserList: {
      a: {
        input: {
          nt: UpdateUserListInput,
          it: [1],
        },
      },
      // nt: UpdateUserListPayload, <-- Assigned later to avoid potential circular dependency.
    },
    updateUserListsForItem: {
      a: {
        input: {
          nt: UpdateUserListsForItemInput,
          it: [1],
        },
      },
      // nt: UpdateUserListsForItemPayload, <-- Assigned later to avoid potential circular dependency.
    },
    verifyVerifiableDomain: {
      a: {
        input: {
          nt: VerifyVerifiableDomainInput,
          it: [1],
        },
      },
      // nt: VerifyVerifiableDomainPayload, <-- Assigned later to avoid potential circular dependency.
    },
  },
}

//
//
//
//
//
//
// ==================================================================================================
//                                       Reference Assignments
//                                (avoids circular assignment issues)
// ==================================================================================================
//
//
//
//
//
//

// TODO: Contribute helper to Utilities to cast readonly data to mutable at type level.
// These assignments are needed to avoid circular references during module initialization.
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRunOutput.f![`images`]!.nt = CheckRunOutputImage
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCheckRunInput.f![`output`]!.nt = CheckRunOutput
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCommitOnBranchInput.f![`fileChanges`]!.nt = FileChanges
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FileChanges.f![`additions`]!.nt = FileAddition
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateCheckRunInput.f![`output`]!.nt = CheckRunOutput
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2ItemFieldValueInput.f![`value`]!.nt = ProjectV2FieldValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateRefsInput.f![`refUpdates`]!.nt = RefUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AcceptEnterpriseAdministratorInvitationPayload.f[`invitation`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AcceptEnterpriseMemberInvitationPayload.f[`invitation`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AcceptTopicSuggestionPayload.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AccessUserNamespaceRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddAssigneesToAssignablePayload.f[`assignable`]!.nt = Assignable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddCommentPayload.f[`commentEdge`]!.nt = IssueCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddCommentPayload.f[`subject`]!.nt = Node
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddCommentPayload.f[`timelineEdge`]!.nt = IssueTimelineItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddDiscussionCommentPayload.f[`comment`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddDiscussionPollVotePayload.f[`pollOption`]!.nt = DiscussionPollOption
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddEnterpriseOrganizationMemberPayload.f[`users`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddLabelsToLabelablePayload.f[`labelable`]!.nt = Labelable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectCardPayload.f[`cardEdge`]!.nt = ProjectCardEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectCardPayload.f[`projectColumn`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectColumnPayload.f[`columnEdge`]!.nt = ProjectColumnEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectColumnPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectV2DraftIssuePayload.f[`projectItem`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddProjectV2ItemByIdPayload.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewCommentPayload.f[`comment`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewCommentPayload.f[`commentEdge`]!.nt = PullRequestReviewCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewPayload.f[`reviewEdge`]!.nt = PullRequestReviewEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewThreadPayload.f[`thread`]!.nt = PullRequestReviewThread
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddPullRequestReviewThreadReplyPayload.f[`comment`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddReactionPayload.f[`reaction`]!.nt = Reaction
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddReactionPayload.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddReactionPayload.f[`subject`]!.nt = Reactable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddStarPayload.f[`starrable`]!.nt = Starrable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddSubIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddSubIssuePayload.f[`subIssue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddUpvotePayload.f[`subject`]!.nt = Votable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddVerifiableDomainPayload.f[`domain`]!.nt = VerifiableDomain
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToMergeQueueEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToMergeQueueEvent.f[`enqueuer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToMergeQueueEvent.f[`mergeQueue`]!.nt = MergeQueue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToMergeQueueEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToProjectEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToProjectEvent.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AddedToProjectEvent.f[`projectCard`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
App.f[`ipAllowListEntries`]!.nt = IpAllowListEntryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ApproveDeploymentsPayload.f[`deployments`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ApproveVerifiableDomainPayload.f[`domain`]!.nt = VerifiableDomain
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ArchiveProjectV2ItemPayload.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ArchiveRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AssignedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AssignedEvent.f[`assignable`]!.nt = Assignable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AssignedEvent.f[`assignee`]!.nt = Assignee
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AssignedEvent.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeDisabledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeDisabledEvent.f[`disabler`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeDisabledEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeEnabledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeEnabledEvent.f[`enabler`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeEnabledEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeRequest.f[`enabledBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoMergeRequest.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoRebaseEnabledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoRebaseEnabledEvent.f[`enabler`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoRebaseEnabledEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoSquashEnabledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoSquashEnabledEvent.f[`enabler`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutoSquashEnabledEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutomaticBaseChangeFailedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutomaticBaseChangeFailedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutomaticBaseChangeSucceededEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
AutomaticBaseChangeSucceededEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefChangedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefChangedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefDeletedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefDeletedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefForcePushedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefForcePushedEvent.f[`afterCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefForcePushedEvent.f[`beforeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefForcePushedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BaseRefForcePushedEvent.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Blame.f[`ranges`]!.nt = BlameRange
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BlameRange.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Blob.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`branchProtectionRuleConflicts`]!.nt = BranchProtectionRuleConflictConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`bypassForcePushAllowances`]!.nt = BypassForcePushAllowanceConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`bypassPullRequestAllowances`]!.nt = BypassPullRequestAllowanceConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`matchingRefs`]!.nt = RefConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`pushAllowances`]!.nt = PushAllowanceConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`requiredStatusChecks`]!.nt = RequiredStatusCheckDescription
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRule.f[`reviewDismissalAllowances`]!.nt = ReviewDismissalAllowanceConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflict.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflict.f[`conflictingBranchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflict.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflictConnection.f[`edges`]!.nt = BranchProtectionRuleConflictEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflictConnection.f[`nodes`]!.nt = BranchProtectionRuleConflict
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflictConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConflictEdge.f[`node`]!.nt = BranchProtectionRuleConflict
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConnection.f[`edges`]!.nt = BranchProtectionRuleEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConnection.f[`nodes`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BranchProtectionRuleEdge.f[`node`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowance.f[`actor`]!.nt = BranchActorAllowanceActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowance.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowanceConnection.f[`edges`]!.nt = BypassForcePushAllowanceEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowanceConnection.f[`nodes`]!.nt = BypassForcePushAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowanceConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassForcePushAllowanceEdge.f[`node`]!.nt = BypassForcePushAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowance.f[`actor`]!.nt = BranchActorAllowanceActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowance.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowanceConnection.f[`edges`]!.nt = BypassPullRequestAllowanceEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowanceConnection.f[`nodes`]!.nt = BypassPullRequestAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowanceConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
BypassPullRequestAllowanceEdge.f[`node`]!.nt = BypassPullRequestAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CWEConnection.f[`edges`]!.nt = CWEEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CWEConnection.f[`nodes`]!.nt = CWE
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CWEConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CWEEdge.f[`node`]!.nt = CWE
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CancelEnterpriseAdminInvitationPayload.f[`invitation`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CancelEnterpriseMemberInvitationPayload.f[`invitation`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CancelSponsorshipPayload.f[`sponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ChangeUserStatusPayload.f[`status`]!.nt = UserStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotation.f[`location`]!.nt = CheckAnnotationSpan
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationConnection.f[`edges`]!.nt = CheckAnnotationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationConnection.f[`nodes`]!.nt = CheckAnnotation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationEdge.f[`node`]!.nt = CheckAnnotation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationSpan.f[`end`]!.nt = CheckAnnotationPosition
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckAnnotationSpan.f[`start`]!.nt = CheckAnnotationPosition
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`annotations`]!.nt = CheckAnnotationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`checkSuite`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`deployment`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`pendingDeploymentRequest`]!.nt = DeploymentRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRun.f[`steps`]!.nt = CheckStepConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRunConnection.f[`edges`]!.nt = CheckRunEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRunConnection.f[`nodes`]!.nt = CheckRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRunConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckRunEdge.f[`node`]!.nt = CheckRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckStepConnection.f[`edges`]!.nt = CheckStepEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckStepConnection.f[`nodes`]!.nt = CheckStep
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckStepConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckStepEdge.f[`node`]!.nt = CheckStep
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`app`]!.nt = App
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`branch`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`checkRuns`]!.nt = CheckRunConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`creator`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`matchingPullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`push`]!.nt = Push
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuite.f[`workflowRun`]!.nt = WorkflowRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuiteConnection.f[`edges`]!.nt = CheckSuiteEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuiteConnection.f[`nodes`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuiteConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CheckSuiteEdge.f[`node`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClearLabelsFromLabelablePayload.f[`labelable`]!.nt = Labelable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClearProjectV2ItemFieldValuePayload.f[`projectV2Item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CloneProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CloneTemplateRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CloseDiscussionPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CloseIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClosePullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClosedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClosedEvent.f[`closable`]!.nt = Closable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ClosedEvent.f[`closer`]!.nt = Closer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CodeScanningParameters.f[`codeScanningTools`]!.nt = CodeScanningTool
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommentDeletedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommentDeletedEvent.f[`deletedCommentAuthor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`associatedPullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`author`]!.nt = GitActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`authors`]!.nt = GitActorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`blame`]!.nt = Blame
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`checkSuites`]!.nt = CheckSuiteConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`comments`]!.nt = CommitCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`committer`]!.nt = GitActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`deployments`]!.nt = DeploymentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`file`]!.nt = TreeEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`history`]!.nt = CommitHistoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`onBehalfOf`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`parents`]!.nt = CommitConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`signature`]!.nt = GitSignature
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`status`]!.nt = Status
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`statusCheckRollup`]!.nt = StatusCheckRollup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`submodules`]!.nt = SubmoduleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Commit.f[`tree`]!.nt = Tree
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentConnection.f[`edges`]!.nt = CommitCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentConnection.f[`nodes`]!.nt = CommitComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentEdge.f[`node`]!.nt = CommitComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentThread.f[`comments`]!.nt = CommitCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentThread.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitCommentThread.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitConnection.f[`edges`]!.nt = CommitEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitConnection.f[`nodes`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitContributionsByRepository.f[`contributions`]!.nt = CreatedCommitContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitContributionsByRepository.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitEdge.f[`node`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitHistoryConnection.f[`edges`]!.nt = CommitEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitHistoryConnection.f[`nodes`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CommitHistoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Comparison.f[`baseTarget`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Comparison.f[`commits`]!.nt = ComparisonCommitConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Comparison.f[`headTarget`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ComparisonCommitConnection.f[`edges`]!.nt = CommitEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ComparisonCommitConnection.f[`nodes`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ComparisonCommitConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConnectedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConnectedEvent.f[`source`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConnectedEvent.f[`subject`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionCalendar.f[`months`]!.nt = ContributionCalendarMonth
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionCalendar.f[`weeks`]!.nt = ContributionCalendarWeek
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionCalendarWeek.f[`contributionDays`]!.nt = ContributionCalendarDay
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`commitContributionsByRepository`]!.nt = CommitContributionsByRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`contributionCalendar`]!.nt = ContributionCalendar
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`firstIssueContribution`]!.nt = CreatedIssueOrRestrictedContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`firstPullRequestContribution`]!.nt = CreatedPullRequestOrRestrictedContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`firstRepositoryContribution`]!.nt = CreatedRepositoryOrRestrictedContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`issueContributions`]!.nt = CreatedIssueContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`issueContributionsByRepository`]!.nt = IssueContributionsByRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`joinedGitHubContribution`]!.nt = JoinedGitHubContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`mostRecentCollectionWithActivity`]!.nt = ContributionsCollection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`mostRecentCollectionWithoutActivity`]!.nt = ContributionsCollection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`popularIssueContribution`]!.nt = CreatedIssueContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`popularPullRequestContribution`]!.nt = CreatedPullRequestContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`pullRequestContributions`]!.nt = CreatedPullRequestContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`pullRequestContributionsByRepository`]!.nt = PullRequestContributionsByRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`pullRequestReviewContributions`]!.nt = CreatedPullRequestReviewContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`pullRequestReviewContributionsByRepository`]!.nt = PullRequestReviewContributionsByRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`repositoryContributions`]!.nt = CreatedRepositoryContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ContributionsCollection.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertProjectCardNoteToIssuePayload.f[`projectCard`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertProjectV2DraftIssueItemToIssuePayload.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertPullRequestToDraftPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertToDraftEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertToDraftEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertedNoteToIssueEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertedNoteToIssueEvent.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertedNoteToIssueEvent.f[`projectCard`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertedToDiscussionEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ConvertedToDiscussionEvent.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CopyProjectV2Payload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateAttributionInvitationPayload.f[`owner`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateAttributionInvitationPayload.f[`source`]!.nt = Claimable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateAttributionInvitationPayload.f[`target`]!.nt = Claimable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateBranchProtectionRulePayload.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCheckRunPayload.f[`checkRun`]!.nt = CheckRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCheckSuitePayload.f[`checkSuite`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCommitOnBranchPayload.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateCommitOnBranchPayload.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateDeploymentPayload.f[`deployment`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateDeploymentStatusPayload.f[`deploymentStatus`]!.nt = DeploymentStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateDiscussionPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateEnterpriseOrganizationPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateEnterpriseOrganizationPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateEnvironmentPayload.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateIpAllowListEntryPayload.f[`ipAllowListEntry`]!.nt = IpAllowListEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateLabelPayload.f[`label`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateLinkedBranchPayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateLinkedBranchPayload.f[`linkedBranch`]!.nt = LinkedBranch
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateMigrationSourcePayload.f[`migrationSource`]!.nt = MigrationSource
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateProjectV2FieldPayload.f[`projectV2Field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateProjectV2Payload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateProjectV2StatusUpdatePayload.f[`statusUpdate`]!.nt = ProjectV2StatusUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatePullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateRefPayload.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateRepositoryRulesetPayload.f[`ruleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateSponsorsListingPayload.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateSponsorsTierPayload.f[`sponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateSponsorshipPayload.f[`sponsorship`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateSponsorshipsPayload.f[`sponsorables`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateTeamDiscussionCommentPayload.f[`teamDiscussionComment`]!.nt = TeamDiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateTeamDiscussionPayload.f[`teamDiscussion`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateUserListPayload.f[`list`]!.nt = UserList
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreateUserListPayload.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContribution.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContributionConnection.f[`edges`]!.nt = CreatedCommitContributionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContributionConnection.f[`nodes`]!.nt = CreatedCommitContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContributionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedCommitContributionEdge.f[`node`]!.nt = CreatedCommitContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContribution.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContributionConnection.f[`edges`]!.nt = CreatedIssueContributionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContributionConnection.f[`nodes`]!.nt = CreatedIssueContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContributionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedIssueContributionEdge.f[`node`]!.nt = CreatedIssueContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContribution.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContributionConnection.f[`edges`]!.nt = CreatedPullRequestContributionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContributionConnection.f[`nodes`]!.nt = CreatedPullRequestContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContributionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestContributionEdge.f[`node`]!.nt = CreatedPullRequestContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContribution.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContribution.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContribution.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContributionConnection.f[`edges`]!.nt = CreatedPullRequestReviewContributionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContributionConnection.f[`nodes`]!.nt = CreatedPullRequestReviewContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContributionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedPullRequestReviewContributionEdge.f[`node`]!.nt = CreatedPullRequestReviewContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContribution.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContributionConnection.f[`edges`]!.nt = CreatedRepositoryContributionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContributionConnection.f[`nodes`]!.nt = CreatedRepositoryContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContributionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CreatedRepositoryContributionEdge.f[`node`]!.nt = CreatedRepositoryContribution
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CrossReferencedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CrossReferencedEvent.f[`source`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CrossReferencedEvent.f[`target`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CvssSeverities.f[`cvssV3`]!.nt = CVSS
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
CvssSeverities.f[`cvssV4`]!.nt = CVSS
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeclineTopicSuggestionPayload.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteDiscussionCommentPayload.f[`comment`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteDiscussionPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteIpAllowListEntryPayload.f[`ipAllowListEntry`]!.nt = IpAllowListEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteIssuePayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteLinkedBranchPayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectCardPayload.f[`column`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectColumnPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectPayload.f[`owner`]!.nt = ProjectOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectV2FieldPayload.f[`projectV2Field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectV2Payload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectV2StatusUpdatePayload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteProjectV2WorkflowPayload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeletePullRequestReviewCommentPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeletePullRequestReviewCommentPayload.f[`pullRequestReviewComment`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeletePullRequestReviewPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteUserListPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeleteVerifiableDomainPayload.f[`owner`]!.nt = VerifiableDomainOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DemilestonedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DemilestonedEvent.f[`subject`]!.nt = MilestoneItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependabotUpdate.f[`error`]!.nt = DependabotUpdateError
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependabotUpdate.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependabotUpdate.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphDependency.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphDependencyConnection.f[`edges`]!.nt = DependencyGraphDependencyEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphDependencyConnection.f[`nodes`]!.nt = DependencyGraphDependency
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphDependencyConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphDependencyEdge.f[`node`]!.nt = DependencyGraphDependency
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifest.f[`dependencies`]!.nt = DependencyGraphDependencyConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifest.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifestConnection.f[`edges`]!.nt = DependencyGraphManifestEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifestConnection.f[`nodes`]!.nt = DependencyGraphManifest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifestConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DependencyGraphManifestEdge.f[`node`]!.nt = DependencyGraphManifest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployKeyConnection.f[`edges`]!.nt = DeployKeyEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployKeyConnection.f[`nodes`]!.nt = DeployKey
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployKeyConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployKeyEdge.f[`node`]!.nt = DeployKey
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployedEvent.f[`deployment`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeployedEvent.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`latestStatus`]!.nt = DeploymentStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Deployment.f[`statuses`]!.nt = DeploymentStatusConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentConnection.f[`edges`]!.nt = DeploymentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentConnection.f[`nodes`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentEdge.f[`node`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentEnvironmentChangedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentEnvironmentChangedEvent.f[`deploymentStatus`]!.nt = DeploymentStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentEnvironmentChangedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentProtectionRule.f[`reviewers`]!.nt = DeploymentReviewerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentProtectionRuleConnection.f[`edges`]!.nt = DeploymentProtectionRuleEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentProtectionRuleConnection.f[`nodes`]!.nt = DeploymentProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentProtectionRuleConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentProtectionRuleEdge.f[`node`]!.nt = DeploymentProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequest.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequest.f[`reviewers`]!.nt = DeploymentReviewerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequestConnection.f[`edges`]!.nt = DeploymentRequestEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequestConnection.f[`nodes`]!.nt = DeploymentRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequestConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentRequestEdge.f[`node`]!.nt = DeploymentRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReview.f[`environments`]!.nt = EnvironmentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReview.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewConnection.f[`edges`]!.nt = DeploymentReviewEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewConnection.f[`nodes`]!.nt = DeploymentReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewEdge.f[`node`]!.nt = DeploymentReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewerConnection.f[`edges`]!.nt = DeploymentReviewerEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewerConnection.f[`nodes`]!.nt = DeploymentReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewerConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentReviewerEdge.f[`node`]!.nt = DeploymentReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatus.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatus.f[`deployment`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatusConnection.f[`edges`]!.nt = DeploymentStatusEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatusConnection.f[`nodes`]!.nt = DeploymentStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatusConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DeploymentStatusEdge.f[`node`]!.nt = DeploymentStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DequeuePullRequestPayload.f[`mergeQueueEntry`]!.nt = MergeQueueEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DisablePullRequestAutoMergePayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DisablePullRequestAutoMergePayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DisconnectedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DisconnectedEvent.f[`source`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DisconnectedEvent.f[`subject`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`answer`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`answerChosenBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`category`]!.nt = DiscussionCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`comments`]!.nt = DiscussionCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`poll`]!.nt = DiscussionPoll
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Discussion.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCategory.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCategoryConnection.f[`edges`]!.nt = DiscussionCategoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCategoryConnection.f[`nodes`]!.nt = DiscussionCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCategoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCategoryEdge.f[`node`]!.nt = DiscussionCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`replies`]!.nt = DiscussionCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`replyTo`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCommentConnection.f[`edges`]!.nt = DiscussionCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCommentConnection.f[`nodes`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionCommentEdge.f[`node`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionConnection.f[`edges`]!.nt = DiscussionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionConnection.f[`nodes`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionEdge.f[`node`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPoll.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPoll.f[`options`]!.nt = DiscussionPollOptionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPollOption.f[`poll`]!.nt = DiscussionPoll
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPollOptionConnection.f[`edges`]!.nt = DiscussionPollOptionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPollOptionConnection.f[`nodes`]!.nt = DiscussionPollOption
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPollOptionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DiscussionPollOptionEdge.f[`node`]!.nt = DiscussionPollOption
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DismissPullRequestReviewPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DismissRepositoryVulnerabilityAlertPayload.f[`repositoryVulnerabilityAlert`]!.nt = RepositoryVulnerabilityAlert
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DraftIssue.f[`assignees`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DraftIssue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DraftIssue.f[`projectV2Items`]!.nt = ProjectV2ItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
DraftIssue.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnablePullRequestAutoMergePayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnablePullRequestAutoMergePayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnqueuePullRequestPayload.f[`mergeQueueEntry`]!.nt = MergeQueueEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`announcementBanner`]!.nt = AnnouncementBanner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`billingInfo`]!.nt = EnterpriseBillingInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`members`]!.nt = EnterpriseMemberConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`organizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`ownerInfo`]!.nt = EnterpriseOwnerInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`ruleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`rulesets`]!.nt = RepositoryRulesetConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Enterprise.f[`userNamespaceRepositories`]!.nt = UserNamespaceRepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorConnection.f[`edges`]!.nt = EnterpriseAdministratorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitation.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitation.f[`invitee`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitation.f[`inviter`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitationConnection.f[`edges`]!.nt = EnterpriseAdministratorInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitationConnection.f[`nodes`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseAdministratorInvitationEdge.f[`node`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseConnection.f[`edges`]!.nt = EnterpriseEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseConnection.f[`nodes`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseEdge.f[`node`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseFailedInvitationConnection.f[`edges`]!.nt = EnterpriseFailedInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseFailedInvitationConnection.f[`nodes`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseFailedInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseFailedInvitationEdge.f[`node`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseIdentityProvider.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseIdentityProvider.f[`externalIdentities`]!.nt = ExternalIdentityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberConnection.f[`edges`]!.nt = EnterpriseMemberEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberConnection.f[`nodes`]!.nt = EnterpriseMember
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberEdge.f[`node`]!.nt = EnterpriseMember
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitation.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitation.f[`invitee`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitation.f[`inviter`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitationConnection.f[`edges`]!.nt = EnterpriseMemberInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitationConnection.f[`nodes`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseMemberInvitationEdge.f[`node`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOrganizationMembershipConnection.f[`edges`]!.nt = EnterpriseOrganizationMembershipEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOrganizationMembershipConnection.f[`nodes`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOrganizationMembershipConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOrganizationMembershipEdge.f[`node`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOutsideCollaboratorConnection.f[`edges`]!.nt = EnterpriseOutsideCollaboratorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOutsideCollaboratorConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOutsideCollaboratorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOutsideCollaboratorEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOutsideCollaboratorEdge.f[`repositories`]!.nt = EnterpriseRepositoryInfoConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`admins`]!.nt = EnterpriseAdministratorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`affiliatedUsersWithTwoFactorDisabled`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`allowPrivateRepositoryForkingSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`defaultRepositoryPermissionSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`domains`]!.nt = VerifiableDomainConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`enterpriseServerInstallations`]!.nt = EnterpriseServerInstallationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`failedInvitations`]!.nt = EnterpriseFailedInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`ipAllowListEntries`]!.nt = IpAllowListEntryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanChangeRepositoryVisibilitySettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanCreateRepositoriesSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanDeleteIssuesSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanDeleteRepositoriesSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanInviteCollaboratorsSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanUpdateProtectedBranchesSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`membersCanViewDependencyInsightsSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`oidcProvider`]!.nt = OIDCProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`organizationProjectsSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`outsideCollaborators`]!.nt = EnterpriseOutsideCollaboratorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`pendingAdminInvitations`]!.nt = EnterpriseAdministratorInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`pendingCollaboratorInvitations`]!.nt = RepositoryInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`pendingMemberInvitations`]!.nt = EnterprisePendingMemberInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`pendingUnaffiliatedMemberInvitations`]!.nt = EnterpriseMemberInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`repositoryDeployKeySettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`repositoryProjectsSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`samlIdentityProvider`]!.nt = EnterpriseIdentityProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`samlIdentityProviderSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`supportEntitlements`]!.nt = EnterpriseMemberConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`teamDiscussionsSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseOwnerInfo.f[`twoFactorRequiredSettingOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterprisePendingMemberInvitationConnection.f[`edges`]!.nt = EnterprisePendingMemberInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterprisePendingMemberInvitationConnection.f[`nodes`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterprisePendingMemberInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterprisePendingMemberInvitationEdge.f[`node`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseRepositoryInfoConnection.f[`edges`]!.nt = EnterpriseRepositoryInfoEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseRepositoryInfoConnection.f[`nodes`]!.nt = EnterpriseRepositoryInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseRepositoryInfoConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseRepositoryInfoEdge.f[`node`]!.nt = EnterpriseRepositoryInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallation.f[`userAccounts`]!.nt = EnterpriseServerUserAccountConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallation.f[`userAccountsUploads`]!.nt = EnterpriseServerUserAccountsUploadConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationConnection.f[`edges`]!.nt = EnterpriseServerInstallationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationConnection.f[`nodes`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationEdge.f[`node`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationMembershipConnection.f[`edges`]!.nt = EnterpriseServerInstallationMembershipEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationMembershipConnection.f[`nodes`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationMembershipConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerInstallationMembershipEdge.f[`node`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccount.f[`emails`]!.nt = EnterpriseServerUserAccountEmailConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccount.f[`enterpriseServerInstallation`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountConnection.f[`edges`]!.nt = EnterpriseServerUserAccountEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountConnection.f[`nodes`]!.nt = EnterpriseServerUserAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEdge.f[`node`]!.nt = EnterpriseServerUserAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEmail.f[`userAccount`]!.nt = EnterpriseServerUserAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEmailConnection.f[`edges`]!.nt = EnterpriseServerUserAccountEmailEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEmailConnection.f[`nodes`]!.nt = EnterpriseServerUserAccountEmail
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEmailConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountEmailEdge.f[`node`]!.nt = EnterpriseServerUserAccountEmail
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUpload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUpload.f[`enterpriseServerInstallation`]!.nt = EnterpriseServerInstallation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUploadConnection.f[`edges`]!.nt = EnterpriseServerUserAccountsUploadEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUploadConnection.f[`nodes`]!.nt = EnterpriseServerUserAccountsUpload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUploadConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseServerUserAccountsUploadEdge.f[`node`]!.nt = EnterpriseServerUserAccountsUpload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseUserAccount.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseUserAccount.f[`enterpriseInstallations`]!.nt = EnterpriseServerInstallationMembershipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseUserAccount.f[`organizations`]!.nt = EnterpriseOrganizationMembershipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnterpriseUserAccount.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Environment.f[`latestCompletedDeployment`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Environment.f[`protectionRules`]!.nt = DeploymentProtectionRuleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnvironmentConnection.f[`edges`]!.nt = EnvironmentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnvironmentConnection.f[`nodes`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnvironmentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
EnvironmentEdge.f[`node`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentity.f[`organizationInvitation`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentity.f[`samlIdentity`]!.nt = ExternalIdentitySamlAttributes
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentity.f[`scimIdentity`]!.nt = ExternalIdentityScimAttributes
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentity.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentityConnection.f[`edges`]!.nt = ExternalIdentityEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentityConnection.f[`nodes`]!.nt = ExternalIdentity
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentityConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentityEdge.f[`node`]!.nt = ExternalIdentity
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentitySamlAttributes.f[`attributes`]!.nt = ExternalIdentityAttribute
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentitySamlAttributes.f[`emails`]!.nt = UserEmailMetadata
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ExternalIdentityScimAttributes.f[`emails`]!.nt = UserEmailMetadata
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowOrganizationPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowUserPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowerConnection.f[`edges`]!.nt = UserEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowerConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowerConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowingConnection.f[`edges`]!.nt = UserEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowingConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
FollowingConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Gist.f[`comments`]!.nt = GistCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Gist.f[`files`]!.nt = GistFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Gist.f[`forks`]!.nt = GistConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Gist.f[`owner`]!.nt = RepositoryOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Gist.f[`stargazers`]!.nt = StargazerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistComment.f[`gist`]!.nt = Gist
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistCommentConnection.f[`edges`]!.nt = GistCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistCommentConnection.f[`nodes`]!.nt = GistComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistCommentEdge.f[`node`]!.nt = GistComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistConnection.f[`edges`]!.nt = GistEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistConnection.f[`nodes`]!.nt = Gist
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistEdge.f[`node`]!.nt = Gist
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GistFile.f[`language`]!.nt = Language
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GitActor.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GitActorConnection.f[`edges`]!.nt = GitActorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GitActorConnection.f[`nodes`]!.nt = GitActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GitActorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GitActorEdge.f[`node`]!.nt = GitActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GpgSignature.f[`signer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
GrantEnterpriseOrganizationsMigratorRolePayload.f[`organizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefDeletedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefDeletedEvent.f[`headRef`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefDeletedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefForcePushedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefForcePushedEvent.f[`afterCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefForcePushedEvent.f[`beforeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefForcePushedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefForcePushedEvent.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefRestoredEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
HeadRefRestoredEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Hovercard.f[`contexts`]!.nt = HovercardContext
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ImportProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
InviteEnterpriseAdminPayload.f[`invitation`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
InviteEnterpriseMemberPayload.f[`invitation`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IpAllowListEntry.f[`owner`]!.nt = IpAllowListOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IpAllowListEntryConnection.f[`edges`]!.nt = IpAllowListEntryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IpAllowListEntryConnection.f[`nodes`]!.nt = IpAllowListEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IpAllowListEntryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IpAllowListEntryEdge.f[`node`]!.nt = IpAllowListEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`assignees`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`closedByPullRequestsReferences`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`comments`]!.nt = IssueCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`hovercard`]!.nt = Hovercard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`linkedBranches`]!.nt = LinkedBranchConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`milestone`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`parent`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`participants`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`projectCards`]!.nt = ProjectCardConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`projectItems`]!.nt = ProjectV2ItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`subIssues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`subIssuesSummary`]!.nt = SubIssuesSummary
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`timeline`]!.nt = IssueTimelineConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`timelineItems`]!.nt = IssueTimelineItemsConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`trackedInIssues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`trackedIssues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Issue.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueCommentConnection.f[`edges`]!.nt = IssueCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueCommentConnection.f[`nodes`]!.nt = IssueComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueCommentEdge.f[`node`]!.nt = IssueComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueConnection.f[`edges`]!.nt = IssueEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueConnection.f[`nodes`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueContributionsByRepository.f[`contributions`]!.nt = CreatedIssueContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueContributionsByRepository.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueEdge.f[`node`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTemplate.f[`assignees`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTemplate.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineConnection.f[`edges`]!.nt = IssueTimelineItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineConnection.f[`nodes`]!.nt = IssueTimelineItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineItemEdge.f[`node`]!.nt = IssueTimelineItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineItemsConnection.f[`edges`]!.nt = IssueTimelineItemsEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineItemsConnection.f[`nodes`]!.nt = IssueTimelineItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineItemsConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
IssueTimelineItemsEdge.f[`node`]!.nt = IssueTimelineItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
JoinedGitHubContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Label.f[`issues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Label.f[`pullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Label.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabelConnection.f[`edges`]!.nt = LabelEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabelConnection.f[`nodes`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabelConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabelEdge.f[`node`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabeledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabeledEvent.f[`label`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LabeledEvent.f[`labelable`]!.nt = Labelable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LanguageConnection.f[`edges`]!.nt = LanguageEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LanguageConnection.f[`nodes`]!.nt = Language
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LanguageConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LanguageEdge.f[`node`]!.nt = Language
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
License.f[`conditions`]!.nt = LicenseRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
License.f[`limitations`]!.nt = LicenseRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
License.f[`permissions`]!.nt = LicenseRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkProjectV2ToRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkProjectV2ToTeamPayload.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkRepositoryToProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkRepositoryToProjectPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkedBranch.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkedBranchConnection.f[`edges`]!.nt = LinkedBranchEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkedBranchConnection.f[`nodes`]!.nt = LinkedBranch
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkedBranchConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LinkedBranchEdge.f[`node`]!.nt = LinkedBranch
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LockLockablePayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LockLockablePayload.f[`lockedRecord`]!.nt = Lockable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LockedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
LockedEvent.f[`lockable`]!.nt = Lockable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mannequin.f[`claimant`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MannequinConnection.f[`edges`]!.nt = MannequinEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MannequinConnection.f[`nodes`]!.nt = Mannequin
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MannequinConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MannequinEdge.f[`node`]!.nt = Mannequin
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkDiscussionCommentAsAnswerPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkFileAsViewedPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkProjectV2AsTemplatePayload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkPullRequestReadyForReviewPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkedAsDuplicateEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkedAsDuplicateEvent.f[`canonical`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarkedAsDuplicateEvent.f[`duplicate`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListing.f[`app`]!.nt = App
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListing.f[`primaryCategory`]!.nt = MarketplaceCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListing.f[`secondaryCategory`]!.nt = MarketplaceCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListingConnection.f[`edges`]!.nt = MarketplaceListingEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListingConnection.f[`nodes`]!.nt = MarketplaceListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListingConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MarketplaceListingEdge.f[`node`]!.nt = MarketplaceListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposClearAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposClearAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposClearAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposClearAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposDisableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposDisableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposDisableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposDisableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposEnableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposEnableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposEnableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MembersCanDeleteReposEnableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MentionedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeBranchPayload.f[`mergeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergePullRequestPayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergePullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueue.f[`configuration`]!.nt = MergeQueueConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueue.f[`entries`]!.nt = MergeQueueEntryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueue.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntry.f[`baseCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntry.f[`enqueuer`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntry.f[`headCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntry.f[`mergeQueue`]!.nt = MergeQueue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntry.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntryConnection.f[`edges`]!.nt = MergeQueueEntryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntryConnection.f[`nodes`]!.nt = MergeQueueEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergeQueueEntryEdge.f[`node`]!.nt = MergeQueueEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergedEvent.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergedEvent.f[`mergeRef`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MergedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Milestone.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Milestone.f[`issues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Milestone.f[`pullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Milestone.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestoneConnection.f[`edges`]!.nt = MilestoneEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestoneConnection.f[`nodes`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestoneConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestoneEdge.f[`node`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestonedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MilestonedEvent.f[`subject`]!.nt = MilestoneItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MinimizeCommentPayload.f[`minimizedComment`]!.nt = Minimizable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MoveProjectCardPayload.f[`cardEdge`]!.nt = ProjectCardEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MoveProjectColumnPayload.f[`columnEdge`]!.nt = ProjectColumnEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MovedColumnsInProjectEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MovedColumnsInProjectEvent.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
MovedColumnsInProjectEvent.f[`projectCard`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OIDCProvider.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OIDCProvider.f[`externalIdentities`]!.nt = ExternalIdentityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OauthApplicationCreateAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OauthApplicationCreateAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OauthApplicationCreateAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OauthApplicationCreateAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddBillingManagerAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddBillingManagerAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddBillingManagerAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddBillingManagerAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgAddMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgBlockUserAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgBlockUserAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgBlockUserAuditEntry.f[`blockedUser`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgBlockUserAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgBlockUserAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigDisableCollaboratorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigDisableCollaboratorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigDisableCollaboratorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigDisableCollaboratorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigEnableCollaboratorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigEnableCollaboratorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigEnableCollaboratorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgConfigEnableCollaboratorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgCreateAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgCreateAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgCreateAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgCreateAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableOauthAppRestrictionsAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableOauthAppRestrictionsAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableOauthAppRestrictionsAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableOauthAppRestrictionsAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableSamlAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableSamlAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableSamlAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableSamlAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableTwoFactorRequirementAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableTwoFactorRequirementAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableTwoFactorRequirementAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgDisableTwoFactorRequirementAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableOauthAppRestrictionsAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableOauthAppRestrictionsAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableOauthAppRestrictionsAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableOauthAppRestrictionsAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableSamlAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableSamlAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableSamlAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableSamlAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableTwoFactorRequirementAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableTwoFactorRequirementAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableTwoFactorRequirementAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgEnableTwoFactorRequirementAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteMemberAuditEntry.f[`organizationInvitation`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteToBusinessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteToBusinessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteToBusinessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgInviteToBusinessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessApprovedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessApprovedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessApprovedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessApprovedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessBlockedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessBlockedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessBlockedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessBlockedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessDeniedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessDeniedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessDeniedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessDeniedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessRequestedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessRequestedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessRequestedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessRequestedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessUnblockedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessUnblockedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessUnblockedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgOauthAppAccessUnblockedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveBillingManagerAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveBillingManagerAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveBillingManagerAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveBillingManagerAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveOutsideCollaboratorAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveOutsideCollaboratorAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveOutsideCollaboratorAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRemoveOutsideCollaboratorAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberAuditEntry.f[`restoredMemberships`]!.nt = OrgRestoreMemberAuditEntryMembership
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberMembershipOrganizationAuditEntryData.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberMembershipRepositoryAuditEntryData.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgRestoreMemberMembershipTeamAuditEntryData.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUnblockUserAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUnblockUserAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUnblockUserAuditEntry.f[`blockedUser`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUnblockUserAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUnblockUserAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateDefaultRepositoryPermissionAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateDefaultRepositoryPermissionAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateDefaultRepositoryPermissionAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateDefaultRepositoryPermissionAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryCreationPermissionAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrgUpdateMemberRepositoryInvitationPermissionAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`announcementBanner`]!.nt = AnnouncementBanner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`auditLog`]!.nt = OrganizationAuditEntryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`domains`]!.nt = VerifiableDomainConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`enterpriseOwners`]!.nt = OrganizationEnterpriseOwnerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`interactionAbility`]!.nt = RepositoryInteractionAbility
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`ipAllowListEntries`]!.nt = IpAllowListEntryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`itemShowcase`]!.nt = ProfileItemShowcase
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`lifetimeReceivedSponsorshipValues`]!.nt = SponsorAndLifetimeValueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`mannequins`]!.nt = MannequinConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`memberStatuses`]!.nt = UserStatusConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`membersWithRole`]!.nt = OrganizationMemberConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`packages`]!.nt = PackageConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`pendingMembers`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`pinnableItems`]!.nt = PinnableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`pinnedItems`]!.nt = PinnableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`projects`]!.nt = ProjectConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`recentProjects`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`repositories`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`repositoryDiscussionComments`]!.nt = DiscussionCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`repositoryDiscussions`]!.nt = DiscussionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`repositoryMigrations`]!.nt = RepositoryMigrationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`ruleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`rulesets`]!.nt = RepositoryRulesetConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`samlIdentityProvider`]!.nt = OrganizationIdentityProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsoring`]!.nt = SponsorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsors`]!.nt = SponsorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorsActivities`]!.nt = SponsorsActivityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorshipForViewerAsSponsor`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorshipForViewerAsSponsorable`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorshipNewsletters`]!.nt = SponsorshipNewsletterConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorshipsAsMaintainer`]!.nt = SponsorshipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`sponsorshipsAsSponsor`]!.nt = SponsorshipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Organization.f[`teams`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationAuditEntryConnection.f[`edges`]!.nt = OrganizationAuditEntryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationAuditEntryConnection.f[`nodes`]!.nt = OrganizationAuditEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationAuditEntryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationAuditEntryEdge.f[`node`]!.nt = OrganizationAuditEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationConnection.f[`edges`]!.nt = OrganizationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationConnection.f[`nodes`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationEdge.f[`node`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationEnterpriseOwnerConnection.f[`edges`]!.nt = OrganizationEnterpriseOwnerEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationEnterpriseOwnerConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationEnterpriseOwnerConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationEnterpriseOwnerEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationIdentityProvider.f[`externalIdentities`]!.nt = ExternalIdentityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationIdentityProvider.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitation.f[`invitee`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitation.f[`inviter`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitation.f[`inviterActor`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitation.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitationConnection.f[`edges`]!.nt = OrganizationInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitationConnection.f[`nodes`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationInvitationEdge.f[`node`]!.nt = OrganizationInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationMemberConnection.f[`edges`]!.nt = OrganizationMemberEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationMemberConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationMemberConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationMemberEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationTeamsHovercardContext.f[`relevantTeams`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
OrganizationsHovercardContext.f[`relevantOrganizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Package.f[`latestVersion`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Package.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Package.f[`statistics`]!.nt = PackageStatistics
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Package.f[`version`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Package.f[`versions`]!.nt = PackageVersionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageConnection.f[`edges`]!.nt = PackageEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageConnection.f[`nodes`]!.nt = Package
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageEdge.f[`node`]!.nt = Package
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageFile.f[`packageVersion`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageFileConnection.f[`edges`]!.nt = PackageFileEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageFileConnection.f[`nodes`]!.nt = PackageFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageFileConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageFileEdge.f[`node`]!.nt = PackageFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageTag.f[`version`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersion.f[`files`]!.nt = PackageFileConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersion.f[`package`]!.nt = Package
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersion.f[`release`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersion.f[`statistics`]!.nt = PackageVersionStatistics
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersionConnection.f[`edges`]!.nt = PackageVersionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersionConnection.f[`nodes`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PackageVersionEdge.f[`node`]!.nt = PackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ParentIssueAddedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ParentIssueAddedEvent.f[`parent`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ParentIssueRemovedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ParentIssueRemovedEvent.f[`parent`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PermissionSource.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PermissionSource.f[`source`]!.nt = PermissionGranter
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinEnvironmentPayload.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinEnvironmentPayload.f[`pinnedEnvironment`]!.nt = PinnedEnvironment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnableItemConnection.f[`edges`]!.nt = PinnableItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnableItemConnection.f[`nodes`]!.nt = PinnableItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnableItemConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnableItemEdge.f[`node`]!.nt = PinnableItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussion.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussion.f[`pinnedBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussion.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussionConnection.f[`edges`]!.nt = PinnedDiscussionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussionConnection.f[`nodes`]!.nt = PinnedDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedDiscussionEdge.f[`node`]!.nt = PinnedDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironment.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironment.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironmentConnection.f[`edges`]!.nt = PinnedEnvironmentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironmentConnection.f[`nodes`]!.nt = PinnedEnvironment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironmentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEnvironmentEdge.f[`node`]!.nt = PinnedEnvironment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedEvent.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssue.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssue.f[`pinnedBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssue.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssueConnection.f[`edges`]!.nt = PinnedIssueEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssueConnection.f[`nodes`]!.nt = PinnedIssue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssueConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PinnedIssueEdge.f[`node`]!.nt = PinnedIssue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingDisableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingDisableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingDisableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingDisableAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingDisableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingEnableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingEnableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingEnableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingEnableAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PrivateRepositoryForkingEnableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProfileItemShowcase.f[`items`]!.nt = PinnableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Project.f[`columns`]!.nt = ProjectColumnConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Project.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Project.f[`owner`]!.nt = ProjectOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Project.f[`pendingCards`]!.nt = ProjectCardConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Project.f[`progress`]!.nt = ProjectProgress
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCard.f[`column`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCard.f[`content`]!.nt = ProjectCardItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCard.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCard.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCardConnection.f[`edges`]!.nt = ProjectCardEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCardConnection.f[`nodes`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCardConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectCardEdge.f[`node`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumn.f[`cards`]!.nt = ProjectCardConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumn.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumnConnection.f[`edges`]!.nt = ProjectColumnEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumnConnection.f[`nodes`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumnConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectColumnEdge.f[`node`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectConnection.f[`edges`]!.nt = ProjectEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectConnection.f[`nodes`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectEdge.f[`node`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`fields`]!.nt = ProjectV2FieldConfigurationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`items`]!.nt = ProjectV2ItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`owner`]!.nt = ProjectV2Owner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`repositories`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`statusUpdates`]!.nt = ProjectV2StatusUpdateConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`teams`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`view`]!.nt = ProjectV2View
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`views`]!.nt = ProjectV2ViewConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`workflow`]!.nt = ProjectV2Workflow
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2.f[`workflows`]!.nt = ProjectV2WorkflowConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ActorConnection.f[`edges`]!.nt = ProjectV2ActorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ActorConnection.f[`nodes`]!.nt = ProjectV2Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ActorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ActorEdge.f[`node`]!.nt = ProjectV2Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Connection.f[`edges`]!.nt = ProjectV2Edge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Connection.f[`nodes`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Connection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Edge.f[`node`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Field.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConfigurationConnection.f[`edges`]!.nt = ProjectV2FieldConfigurationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConfigurationConnection.f[`nodes`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConfigurationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConfigurationEdge.f[`node`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConnection.f[`edges`]!.nt = ProjectV2FieldEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConnection.f[`nodes`]!.nt = ProjectV2Field
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2FieldEdge.f[`node`]!.nt = ProjectV2Field
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Item.f[`content`]!.nt = ProjectV2ItemContent
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Item.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Item.f[`fieldValueByName`]!.nt = ProjectV2ItemFieldValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Item.f[`fieldValues`]!.nt = ProjectV2ItemFieldValueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Item.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemConnection.f[`edges`]!.nt = ProjectV2ItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemConnection.f[`nodes`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemEdge.f[`node`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldDateValue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldDateValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldDateValue.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldIterationValue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldIterationValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldIterationValue.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldLabelValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldLabelValue.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldMilestoneValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldMilestoneValue.f[`milestone`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldNumberValue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldNumberValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldNumberValue.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldPullRequestValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldPullRequestValue.f[`pullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldRepositoryValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldRepositoryValue.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldReviewerValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldReviewerValue.f[`reviewers`]!.nt = RequestedReviewerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldSingleSelectValue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldSingleSelectValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldSingleSelectValue.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldTextValue.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldTextValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldTextValue.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldUserValue.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldUserValue.f[`users`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldValueConnection.f[`edges`]!.nt = ProjectV2ItemFieldValueEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldValueConnection.f[`nodes`]!.nt = ProjectV2ItemFieldValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldValueConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ItemFieldValueEdge.f[`node`]!.nt = ProjectV2ItemFieldValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2IterationField.f[`configuration`]!.nt = ProjectV2IterationFieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2IterationField.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2IterationFieldConfiguration.f[`completedIterations`]!.nt = ProjectV2IterationFieldIteration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2IterationFieldConfiguration.f[`iterations`]!.nt = ProjectV2IterationFieldIteration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SingleSelectField.f[`options`]!.nt = ProjectV2SingleSelectFieldOption
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SingleSelectField.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortBy.f[`field`]!.nt = ProjectV2Field
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByConnection.f[`edges`]!.nt = ProjectV2SortByEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByConnection.f[`nodes`]!.nt = ProjectV2SortBy
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByEdge.f[`node`]!.nt = ProjectV2SortBy
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByField.f[`field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByFieldConnection.f[`edges`]!.nt = ProjectV2SortByFieldEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByFieldConnection.f[`nodes`]!.nt = ProjectV2SortByField
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByFieldConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2SortByFieldEdge.f[`node`]!.nt = ProjectV2SortByField
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdate.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdate.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdateConnection.f[`edges`]!.nt = ProjectV2StatusUpdateEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdateConnection.f[`nodes`]!.nt = ProjectV2StatusUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdateConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2StatusUpdateEdge.f[`node`]!.nt = ProjectV2StatusUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`fields`]!.nt = ProjectV2FieldConfigurationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`groupBy`]!.nt = ProjectV2FieldConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`groupByFields`]!.nt = ProjectV2FieldConfigurationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`sortBy`]!.nt = ProjectV2SortByConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`sortByFields`]!.nt = ProjectV2SortByFieldConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`verticalGroupBy`]!.nt = ProjectV2FieldConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`verticalGroupByFields`]!.nt = ProjectV2FieldConfigurationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2View.f[`visibleFields`]!.nt = ProjectV2FieldConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ViewConnection.f[`edges`]!.nt = ProjectV2ViewEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ViewConnection.f[`nodes`]!.nt = ProjectV2View
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ViewConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2ViewEdge.f[`node`]!.nt = ProjectV2View
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2Workflow.f[`project`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2WorkflowConnection.f[`edges`]!.nt = ProjectV2WorkflowEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2WorkflowConnection.f[`nodes`]!.nt = ProjectV2Workflow
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2WorkflowConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ProjectV2WorkflowEdge.f[`node`]!.nt = ProjectV2Workflow
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PublicKeyConnection.f[`edges`]!.nt = PublicKeyEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PublicKeyConnection.f[`nodes`]!.nt = PublicKey
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PublicKeyConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PublicKeyEdge.f[`node`]!.nt = PublicKey
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PublishSponsorsTierPayload.f[`sponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`assignees`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`autoMergeRequest`]!.nt = AutoMergeRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`baseRef`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`baseRepository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`closingIssuesReferences`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`comments`]!.nt = IssueCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`commits`]!.nt = PullRequestCommitConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`files`]!.nt = PullRequestChangedFileConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`headRef`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`headRepository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`headRepositoryOwner`]!.nt = RepositoryOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`hovercard`]!.nt = Hovercard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`latestOpinionatedReviews`]!.nt = PullRequestReviewConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`latestReviews`]!.nt = PullRequestReviewConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`mergeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`mergeQueue`]!.nt = MergeQueue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`mergeQueueEntry`]!.nt = MergeQueueEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`mergedBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`milestone`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`participants`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`potentialMergeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`projectCards`]!.nt = ProjectCardConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`projectItems`]!.nt = ProjectV2ItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`reviewRequests`]!.nt = ReviewRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`reviewThreads`]!.nt = PullRequestReviewThreadConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`reviews`]!.nt = PullRequestReviewConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`statusCheckRollup`]!.nt = StatusCheckRollup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`suggestedReviewers`]!.nt = SuggestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`timeline`]!.nt = PullRequestTimelineConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`timelineItems`]!.nt = PullRequestTimelineItemsConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`viewerLatestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequest.f[`viewerLatestReviewRequest`]!.nt = ReviewRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestChangedFileConnection.f[`edges`]!.nt = PullRequestChangedFileEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestChangedFileConnection.f[`nodes`]!.nt = PullRequestChangedFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestChangedFileConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestChangedFileEdge.f[`node`]!.nt = PullRequestChangedFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommit.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommit.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitCommentThread.f[`comments`]!.nt = CommitCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitCommentThread.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitCommentThread.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitCommentThread.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitConnection.f[`edges`]!.nt = PullRequestCommitEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitConnection.f[`nodes`]!.nt = PullRequestCommit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestCommitEdge.f[`node`]!.nt = PullRequestCommit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestConnection.f[`edges`]!.nt = PullRequestEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestConnection.f[`nodes`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestContributionsByRepository.f[`contributions`]!.nt = CreatedPullRequestContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestContributionsByRepository.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestEdge.f[`node`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`comments`]!.nt = PullRequestReviewCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`onBehalfOf`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReview.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`originalCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`replyTo`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewCommentConnection.f[`edges`]!.nt = PullRequestReviewCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewCommentConnection.f[`nodes`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewCommentEdge.f[`node`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewConnection.f[`edges`]!.nt = PullRequestReviewEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewConnection.f[`nodes`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewContributionsByRepository.f[`contributions`]!.nt = CreatedPullRequestReviewContributionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewContributionsByRepository.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewEdge.f[`node`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThread.f[`comments`]!.nt = PullRequestReviewCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThread.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThread.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThread.f[`resolvedBy`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThreadConnection.f[`edges`]!.nt = PullRequestReviewThreadEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThreadConnection.f[`nodes`]!.nt = PullRequestReviewThread
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThreadConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestReviewThreadEdge.f[`node`]!.nt = PullRequestReviewThread
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestRevisionMarker.f[`lastSeenCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestRevisionMarker.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTemplate.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestThread.f[`comments`]!.nt = PullRequestReviewCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestThread.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestThread.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestThread.f[`resolvedBy`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineConnection.f[`edges`]!.nt = PullRequestTimelineItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineConnection.f[`nodes`]!.nt = PullRequestTimelineItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineItemEdge.f[`node`]!.nt = PullRequestTimelineItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineItemsConnection.f[`edges`]!.nt = PullRequestTimelineItemsEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineItemsConnection.f[`nodes`]!.nt = PullRequestTimelineItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineItemsConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PullRequestTimelineItemsEdge.f[`node`]!.nt = PullRequestTimelineItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Push.f[`pusher`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Push.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowance.f[`actor`]!.nt = PushAllowanceActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowance.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowanceConnection.f[`edges`]!.nt = PushAllowanceEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowanceConnection.f[`nodes`]!.nt = PushAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowanceConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
PushAllowanceEdge.f[`node`]!.nt = PushAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactingUserConnection.f[`edges`]!.nt = ReactingUserEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactingUserConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactingUserConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactingUserEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Reaction.f[`reactable`]!.nt = Reactable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Reaction.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionConnection.f[`edges`]!.nt = ReactionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionConnection.f[`nodes`]!.nt = Reaction
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionEdge.f[`node`]!.nt = Reaction
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionGroup.f[`reactors`]!.nt = ReactorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionGroup.f[`subject`]!.nt = Reactable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactionGroup.f[`users`]!.nt = ReactingUserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactorConnection.f[`edges`]!.nt = ReactorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactorConnection.f[`nodes`]!.nt = Reactor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReactorEdge.f[`node`]!.nt = Reactor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReadyForReviewEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReadyForReviewEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`associatedPullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`compare`]!.nt = Comparison
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`refUpdateRule`]!.nt = RefUpdateRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`rules`]!.nt = RepositoryRuleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Ref.f[`target`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RefConnection.f[`edges`]!.nt = RefEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RefConnection.f[`nodes`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RefConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RefEdge.f[`node`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReferencedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReferencedEvent.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReferencedEvent.f[`commitRepository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReferencedEvent.f[`subject`]!.nt = ReferencedSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RegenerateEnterpriseIdentityProviderRecoveryCodesPayload.f[`identityProvider`]!.nt = EnterpriseIdentityProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RejectDeploymentsPayload.f[`deployments`]!.nt = Deployment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`author`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`mentions`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`releaseAssets`]!.nt = ReleaseAssetConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`tag`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Release.f[`tagCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAsset.f[`release`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAsset.f[`uploadedBy`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAssetConnection.f[`edges`]!.nt = ReleaseAssetEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAssetConnection.f[`nodes`]!.nt = ReleaseAsset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAssetConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseAssetEdge.f[`node`]!.nt = ReleaseAsset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseConnection.f[`edges`]!.nt = ReleaseEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseConnection.f[`nodes`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReleaseEdge.f[`node`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveAssigneesFromAssignablePayload.f[`assignable`]!.nt = Assignable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseAdminPayload.f[`admin`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseAdminPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseAdminPayload.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseIdentityProviderPayload.f[`identityProvider`]!.nt = EnterpriseIdentityProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseMemberPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseMemberPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseMemberPayload.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseOrganizationPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseOrganizationPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveEnterpriseOrganizationPayload.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveLabelsFromLabelablePayload.f[`labelable`]!.nt = Labelable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveOutsideCollaboratorPayload.f[`removedUser`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveReactionPayload.f[`reaction`]!.nt = Reaction
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveReactionPayload.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveReactionPayload.f[`subject`]!.nt = Reactable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveStarPayload.f[`starrable`]!.nt = Starrable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveSubIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveSubIssuePayload.f[`subIssue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemoveUpvotePayload.f[`subject`]!.nt = Votable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromMergeQueueEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromMergeQueueEvent.f[`beforeCommit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromMergeQueueEvent.f[`enqueuer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromMergeQueueEvent.f[`mergeQueue`]!.nt = MergeQueue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromMergeQueueEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromProjectEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RemovedFromProjectEvent.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RenamedTitleEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RenamedTitleEvent.f[`subject`]!.nt = RenamedTitleSubject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReopenDiscussionPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReopenIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReopenPullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReopenedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReopenedEvent.f[`closable`]!.nt = Closable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReorderEnvironmentPayload.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAccessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAccessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAccessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAccessAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAccessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddMemberAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoAddTopicAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoArchivedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoArchivedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoArchivedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoArchivedAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoArchivedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoChangeMergeSettingAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoChangeMergeSettingAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoChangeMergeSettingAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoChangeMergeSettingAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoChangeMergeSettingAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableAnonymousGitAccessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableAnonymousGitAccessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableAnonymousGitAccessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableAnonymousGitAccessAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableAnonymousGitAccessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableCollaboratorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableCollaboratorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableCollaboratorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableCollaboratorsOnlyAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableCollaboratorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableContributorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableContributorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableContributorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableContributorsOnlyAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableContributorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableSockpuppetDisallowedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableSockpuppetDisallowedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableSockpuppetDisallowedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableSockpuppetDisallowedAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigDisableSockpuppetDisallowedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableAnonymousGitAccessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableAnonymousGitAccessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableAnonymousGitAccessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableAnonymousGitAccessAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableAnonymousGitAccessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableCollaboratorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableCollaboratorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableCollaboratorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableCollaboratorsOnlyAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableCollaboratorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableContributorsOnlyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableContributorsOnlyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableContributorsOnlyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableContributorsOnlyAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableContributorsOnlyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableSockpuppetDisallowedAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableSockpuppetDisallowedAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableSockpuppetDisallowedAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableSockpuppetDisallowedAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigEnableSockpuppetDisallowedAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigLockAnonymousGitAccessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigLockAnonymousGitAccessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigLockAnonymousGitAccessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigLockAnonymousGitAccessAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigLockAnonymousGitAccessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigUnlockAnonymousGitAccessAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigUnlockAnonymousGitAccessAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigUnlockAnonymousGitAccessAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigUnlockAnonymousGitAccessAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoConfigUnlockAnonymousGitAccessAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoCreateAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoCreateAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoCreateAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoCreateAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoCreateAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoDestroyAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoDestroyAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoDestroyAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoDestroyAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoDestroyAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveMemberAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepoRemoveTopicAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`assignableUsers`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`branchProtectionRules`]!.nt = BranchProtectionRuleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`codeOfConduct`]!.nt = CodeOfConduct
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`codeowners`]!.nt = RepositoryCodeowners
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`collaborators`]!.nt = RepositoryCollaboratorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`commitComments`]!.nt = CommitCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`contactLinks`]!.nt = RepositoryContactLink
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`contributingGuidelines`]!.nt = ContributingGuidelines
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`defaultBranchRef`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`dependencyGraphManifests`]!.nt = DependencyGraphManifestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`deployKeys`]!.nt = DeployKeyConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`deployments`]!.nt = DeploymentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`discussionCategories`]!.nt = DiscussionCategoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`discussionCategory`]!.nt = DiscussionCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`discussions`]!.nt = DiscussionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`environments`]!.nt = EnvironmentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`forks`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`fundingLinks`]!.nt = FundingLink
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`interactionAbility`]!.nt = RepositoryInteractionAbility
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`issueOrPullRequest`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`issueTemplates`]!.nt = IssueTemplate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`issues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`label`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`labels`]!.nt = LabelConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`languages`]!.nt = LanguageConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`latestRelease`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`licenseInfo`]!.nt = License
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`mentionableUsers`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`mergeQueue`]!.nt = MergeQueue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`milestone`]!.nt = Milestone
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`milestones`]!.nt = MilestoneConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`object`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`owner`]!.nt = RepositoryOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`packages`]!.nt = PackageConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`parent`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pinnedDiscussions`]!.nt = PinnedDiscussionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pinnedEnvironments`]!.nt = PinnedEnvironmentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pinnedIssues`]!.nt = PinnedIssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`planFeatures`]!.nt = RepositoryPlanFeatures
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`primaryLanguage`]!.nt = Language
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`projects`]!.nt = ProjectConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pullRequestTemplates`]!.nt = PullRequestTemplate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`pullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`recentProjects`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`refs`]!.nt = RefConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`release`]!.nt = Release
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`releases`]!.nt = ReleaseConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`repositoryTopics`]!.nt = RepositoryTopicConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`ruleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`rulesets`]!.nt = RepositoryRulesetConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`stargazers`]!.nt = StargazerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`submodules`]!.nt = SubmoduleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`templateRepository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`vulnerabilityAlert`]!.nt = RepositoryVulnerabilityAlert
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`vulnerabilityAlerts`]!.nt = RepositoryVulnerabilityAlertConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Repository.f[`watchers`]!.nt = UserConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCodeowners.f[`errors`]!.nt = RepositoryCodeownersError
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCollaboratorConnection.f[`edges`]!.nt = RepositoryCollaboratorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCollaboratorConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCollaboratorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCollaboratorEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryCollaboratorEdge.f[`permissionSources`]!.nt = PermissionSource
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryConnection.f[`edges`]!.nt = RepositoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryConnection.f[`nodes`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryEdge.f[`node`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitation.f[`invitee`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitation.f[`inviter`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitation.f[`repository`]!.nt = RepositoryInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitationConnection.f[`edges`]!.nt = RepositoryInvitationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitationConnection.f[`nodes`]!.nt = RepositoryInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryInvitationEdge.f[`node`]!.nt = RepositoryInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryMigration.f[`migrationSource`]!.nt = MigrationSource
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryMigrationConnection.f[`edges`]!.nt = RepositoryMigrationEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryMigrationConnection.f[`nodes`]!.nt = RepositoryMigration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryMigrationConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryMigrationEdge.f[`node`]!.nt = RepositoryMigration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryPropertyConditionTarget.f[`exclude`]!.nt = PropertyTargetDefinition
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryPropertyConditionTarget.f[`include`]!.nt = PropertyTargetDefinition
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRule.f[`parameters`]!.nt = RuleParameters
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRule.f[`repositoryRuleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConditions.f[`refName`]!.nt = RefNameConditionTarget
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConditions.f[`repositoryId`]!.nt = RepositoryIdConditionTarget
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConditions.f[`repositoryName`]!.nt = RepositoryNameConditionTarget
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConditions.f[`repositoryProperty`]!.nt = RepositoryPropertyConditionTarget
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConnection.f[`edges`]!.nt = RepositoryRuleEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConnection.f[`nodes`]!.nt = RepositoryRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleEdge.f[`node`]!.nt = RepositoryRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleset.f[`bypassActors`]!.nt = RepositoryRulesetBypassActorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleset.f[`conditions`]!.nt = RepositoryRuleConditions
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleset.f[`rules`]!.nt = RepositoryRuleConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRuleset.f[`source`]!.nt = RuleSource
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActor.f[`actor`]!.nt = BypassActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActor.f[`repositoryRuleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActorConnection.f[`edges`]!.nt = RepositoryRulesetBypassActorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActorConnection.f[`nodes`]!.nt = RepositoryRulesetBypassActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetBypassActorEdge.f[`node`]!.nt = RepositoryRulesetBypassActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetConnection.f[`edges`]!.nt = RepositoryRulesetEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetConnection.f[`nodes`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryRulesetEdge.f[`node`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryTopic.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryTopicConnection.f[`edges`]!.nt = RepositoryTopicEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryTopicConnection.f[`nodes`]!.nt = RepositoryTopic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryTopicConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryTopicEdge.f[`node`]!.nt = RepositoryTopic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeDisableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeDisableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeDisableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeDisableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeEnableAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeEnableAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeEnableAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVisibilityChangeEnableAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlert.f[`dependabotUpdate`]!.nt = DependabotUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlert.f[`dismisser`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlert.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlert.f[`securityAdvisory`]!.nt = SecurityAdvisory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlert.f[`securityVulnerability`]!.nt = SecurityVulnerability
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlertConnection.f[`edges`]!.nt = RepositoryVulnerabilityAlertEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlertConnection.f[`nodes`]!.nt = RepositoryVulnerabilityAlert
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlertConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RepositoryVulnerabilityAlertEdge.f[`node`]!.nt = RepositoryVulnerabilityAlert
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReprioritizeSubIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestReviewsPayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestReviewsPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestReviewsPayload.f[`requestedReviewersEdge`]!.nt = UserEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestedReviewerConnection.f[`edges`]!.nt = RequestedReviewerEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestedReviewerConnection.f[`nodes`]!.nt = RequestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestedReviewerConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequestedReviewerEdge.f[`node`]!.nt = RequestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequiredStatusCheckDescription.f[`app`]!.nt = App
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RequiredStatusChecksParameters.f[`requiredStatusChecks`]!.nt = StatusCheckConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RerequestCheckSuitePayload.f[`checkSuite`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ResolveReviewThreadPayload.f[`thread`]!.nt = PullRequestReviewThread
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RestrictedContribution.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RetireSponsorsTierPayload.f[`sponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RevertPullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RevertPullRequestPayload.f[`revertPullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowance.f[`actor`]!.nt = ReviewDismissalAllowanceActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowance.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowanceConnection.f[`edges`]!.nt = ReviewDismissalAllowanceEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowanceConnection.f[`nodes`]!.nt = ReviewDismissalAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowanceConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissalAllowanceEdge.f[`node`]!.nt = ReviewDismissalAllowance
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissedEvent.f[`pullRequestCommit`]!.nt = PullRequestCommit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewDismissedEvent.f[`review`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequest.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequest.f[`requestedReviewer`]!.nt = RequestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestConnection.f[`edges`]!.nt = ReviewRequestEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestConnection.f[`nodes`]!.nt = ReviewRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestEdge.f[`node`]!.nt = ReviewRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestRemovedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestRemovedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestRemovedEvent.f[`requestedReviewer`]!.nt = RequestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestedEvent.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ReviewRequestedEvent.f[`requestedReviewer`]!.nt = RequestedReviewer
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
RevokeEnterpriseOrganizationsMigratorRolePayload.f[`organizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SavedReply.f[`user`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SavedReplyConnection.f[`edges`]!.nt = SavedReplyEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SavedReplyConnection.f[`nodes`]!.nt = SavedReply
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SavedReplyConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SavedReplyEdge.f[`node`]!.nt = SavedReply
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SearchResultItemConnection.f[`edges`]!.nt = SearchResultItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SearchResultItemConnection.f[`nodes`]!.nt = SearchResultItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SearchResultItemConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SearchResultItemEdge.f[`node`]!.nt = SearchResultItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SearchResultItemEdge.f[`textMatches`]!.nt = TextMatch
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`cvss`]!.nt = CVSS
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`cvssSeverities`]!.nt = CvssSeverities
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`cwes`]!.nt = CWEConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`epss`]!.nt = EPSS
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`identifiers`]!.nt = SecurityAdvisoryIdentifier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`references`]!.nt = SecurityAdvisoryReference
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisory.f[`vulnerabilities`]!.nt = SecurityVulnerabilityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisoryConnection.f[`edges`]!.nt = SecurityAdvisoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisoryConnection.f[`nodes`]!.nt = SecurityAdvisory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityAdvisoryEdge.f[`node`]!.nt = SecurityAdvisory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerability.f[`advisory`]!.nt = SecurityAdvisory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerability.f[`firstPatchedVersion`]!.nt = SecurityAdvisoryPackageVersion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerability.f[`package`]!.nt = SecurityAdvisoryPackage
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerabilityConnection.f[`edges`]!.nt = SecurityVulnerabilityEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerabilityConnection.f[`nodes`]!.nt = SecurityVulnerability
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerabilityConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SecurityVulnerabilityEdge.f[`node`]!.nt = SecurityVulnerability
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SetEnterpriseIdentityProviderPayload.f[`identityProvider`]!.nt = EnterpriseIdentityProvider
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SetOrganizationInteractionLimitPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SetRepositoryInteractionLimitPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SetUserInteractionLimitPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SmimeSignature.f[`signer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SocialAccountConnection.f[`edges`]!.nt = SocialAccountEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SocialAccountConnection.f[`nodes`]!.nt = SocialAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SocialAccountConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SocialAccountEdge.f[`node`]!.nt = SocialAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValue.f[`sponsor`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValue.f[`sponsorable`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValueConnection.f[`edges`]!.nt = SponsorAndLifetimeValueEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValueConnection.f[`nodes`]!.nt = SponsorAndLifetimeValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValueConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorAndLifetimeValueEdge.f[`node`]!.nt = SponsorAndLifetimeValue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorConnection.f[`edges`]!.nt = SponsorEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorConnection.f[`nodes`]!.nt = Sponsor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorEdge.f[`node`]!.nt = Sponsor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorableItemConnection.f[`edges`]!.nt = SponsorableItemEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorableItemConnection.f[`nodes`]!.nt = SponsorableItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorableItemConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorableItemEdge.f[`node`]!.nt = SponsorableItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivity.f[`previousSponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivity.f[`sponsor`]!.nt = Sponsor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivity.f[`sponsorable`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivity.f[`sponsorsTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivityConnection.f[`edges`]!.nt = SponsorsActivityEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivityConnection.f[`nodes`]!.nt = SponsorsActivity
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivityConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsActivityEdge.f[`node`]!.nt = SponsorsActivity
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`activeGoal`]!.nt = SponsorsGoal
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`activeStripeConnectAccount`]!.nt = StripeConnectAccount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`featuredItems`]!.nt = SponsorsListingFeaturedItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`fiscalHost`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`sponsorable`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListing.f[`tiers`]!.nt = SponsorsTierConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListingFeaturedItem.f[`featureable`]!.nt = SponsorsListingFeatureableItem
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsListingFeaturedItem.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTier.f[`adminInfo`]!.nt = SponsorsTierAdminInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTier.f[`closestLesserValueTier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTier.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTierAdminInfo.f[`sponsorships`]!.nt = SponsorshipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTierConnection.f[`edges`]!.nt = SponsorsTierEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTierConnection.f[`nodes`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTierConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorsTierEdge.f[`node`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Sponsorship.f[`maintainer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Sponsorship.f[`sponsor`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Sponsorship.f[`sponsorEntity`]!.nt = Sponsor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Sponsorship.f[`sponsorable`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Sponsorship.f[`tier`]!.nt = SponsorsTier
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipConnection.f[`edges`]!.nt = SponsorshipEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipConnection.f[`nodes`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipEdge.f[`node`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletter.f[`author`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletter.f[`sponsorable`]!.nt = Sponsorable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletterConnection.f[`edges`]!.nt = SponsorshipNewsletterEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletterConnection.f[`nodes`]!.nt = SponsorshipNewsletter
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletterConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SponsorshipNewsletterEdge.f[`node`]!.nt = SponsorshipNewsletter
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SshSignature.f[`signer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StargazerConnection.f[`edges`]!.nt = StargazerEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StargazerConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StargazerConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StargazerEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StarredRepositoryConnection.f[`edges`]!.nt = StarredRepositoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StarredRepositoryConnection.f[`nodes`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StarredRepositoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StarredRepositoryEdge.f[`node`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StartOrganizationMigrationPayload.f[`orgMigration`]!.nt = OrganizationMigration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StartRepositoryMigrationPayload.f[`repositoryMigration`]!.nt = RepositoryMigration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Status.f[`combinedContexts`]!.nt = StatusCheckRollupContextConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Status.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Status.f[`context`]!.nt = StatusContext
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Status.f[`contexts`]!.nt = StatusContext
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollup.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollup.f[`contexts`]!.nt = StatusCheckRollupContextConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextConnection.f[`checkRunCountsByState`]!.nt = CheckRunStateCount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextConnection.f[`edges`]!.nt = StatusCheckRollupContextEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextConnection.f[`nodes`]!.nt = StatusCheckRollupContext
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextConnection.f[`statusContextCountsByState`]!.nt = StatusContextStateCount
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusCheckRollupContextEdge.f[`node`]!.nt = StatusCheckRollupContext
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusContext.f[`commit`]!.nt = Commit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StatusContext.f[`creator`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
StripeConnectAccount.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubIssueAddedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubIssueAddedEvent.f[`subIssue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubIssueRemovedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubIssueRemovedEvent.f[`subIssue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubmitPullRequestReviewPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubmoduleConnection.f[`edges`]!.nt = SubmoduleEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubmoduleConnection.f[`nodes`]!.nt = Submodule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubmoduleConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubmoduleEdge.f[`node`]!.nt = Submodule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubscribedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SubscribedEvent.f[`subscribable`]!.nt = Subscribable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
SuggestedReviewer.f[`reviewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Tag.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Tag.f[`tagger`]!.nt = GitActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Tag.f[`target`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`ancestors`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`childTeams`]!.nt = TeamConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`discussion`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`discussions`]!.nt = TeamDiscussionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`invitations`]!.nt = OrganizationInvitationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`memberStatuses`]!.nt = UserStatusConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`members`]!.nt = TeamMemberConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`parentTeam`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Team.f[`repositories`]!.nt = TeamRepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddMemberAuditEntry.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamAddRepositoryAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`parentTeam`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`parentTeamWas`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamChangeParentTeamAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamConnection.f[`edges`]!.nt = TeamEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamConnection.f[`nodes`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`comments`]!.nt = TeamDiscussionCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussion.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`author`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`discussion`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`reactionGroups`]!.nt = ReactionGroup
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`reactions`]!.nt = ReactionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionComment.f[`userContentEdits`]!.nt = UserContentEditConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionCommentConnection.f[`edges`]!.nt = TeamDiscussionCommentEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionCommentConnection.f[`nodes`]!.nt = TeamDiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionCommentConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionCommentEdge.f[`node`]!.nt = TeamDiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionConnection.f[`edges`]!.nt = TeamDiscussionEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionConnection.f[`nodes`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamDiscussionEdge.f[`node`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamEdge.f[`node`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamMemberConnection.f[`edges`]!.nt = TeamMemberEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamMemberConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamMemberConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamMemberEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveMemberAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveMemberAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveMemberAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveMemberAuditEntry.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveMemberAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`actor`]!.nt = AuditEntryActor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`actorLocation`]!.nt = ActorLocation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRemoveRepositoryAuditEntry.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRepositoryConnection.f[`edges`]!.nt = TeamRepositoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRepositoryConnection.f[`nodes`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRepositoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TeamRepositoryEdge.f[`node`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TextMatch.f[`highlights`]!.nt = TextMatchHighlight
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Topic.f[`relatedTopics`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Topic.f[`repositories`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Topic.f[`stargazers`]!.nt = StargazerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TransferEnterpriseOrganizationPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TransferIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TransferredEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TransferredEvent.f[`fromRepository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TransferredEvent.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Tree.f[`entries`]!.nt = TreeEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Tree.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TreeEntry.f[`language`]!.nt = Language
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TreeEntry.f[`object`]!.nt = GitObject
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TreeEntry.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
TreeEntry.f[`submodule`]!.nt = Submodule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnarchiveProjectV2ItemPayload.f[`item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnarchiveRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnassignedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnassignedEvent.f[`assignable`]!.nt = Assignable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnassignedEvent.f[`assignee`]!.nt = Assignee
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnassignedEvent.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnfollowOrganizationPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnfollowUserPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnknownSignature.f[`signer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlabeledEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlabeledEvent.f[`label`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlabeledEvent.f[`labelable`]!.nt = Labelable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlinkProjectV2FromRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlinkProjectV2FromTeamPayload.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlinkRepositoryFromProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlinkRepositoryFromProjectPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlockLockablePayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlockLockablePayload.f[`unlockedRecord`]!.nt = Lockable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlockedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnlockedEvent.f[`lockable`]!.nt = Lockable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkDiscussionCommentAsAnswerPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkFileAsViewedPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkIssueAsDuplicatePayload.f[`duplicate`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkProjectV2AsTemplatePayload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkedAsDuplicateEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkedAsDuplicateEvent.f[`canonical`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnmarkedAsDuplicateEvent.f[`duplicate`]!.nt = IssueOrPullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnminimizeCommentPayload.f[`unminimizedComment`]!.nt = Minimizable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnpinIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnpinnedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnpinnedEvent.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnresolveReviewThreadPayload.f[`thread`]!.nt = PullRequestReviewThread
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnsubscribedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UnsubscribedEvent.f[`subscribable`]!.nt = Subscribable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateBranchProtectionRulePayload.f[`branchProtectionRule`]!.nt = BranchProtectionRule
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateCheckRunPayload.f[`checkRun`]!.nt = CheckRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateCheckSuitePreferencesPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateDiscussionCommentPayload.f[`comment`]!.nt = DiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateDiscussionPayload.f[`discussion`]!.nt = Discussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseDefaultRepositoryPermissionSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseDeployKeySettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanDeleteIssuesSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanMakePurchasesSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseOrganizationProjectsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseProfilePayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseRepositoryProjectsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseTeamDiscussionsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateEnvironmentPayload.f[`environment`]!.nt = Environment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIpAllowListEnabledSettingPayload.f[`owner`]!.nt = IpAllowListOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIpAllowListEntryPayload.f[`ipAllowListEntry`]!.nt = IpAllowListEntry
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIpAllowListForInstalledAppsEnabledSettingPayload.f[`owner`]!.nt = IpAllowListOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIssueCommentPayload.f[`issueComment`]!.nt = IssueComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIssuePayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateIssuePayload.f[`issue`]!.nt = Issue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateLabelPayload.f[`label`]!.nt = Label
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateNotificationRestrictionSettingPayload.f[`owner`]!.nt = VerifiableDomainOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateOrganizationWebCommitSignoffSettingPayload.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePatreonSponsorabilityPayload.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectCardPayload.f[`projectCard`]!.nt = ProjectCard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectColumnPayload.f[`projectColumn`]!.nt = ProjectColumn
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectPayload.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2CollaboratorsPayload.f[`collaborators`]!.nt = ProjectV2ActorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2DraftIssuePayload.f[`draftIssue`]!.nt = DraftIssue
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2FieldPayload.f[`projectV2Field`]!.nt = ProjectV2FieldConfiguration
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2ItemFieldValuePayload.f[`projectV2Item`]!.nt = ProjectV2Item
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2ItemPositionPayload.f[`items`]!.nt = ProjectV2ItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2Payload.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateProjectV2StatusUpdatePayload.f[`statusUpdate`]!.nt = ProjectV2StatusUpdate
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePullRequestBranchPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePullRequestPayload.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePullRequestPayload.f[`pullRequest`]!.nt = PullRequest
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePullRequestReviewCommentPayload.f[`pullRequestReviewComment`]!.nt = PullRequestReviewComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdatePullRequestReviewPayload.f[`pullRequestReview`]!.nt = PullRequestReview
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateRefPayload.f[`ref`]!.nt = Ref
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateRepositoryRulesetPayload.f[`ruleset`]!.nt = RepositoryRuleset
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateRepositoryWebCommitSignoffSettingPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateSponsorshipPreferencesPayload.f[`sponsorship`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateSubscriptionPayload.f[`subscribable`]!.nt = Subscribable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTeamDiscussionCommentPayload.f[`teamDiscussionComment`]!.nt = TeamDiscussionComment
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTeamDiscussionPayload.f[`teamDiscussion`]!.nt = TeamDiscussion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTeamReviewAssignmentPayload.f[`team`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTeamsRepositoryPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTeamsRepositoryPayload.f[`teams`]!.nt = Team
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateTopicsPayload.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateUserListPayload.f[`list`]!.nt = UserList
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateUserListsForItemPayload.f[`item`]!.nt = UserListItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateUserListsForItemPayload.f[`lists`]!.nt = UserList
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UpdateUserListsForItemPayload.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`commitComments`]!.nt = CommitCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`contributionsCollection`]!.nt = ContributionsCollection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`copilotEndpoints`]!.nt = CopilotEndpoints
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`enterprises`]!.nt = EnterpriseConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`followers`]!.nt = FollowerConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`following`]!.nt = FollowingConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`gist`]!.nt = Gist
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`gistComments`]!.nt = GistCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`gists`]!.nt = GistConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`hovercard`]!.nt = Hovercard
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`interactionAbility`]!.nt = RepositoryInteractionAbility
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`issueComments`]!.nt = IssueCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`issues`]!.nt = IssueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`itemShowcase`]!.nt = ProfileItemShowcase
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`lifetimeReceivedSponsorshipValues`]!.nt = SponsorAndLifetimeValueConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`lists`]!.nt = UserListConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`organizations`]!.nt = OrganizationConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`packages`]!.nt = PackageConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`pinnableItems`]!.nt = PinnableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`pinnedItems`]!.nt = PinnableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`project`]!.nt = Project
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`projectV2`]!.nt = ProjectV2
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`projects`]!.nt = ProjectConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`projectsV2`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`publicKeys`]!.nt = PublicKeyConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`pullRequests`]!.nt = PullRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`recentProjects`]!.nt = ProjectV2Connection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`repositories`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`repositoriesContributedTo`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`repositoryDiscussionComments`]!.nt = DiscussionCommentConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`repositoryDiscussions`]!.nt = DiscussionConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`savedReplies`]!.nt = SavedReplyConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`socialAccounts`]!.nt = SocialAccountConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsoring`]!.nt = SponsorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsors`]!.nt = SponsorConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorsActivities`]!.nt = SponsorsActivityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorsListing`]!.nt = SponsorsListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorshipForViewerAsSponsor`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorshipForViewerAsSponsorable`]!.nt = Sponsorship
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorshipNewsletters`]!.nt = SponsorshipNewsletterConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorshipsAsMaintainer`]!.nt = SponsorshipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`sponsorshipsAsSponsor`]!.nt = SponsorshipConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`starredRepositories`]!.nt = StarredRepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`status`]!.nt = UserStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`suggestedListNames`]!.nt = UserListSuggestion
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`topRepositories`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
User.f[`watching`]!.nt = RepositoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserBlockedEvent.f[`actor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserBlockedEvent.f[`subject`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserConnection.f[`edges`]!.nt = UserEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserConnection.f[`nodes`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEdit.f[`deletedBy`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEdit.f[`editor`]!.nt = Actor
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEditConnection.f[`edges`]!.nt = UserContentEditEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEditConnection.f[`nodes`]!.nt = UserContentEdit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEditConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserContentEditEdge.f[`node`]!.nt = UserContentEdit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserEdge.f[`node`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserList.f[`items`]!.nt = UserListItemsConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserList.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListConnection.f[`edges`]!.nt = UserListEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListConnection.f[`nodes`]!.nt = UserList
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListEdge.f[`node`]!.nt = UserList
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListItemsConnection.f[`edges`]!.nt = UserListItemsEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListItemsConnection.f[`nodes`]!.nt = UserListItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListItemsConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserListItemsEdge.f[`node`]!.nt = UserListItems
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepository.f[`owner`]!.nt = RepositoryOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepository.f[`repository`]!.nt = RepositoryInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepositoryConnection.f[`edges`]!.nt = UserNamespaceRepositoryEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepositoryConnection.f[`nodes`]!.nt = UserNamespaceRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepositoryConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserNamespaceRepositoryEdge.f[`node`]!.nt = UserNamespaceRepository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatus.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatus.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatusConnection.f[`edges`]!.nt = UserStatusEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatusConnection.f[`nodes`]!.nt = UserStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatusConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
UserStatusEdge.f[`node`]!.nt = UserStatus
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifiableDomain.f[`owner`]!.nt = VerifiableDomainOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifiableDomainConnection.f[`edges`]!.nt = VerifiableDomainEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifiableDomainConnection.f[`nodes`]!.nt = VerifiableDomain
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifiableDomainConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifiableDomainEdge.f[`node`]!.nt = VerifiableDomain
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
VerifyVerifiableDomainPayload.f[`domain`]!.nt = VerifiableDomain
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
ViewerHovercardContext.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Workflow.f[`runs`]!.nt = WorkflowRunConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRun.f[`checkSuite`]!.nt = CheckSuite
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRun.f[`deploymentReviews`]!.nt = DeploymentReviewConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRun.f[`file`]!.nt = WorkflowRunFile
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRun.f[`pendingDeploymentRequests`]!.nt = DeploymentRequestConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRun.f[`workflow`]!.nt = Workflow
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRunConnection.f[`edges`]!.nt = WorkflowRunEdge
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRunConnection.f[`nodes`]!.nt = WorkflowRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRunConnection.f[`pageInfo`]!.nt = PageInfo
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRunEdge.f[`node`]!.nt = WorkflowRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowRunFile.f[`run`]!.nt = WorkflowRun
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
WorkflowsParameters.f[`workflows`]!.nt = WorkflowFileReference
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`codeOfConduct`]!.nt = CodeOfConduct
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`codesOfConduct`]!.nt = CodeOfConduct
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`enterprise`]!.nt = Enterprise
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`enterpriseAdministratorInvitation`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`enterpriseAdministratorInvitationByToken`]!.nt = EnterpriseAdministratorInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`enterpriseMemberInvitation`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`enterpriseMemberInvitationByToken`]!.nt = EnterpriseMemberInvitation
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`license`]!.nt = License
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`licenses`]!.nt = License
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`marketplaceCategories`]!.nt = MarketplaceCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`marketplaceCategory`]!.nt = MarketplaceCategory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`marketplaceListing`]!.nt = MarketplaceListing
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`marketplaceListings`]!.nt = MarketplaceListingConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`meta`]!.nt = GitHubMetadata
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`node`]!.nt = Node
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`nodes`]!.nt = Node
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`organization`]!.nt = Organization
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`rateLimit`]!.nt = RateLimit
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`relay`]!.nt = Query
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`repository`]!.nt = Repository
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`repositoryOwner`]!.nt = RepositoryOwner
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`resource`]!.nt = UniformResourceLocatable
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`search`]!.nt = SearchResultItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`securityAdvisories`]!.nt = SecurityAdvisoryConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`securityAdvisory`]!.nt = SecurityAdvisory
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`securityVulnerabilities`]!.nt = SecurityVulnerabilityConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`sponsorables`]!.nt = SponsorableItemConnection
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`topic`]!.nt = Topic
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`user`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Query.f[`viewer`]!.nt = User
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`abortQueuedMigrations`]!.nt = AbortQueuedMigrationsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`abortRepositoryMigration`]!.nt = AbortRepositoryMigrationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`acceptEnterpriseAdministratorInvitation`]!.nt = AcceptEnterpriseAdministratorInvitationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`acceptEnterpriseMemberInvitation`]!.nt = AcceptEnterpriseMemberInvitationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`acceptTopicSuggestion`]!.nt = AcceptTopicSuggestionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`accessUserNamespaceRepository`]!.nt = AccessUserNamespaceRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addAssigneesToAssignable`]!.nt = AddAssigneesToAssignablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addComment`]!.nt = AddCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addDiscussionComment`]!.nt = AddDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addDiscussionPollVote`]!.nt = AddDiscussionPollVotePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addEnterpriseOrganizationMember`]!.nt = AddEnterpriseOrganizationMemberPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addEnterpriseSupportEntitlement`]!.nt = AddEnterpriseSupportEntitlementPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addLabelsToLabelable`]!.nt = AddLabelsToLabelablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addProjectCard`]!.nt = AddProjectCardPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addProjectColumn`]!.nt = AddProjectColumnPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addProjectV2DraftIssue`]!.nt = AddProjectV2DraftIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addProjectV2ItemById`]!.nt = AddProjectV2ItemByIdPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addPullRequestReview`]!.nt = AddPullRequestReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addPullRequestReviewComment`]!.nt = AddPullRequestReviewCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addPullRequestReviewThread`]!.nt = AddPullRequestReviewThreadPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addPullRequestReviewThreadReply`]!.nt = AddPullRequestReviewThreadReplyPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addReaction`]!.nt = AddReactionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addStar`]!.nt = AddStarPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addSubIssue`]!.nt = AddSubIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addUpvote`]!.nt = AddUpvotePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`addVerifiableDomain`]!.nt = AddVerifiableDomainPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`approveDeployments`]!.nt = ApproveDeploymentsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`approveVerifiableDomain`]!.nt = ApproveVerifiableDomainPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`archiveProjectV2Item`]!.nt = ArchiveProjectV2ItemPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`archiveRepository`]!.nt = ArchiveRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`cancelEnterpriseAdminInvitation`]!.nt = CancelEnterpriseAdminInvitationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`cancelEnterpriseMemberInvitation`]!.nt = CancelEnterpriseMemberInvitationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`cancelSponsorship`]!.nt = CancelSponsorshipPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`changeUserStatus`]!.nt = ChangeUserStatusPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`clearLabelsFromLabelable`]!.nt = ClearLabelsFromLabelablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`clearProjectV2ItemFieldValue`]!.nt = ClearProjectV2ItemFieldValuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`cloneProject`]!.nt = CloneProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`cloneTemplateRepository`]!.nt = CloneTemplateRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`closeDiscussion`]!.nt = CloseDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`closeIssue`]!.nt = CloseIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`closePullRequest`]!.nt = ClosePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`convertProjectCardNoteToIssue`]!.nt = ConvertProjectCardNoteToIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`convertProjectV2DraftIssueItemToIssue`]!.nt = ConvertProjectV2DraftIssueItemToIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`convertPullRequestToDraft`]!.nt = ConvertPullRequestToDraftPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`copyProjectV2`]!.nt = CopyProjectV2Payload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createAttributionInvitation`]!.nt = CreateAttributionInvitationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createBranchProtectionRule`]!.nt = CreateBranchProtectionRulePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createCheckRun`]!.nt = CreateCheckRunPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createCheckSuite`]!.nt = CreateCheckSuitePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createCommitOnBranch`]!.nt = CreateCommitOnBranchPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createDeployment`]!.nt = CreateDeploymentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createDeploymentStatus`]!.nt = CreateDeploymentStatusPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createDiscussion`]!.nt = CreateDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createEnterpriseOrganization`]!.nt = CreateEnterpriseOrganizationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createEnvironment`]!.nt = CreateEnvironmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createIpAllowListEntry`]!.nt = CreateIpAllowListEntryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createIssue`]!.nt = CreateIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createLabel`]!.nt = CreateLabelPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createLinkedBranch`]!.nt = CreateLinkedBranchPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createMigrationSource`]!.nt = CreateMigrationSourcePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createProject`]!.nt = CreateProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createProjectV2`]!.nt = CreateProjectV2Payload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createProjectV2Field`]!.nt = CreateProjectV2FieldPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createProjectV2StatusUpdate`]!.nt = CreateProjectV2StatusUpdatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createPullRequest`]!.nt = CreatePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createRef`]!.nt = CreateRefPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createRepository`]!.nt = CreateRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createRepositoryRuleset`]!.nt = CreateRepositoryRulesetPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createSponsorsListing`]!.nt = CreateSponsorsListingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createSponsorsTier`]!.nt = CreateSponsorsTierPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createSponsorship`]!.nt = CreateSponsorshipPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createSponsorships`]!.nt = CreateSponsorshipsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createTeamDiscussion`]!.nt = CreateTeamDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createTeamDiscussionComment`]!.nt = CreateTeamDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`createUserList`]!.nt = CreateUserListPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`declineTopicSuggestion`]!.nt = DeclineTopicSuggestionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteBranchProtectionRule`]!.nt = DeleteBranchProtectionRulePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteDeployment`]!.nt = DeleteDeploymentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteDiscussion`]!.nt = DeleteDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteDiscussionComment`]!.nt = DeleteDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteEnvironment`]!.nt = DeleteEnvironmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteIpAllowListEntry`]!.nt = DeleteIpAllowListEntryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteIssue`]!.nt = DeleteIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteIssueComment`]!.nt = DeleteIssueCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteLabel`]!.nt = DeleteLabelPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteLinkedBranch`]!.nt = DeleteLinkedBranchPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deletePackageVersion`]!.nt = DeletePackageVersionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProject`]!.nt = DeleteProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectCard`]!.nt = DeleteProjectCardPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectColumn`]!.nt = DeleteProjectColumnPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectV2`]!.nt = DeleteProjectV2Payload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectV2Field`]!.nt = DeleteProjectV2FieldPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectV2Item`]!.nt = DeleteProjectV2ItemPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectV2StatusUpdate`]!.nt = DeleteProjectV2StatusUpdatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteProjectV2Workflow`]!.nt = DeleteProjectV2WorkflowPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deletePullRequestReview`]!.nt = DeletePullRequestReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deletePullRequestReviewComment`]!.nt = DeletePullRequestReviewCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteRef`]!.nt = DeleteRefPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteRepositoryRuleset`]!.nt = DeleteRepositoryRulesetPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteTeamDiscussion`]!.nt = DeleteTeamDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteTeamDiscussionComment`]!.nt = DeleteTeamDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteUserList`]!.nt = DeleteUserListPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`deleteVerifiableDomain`]!.nt = DeleteVerifiableDomainPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`dequeuePullRequest`]!.nt = DequeuePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`disablePullRequestAutoMerge`]!.nt = DisablePullRequestAutoMergePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`dismissPullRequestReview`]!.nt = DismissPullRequestReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`dismissRepositoryVulnerabilityAlert`]!.nt = DismissRepositoryVulnerabilityAlertPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`enablePullRequestAutoMerge`]!.nt = EnablePullRequestAutoMergePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`enqueuePullRequest`]!.nt = EnqueuePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`followOrganization`]!.nt = FollowOrganizationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`followUser`]!.nt = FollowUserPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`grantEnterpriseOrganizationsMigratorRole`]!.nt = GrantEnterpriseOrganizationsMigratorRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`grantMigratorRole`]!.nt = GrantMigratorRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`importProject`]!.nt = ImportProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`inviteEnterpriseAdmin`]!.nt = InviteEnterpriseAdminPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`inviteEnterpriseMember`]!.nt = InviteEnterpriseMemberPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`linkProjectV2ToRepository`]!.nt = LinkProjectV2ToRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`linkProjectV2ToTeam`]!.nt = LinkProjectV2ToTeamPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`linkRepositoryToProject`]!.nt = LinkRepositoryToProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`lockLockable`]!.nt = LockLockablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`markDiscussionCommentAsAnswer`]!.nt = MarkDiscussionCommentAsAnswerPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`markFileAsViewed`]!.nt = MarkFileAsViewedPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`markProjectV2AsTemplate`]!.nt = MarkProjectV2AsTemplatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`markPullRequestReadyForReview`]!.nt = MarkPullRequestReadyForReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`mergeBranch`]!.nt = MergeBranchPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`mergePullRequest`]!.nt = MergePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`minimizeComment`]!.nt = MinimizeCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`moveProjectCard`]!.nt = MoveProjectCardPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`moveProjectColumn`]!.nt = MoveProjectColumnPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`pinEnvironment`]!.nt = PinEnvironmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`pinIssue`]!.nt = PinIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`publishSponsorsTier`]!.nt = PublishSponsorsTierPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`regenerateEnterpriseIdentityProviderRecoveryCodes`]!.nt =
  RegenerateEnterpriseIdentityProviderRecoveryCodesPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`regenerateVerifiableDomainToken`]!.nt = RegenerateVerifiableDomainTokenPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`rejectDeployments`]!.nt = RejectDeploymentsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeAssigneesFromAssignable`]!.nt = RemoveAssigneesFromAssignablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeEnterpriseAdmin`]!.nt = RemoveEnterpriseAdminPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeEnterpriseIdentityProvider`]!.nt = RemoveEnterpriseIdentityProviderPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeEnterpriseMember`]!.nt = RemoveEnterpriseMemberPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeEnterpriseOrganization`]!.nt = RemoveEnterpriseOrganizationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeEnterpriseSupportEntitlement`]!.nt = RemoveEnterpriseSupportEntitlementPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeLabelsFromLabelable`]!.nt = RemoveLabelsFromLabelablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeOutsideCollaborator`]!.nt = RemoveOutsideCollaboratorPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeReaction`]!.nt = RemoveReactionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeStar`]!.nt = RemoveStarPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeSubIssue`]!.nt = RemoveSubIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`removeUpvote`]!.nt = RemoveUpvotePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`reopenDiscussion`]!.nt = ReopenDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`reopenIssue`]!.nt = ReopenIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`reopenPullRequest`]!.nt = ReopenPullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`reorderEnvironment`]!.nt = ReorderEnvironmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`reprioritizeSubIssue`]!.nt = ReprioritizeSubIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`requestReviews`]!.nt = RequestReviewsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`rerequestCheckSuite`]!.nt = RerequestCheckSuitePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`resolveReviewThread`]!.nt = ResolveReviewThreadPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`retireSponsorsTier`]!.nt = RetireSponsorsTierPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`revertPullRequest`]!.nt = RevertPullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`revokeEnterpriseOrganizationsMigratorRole`]!.nt = RevokeEnterpriseOrganizationsMigratorRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`revokeMigratorRole`]!.nt = RevokeMigratorRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`setEnterpriseIdentityProvider`]!.nt = SetEnterpriseIdentityProviderPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`setOrganizationInteractionLimit`]!.nt = SetOrganizationInteractionLimitPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`setRepositoryInteractionLimit`]!.nt = SetRepositoryInteractionLimitPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`setUserInteractionLimit`]!.nt = SetUserInteractionLimitPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`startOrganizationMigration`]!.nt = StartOrganizationMigrationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`startRepositoryMigration`]!.nt = StartRepositoryMigrationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`submitPullRequestReview`]!.nt = SubmitPullRequestReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`transferEnterpriseOrganization`]!.nt = TransferEnterpriseOrganizationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`transferIssue`]!.nt = TransferIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unarchiveProjectV2Item`]!.nt = UnarchiveProjectV2ItemPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unarchiveRepository`]!.nt = UnarchiveRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unfollowOrganization`]!.nt = UnfollowOrganizationPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unfollowUser`]!.nt = UnfollowUserPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unlinkProjectV2FromRepository`]!.nt = UnlinkProjectV2FromRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unlinkProjectV2FromTeam`]!.nt = UnlinkProjectV2FromTeamPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unlinkRepositoryFromProject`]!.nt = UnlinkRepositoryFromProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unlockLockable`]!.nt = UnlockLockablePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unmarkDiscussionCommentAsAnswer`]!.nt = UnmarkDiscussionCommentAsAnswerPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unmarkFileAsViewed`]!.nt = UnmarkFileAsViewedPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unmarkIssueAsDuplicate`]!.nt = UnmarkIssueAsDuplicatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unmarkProjectV2AsTemplate`]!.nt = UnmarkProjectV2AsTemplatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unminimizeComment`]!.nt = UnminimizeCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unpinIssue`]!.nt = UnpinIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`unresolveReviewThread`]!.nt = UnresolveReviewThreadPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateBranchProtectionRule`]!.nt = UpdateBranchProtectionRulePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateCheckRun`]!.nt = UpdateCheckRunPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateCheckSuitePreferences`]!.nt = UpdateCheckSuitePreferencesPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateDiscussion`]!.nt = UpdateDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateDiscussionComment`]!.nt = UpdateDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseAdministratorRole`]!.nt = UpdateEnterpriseAdministratorRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseAllowPrivateRepositoryForkingSetting`]!.nt =
  UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseDefaultRepositoryPermissionSetting`]!.nt =
  UpdateEnterpriseDefaultRepositoryPermissionSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseDeployKeySetting`]!.nt = UpdateEnterpriseDeployKeySettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanChangeRepositoryVisibilitySetting`]!.nt =
  UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanCreateRepositoriesSetting`]!.nt =
  UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanDeleteIssuesSetting`]!.nt = UpdateEnterpriseMembersCanDeleteIssuesSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanDeleteRepositoriesSetting`]!.nt =
  UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanInviteCollaboratorsSetting`]!.nt =
  UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanMakePurchasesSetting`]!.nt = UpdateEnterpriseMembersCanMakePurchasesSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanUpdateProtectedBranchesSetting`]!.nt =
  UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseMembersCanViewDependencyInsightsSetting`]!.nt =
  UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseOrganizationProjectsSetting`]!.nt = UpdateEnterpriseOrganizationProjectsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseOwnerOrganizationRole`]!.nt = UpdateEnterpriseOwnerOrganizationRolePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseProfile`]!.nt = UpdateEnterpriseProfilePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseRepositoryProjectsSetting`]!.nt = UpdateEnterpriseRepositoryProjectsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseTeamDiscussionsSetting`]!.nt = UpdateEnterpriseTeamDiscussionsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseTwoFactorAuthenticationDisallowedMethodsSetting`]!.nt =
  UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnterpriseTwoFactorAuthenticationRequiredSetting`]!.nt =
  UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateEnvironment`]!.nt = UpdateEnvironmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateIpAllowListEnabledSetting`]!.nt = UpdateIpAllowListEnabledSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateIpAllowListEntry`]!.nt = UpdateIpAllowListEntryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateIpAllowListForInstalledAppsEnabledSetting`]!.nt =
  UpdateIpAllowListForInstalledAppsEnabledSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateIssue`]!.nt = UpdateIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateIssueComment`]!.nt = UpdateIssueCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateLabel`]!.nt = UpdateLabelPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateNotificationRestrictionSetting`]!.nt = UpdateNotificationRestrictionSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateOrganizationAllowPrivateRepositoryForkingSetting`]!.nt =
  UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateOrganizationWebCommitSignoffSetting`]!.nt = UpdateOrganizationWebCommitSignoffSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updatePatreonSponsorability`]!.nt = UpdatePatreonSponsorabilityPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProject`]!.nt = UpdateProjectPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectCard`]!.nt = UpdateProjectCardPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectColumn`]!.nt = UpdateProjectColumnPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2`]!.nt = UpdateProjectV2Payload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2Collaborators`]!.nt = UpdateProjectV2CollaboratorsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2DraftIssue`]!.nt = UpdateProjectV2DraftIssuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2Field`]!.nt = UpdateProjectV2FieldPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2ItemFieldValue`]!.nt = UpdateProjectV2ItemFieldValuePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2ItemPosition`]!.nt = UpdateProjectV2ItemPositionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateProjectV2StatusUpdate`]!.nt = UpdateProjectV2StatusUpdatePayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updatePullRequest`]!.nt = UpdatePullRequestPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updatePullRequestBranch`]!.nt = UpdatePullRequestBranchPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updatePullRequestReview`]!.nt = UpdatePullRequestReviewPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updatePullRequestReviewComment`]!.nt = UpdatePullRequestReviewCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateRef`]!.nt = UpdateRefPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateRefs`]!.nt = UpdateRefsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateRepository`]!.nt = UpdateRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateRepositoryRuleset`]!.nt = UpdateRepositoryRulesetPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateRepositoryWebCommitSignoffSetting`]!.nt = UpdateRepositoryWebCommitSignoffSettingPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateSponsorshipPreferences`]!.nt = UpdateSponsorshipPreferencesPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateSubscription`]!.nt = UpdateSubscriptionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateTeamDiscussion`]!.nt = UpdateTeamDiscussionPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateTeamDiscussionComment`]!.nt = UpdateTeamDiscussionCommentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateTeamReviewAssignment`]!.nt = UpdateTeamReviewAssignmentPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateTeamsRepository`]!.nt = UpdateTeamsRepositoryPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateTopics`]!.nt = UpdateTopicsPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateUserList`]!.nt = UpdateUserListPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`updateUserListsForItem`]!.nt = UpdateUserListsForItemPayload
// @ts-expect-error Assignment to readonly property is needed for circular reference handling.
Mutation.f[`verifyVerifiableDomain`]!.nt = VerifyVerifiableDomainPayload

//
//
//
//
//
//
// ==================================================================================================
//                                               Index
// ==================================================================================================
//
//
//
//
//
//

const $schemaDrivenDataMap: $$Utilities.SchemaDrivenDataMap = {
  operations: {
    query: Query,
    mutation: Mutation,
  },
  directives: {},
  types: {
    String,
    ID,
    Boolean,
    Int,
    Float,
    Base64String,
    BigInt,
    Date,
    DateTime,
    GitObjectID,
    GitRefname,
    GitSSHRemote,
    GitTimestamp,
    HTML,
    PreciseDateTime,
    URI,
    X509Certificate,
    ActorType,
    AuditLogOrderField,
    CheckAnnotationLevel,
    CheckConclusionState,
    CheckRunState,
    CheckRunType,
    CheckStatusState,
    CollaboratorAffiliation,
    CommentAuthorAssociation,
    CommentCannotUpdateReason,
    CommitContributionOrderField,
    ComparisonStatus,
    ContributionLevel,
    DefaultRepositoryPermissionField,
    DependencyGraphEcosystem,
    DeploymentOrderField,
    DeploymentProtectionRuleType,
    DeploymentReviewState,
    DeploymentState,
    DeploymentStatusState,
    DiffSide,
    DiscussionCloseReason,
    DiscussionOrderField,
    DiscussionPollOptionOrderField,
    DiscussionState,
    DiscussionStateReason,
    DismissReason,
    EnterpriseAdministratorInvitationOrderField,
    EnterpriseAdministratorRole,
    EnterpriseAllowPrivateRepositoryForkingPolicyValue,
    EnterpriseDefaultRepositoryPermissionSettingValue,
    EnterpriseDisallowedMethodsSettingValue,
    EnterpriseEnabledDisabledSettingValue,
    EnterpriseEnabledSettingValue,
    EnterpriseMemberInvitationOrderField,
    EnterpriseMemberOrderField,
    EnterpriseMembersCanCreateRepositoriesSettingValue,
    EnterpriseMembersCanMakePurchasesSettingValue,
    EnterpriseMembershipType,
    EnterpriseOrderField,
    EnterpriseServerInstallationOrderField,
    EnterpriseServerUserAccountEmailOrderField,
    EnterpriseServerUserAccountOrderField,
    EnterpriseServerUserAccountsUploadOrderField,
    EnterpriseServerUserAccountsUploadSyncState,
    EnterpriseUserAccountMembershipRole,
    EnterpriseUserDeployment,
    EnvironmentOrderField,
    EnvironmentPinnedFilterField,
    FileViewedState,
    FundingPlatform,
    GistOrderField,
    GistPrivacy,
    GitSignatureState,
    IdentityProviderConfigurationState,
    IpAllowListEnabledSettingValue,
    IpAllowListEntryOrderField,
    IpAllowListForInstalledAppsEnabledSettingValue,
    IssueClosedStateReason,
    IssueCommentOrderField,
    IssueOrderField,
    IssueState,
    IssueStateReason,
    IssueTimelineItemsItemType,
    LabelOrderField,
    LanguageOrderField,
    LockReason,
    MannequinOrderField,
    MergeCommitMessage,
    MergeCommitTitle,
    MergeQueueEntryState,
    MergeQueueGroupingStrategy,
    MergeQueueMergeMethod,
    MergeQueueMergingStrategy,
    MergeStateStatus,
    MergeableState,
    MigrationSourceType,
    MigrationState,
    MilestoneOrderField,
    MilestoneState,
    NotificationRestrictionSettingValue,
    OIDCProviderType,
    OauthApplicationCreateAuditEntryState,
    OperationType,
    OrderDirection,
    OrgAddMemberAuditEntryPermission,
    OrgCreateAuditEntryBillingPlan,
    OrgEnterpriseOwnerOrderField,
    OrgRemoveBillingManagerAuditEntryReason,
    OrgRemoveMemberAuditEntryMembershipType,
    OrgRemoveMemberAuditEntryReason,
    OrgRemoveOutsideCollaboratorAuditEntryMembershipType,
    OrgRemoveOutsideCollaboratorAuditEntryReason,
    OrgUpdateDefaultRepositoryPermissionAuditEntryPermission,
    OrgUpdateMemberAuditEntryPermission,
    OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility,
    OrganizationInvitationRole,
    OrganizationInvitationSource,
    OrganizationInvitationType,
    OrganizationMemberRole,
    OrganizationMembersCanCreateRepositoriesSettingValue,
    OrganizationMigrationState,
    OrganizationOrderField,
    PackageFileOrderField,
    PackageOrderField,
    PackageType,
    PackageVersionOrderField,
    PatchStatus,
    PinnableItemType,
    PinnedDiscussionGradient,
    PinnedDiscussionPattern,
    PinnedEnvironmentOrderField,
    ProjectCardArchivedState,
    ProjectCardState,
    ProjectColumnPurpose,
    ProjectOrderField,
    ProjectState,
    ProjectTemplate,
    ProjectV2CustomFieldType,
    ProjectV2FieldOrderField,
    ProjectV2FieldType,
    ProjectV2ItemFieldValueOrderField,
    ProjectV2ItemOrderField,
    ProjectV2ItemType,
    ProjectV2OrderField,
    ProjectV2PermissionLevel,
    ProjectV2Roles,
    ProjectV2SingleSelectFieldOptionColor,
    ProjectV2State,
    ProjectV2StatusUpdateOrderField,
    ProjectV2StatusUpdateStatus,
    ProjectV2ViewLayout,
    ProjectV2ViewOrderField,
    ProjectV2WorkflowsOrderField,
    PullRequestBranchUpdateMethod,
    PullRequestMergeMethod,
    PullRequestOrderField,
    PullRequestReviewCommentState,
    PullRequestReviewDecision,
    PullRequestReviewEvent,
    PullRequestReviewState,
    PullRequestReviewThreadSubjectType,
    PullRequestState,
    PullRequestTimelineItemsItemType,
    PullRequestUpdateState,
    ReactionContent,
    ReactionOrderField,
    RefOrderField,
    ReleaseOrderField,
    RepoAccessAuditEntryVisibility,
    RepoAddMemberAuditEntryVisibility,
    RepoArchivedAuditEntryVisibility,
    RepoChangeMergeSettingAuditEntryMergeType,
    RepoCreateAuditEntryVisibility,
    RepoDestroyAuditEntryVisibility,
    RepoRemoveMemberAuditEntryVisibility,
    ReportedContentClassifiers,
    RepositoryAffiliation,
    RepositoryContributionType,
    RepositoryInteractionLimit,
    RepositoryInteractionLimitExpiry,
    RepositoryInteractionLimitOrigin,
    RepositoryInvitationOrderField,
    RepositoryLockReason,
    RepositoryMigrationOrderDirection,
    RepositoryMigrationOrderField,
    RepositoryOrderField,
    RepositoryPermission,
    RepositoryPrivacy,
    RepositoryRuleOrderField,
    RepositoryRuleType,
    RepositoryRulesetBypassActorBypassMode,
    RepositoryRulesetTarget,
    RepositoryVisibility,
    RepositoryVulnerabilityAlertDependencyScope,
    RepositoryVulnerabilityAlertState,
    RequestableCheckStatusState,
    RoleInOrganization,
    RuleEnforcement,
    SamlDigestAlgorithm,
    SamlSignatureAlgorithm,
    SavedReplyOrderField,
    SearchType,
    SecurityAdvisoryClassification,
    SecurityAdvisoryEcosystem,
    SecurityAdvisoryIdentifierType,
    SecurityAdvisoryOrderField,
    SecurityAdvisorySeverity,
    SecurityVulnerabilityOrderField,
    SocialAccountProvider,
    SponsorAndLifetimeValueOrderField,
    SponsorOrderField,
    SponsorableOrderField,
    SponsorsActivityAction,
    SponsorsActivityOrderField,
    SponsorsActivityPeriod,
    SponsorsCountryOrRegionCode,
    SponsorsGoalKind,
    SponsorsListingFeaturedItemFeatureableType,
    SponsorsTierOrderField,
    SponsorshipNewsletterOrderField,
    SponsorshipOrderField,
    SponsorshipPaymentSource,
    SponsorshipPrivacy,
    SquashMergeCommitMessage,
    SquashMergeCommitTitle,
    StarOrderField,
    StatusState,
    SubscriptionState,
    TeamDiscussionCommentOrderField,
    TeamDiscussionOrderField,
    TeamMemberOrderField,
    TeamMemberRole,
    TeamMembershipType,
    TeamNotificationSetting,
    TeamOrderField,
    TeamPrivacy,
    TeamRepositoryOrderField,
    TeamReviewAssignmentAlgorithm,
    TeamRole,
    ThreadSubscriptionFormAction,
    ThreadSubscriptionState,
    TopicSuggestionDeclineReason,
    TrackedIssueStates,
    TwoFactorCredentialSecurityType,
    UserBlockDuration,
    UserStatusOrderField,
    UserViewType,
    VerifiableDomainOrderField,
    WorkflowRunOrderField,
    WorkflowState,
    AbortQueuedMigrationsInput,
    AbortRepositoryMigrationInput,
    AcceptEnterpriseAdministratorInvitationInput,
    AcceptEnterpriseMemberInvitationInput,
    AcceptTopicSuggestionInput,
    AccessUserNamespaceRepositoryInput,
    AddAssigneesToAssignableInput,
    AddCommentInput,
    AddDiscussionCommentInput,
    AddDiscussionPollVoteInput,
    AddEnterpriseOrganizationMemberInput,
    AddEnterpriseSupportEntitlementInput,
    AddLabelsToLabelableInput,
    AddProjectCardInput,
    AddProjectColumnInput,
    AddProjectV2DraftIssueInput,
    AddProjectV2ItemByIdInput,
    AddPullRequestReviewCommentInput,
    AddPullRequestReviewInput,
    AddPullRequestReviewThreadInput,
    AddPullRequestReviewThreadReplyInput,
    AddReactionInput,
    AddStarInput,
    AddSubIssueInput,
    AddUpvoteInput,
    AddVerifiableDomainInput,
    ApproveDeploymentsInput,
    ApproveVerifiableDomainInput,
    ArchiveProjectV2ItemInput,
    ArchiveRepositoryInput,
    AuditLogOrder,
    BranchNamePatternParametersInput,
    BulkSponsorship,
    CancelEnterpriseAdminInvitationInput,
    CancelEnterpriseMemberInvitationInput,
    CancelSponsorshipInput,
    ChangeUserStatusInput,
    CheckAnnotationData,
    CheckAnnotationRange,
    CheckRunAction,
    CheckRunFilter,
    CheckRunOutput,
    CheckRunOutputImage,
    CheckSuiteAutoTriggerPreference,
    CheckSuiteFilter,
    ClearLabelsFromLabelableInput,
    ClearProjectV2ItemFieldValueInput,
    CloneProjectInput,
    CloneTemplateRepositoryInput,
    CloseDiscussionInput,
    CloseIssueInput,
    ClosePullRequestInput,
    CodeScanningParametersInput,
    CodeScanningToolInput,
    CommitAuthor,
    CommitAuthorEmailPatternParametersInput,
    CommitContributionOrder,
    CommitMessage,
    CommitMessagePatternParametersInput,
    CommittableBranch,
    CommitterEmailPatternParametersInput,
    ContributionOrder,
    ConvertProjectCardNoteToIssueInput,
    ConvertProjectV2DraftIssueItemToIssueInput,
    ConvertPullRequestToDraftInput,
    CopyProjectV2Input,
    CreateAttributionInvitationInput,
    CreateBranchProtectionRuleInput,
    CreateCheckRunInput,
    CreateCheckSuiteInput,
    CreateCommitOnBranchInput,
    CreateDeploymentInput,
    CreateDeploymentStatusInput,
    CreateDiscussionInput,
    CreateEnterpriseOrganizationInput,
    CreateEnvironmentInput,
    CreateIpAllowListEntryInput,
    CreateIssueInput,
    CreateLabelInput,
    CreateLinkedBranchInput,
    CreateMigrationSourceInput,
    CreateProjectInput,
    CreateProjectV2FieldInput,
    CreateProjectV2Input,
    CreateProjectV2StatusUpdateInput,
    CreatePullRequestInput,
    CreateRefInput,
    CreateRepositoryInput,
    CreateRepositoryRulesetInput,
    CreateSponsorsListingInput,
    CreateSponsorsTierInput,
    CreateSponsorshipInput,
    CreateSponsorshipsInput,
    CreateTeamDiscussionCommentInput,
    CreateTeamDiscussionInput,
    CreateUserListInput,
    DeclineTopicSuggestionInput,
    DeleteBranchProtectionRuleInput,
    DeleteDeploymentInput,
    DeleteDiscussionCommentInput,
    DeleteDiscussionInput,
    DeleteEnvironmentInput,
    DeleteIpAllowListEntryInput,
    DeleteIssueCommentInput,
    DeleteIssueInput,
    DeleteLabelInput,
    DeleteLinkedBranchInput,
    DeletePackageVersionInput,
    DeleteProjectCardInput,
    DeleteProjectColumnInput,
    DeleteProjectInput,
    DeleteProjectV2FieldInput,
    DeleteProjectV2Input,
    DeleteProjectV2ItemInput,
    DeleteProjectV2StatusUpdateInput,
    DeleteProjectV2WorkflowInput,
    DeletePullRequestReviewCommentInput,
    DeletePullRequestReviewInput,
    DeleteRefInput,
    DeleteRepositoryRulesetInput,
    DeleteTeamDiscussionCommentInput,
    DeleteTeamDiscussionInput,
    DeleteUserListInput,
    DeleteVerifiableDomainInput,
    DeploymentOrder,
    DequeuePullRequestInput,
    DisablePullRequestAutoMergeInput,
    DiscussionOrder,
    DiscussionPollOptionOrder,
    DismissPullRequestReviewInput,
    DismissRepositoryVulnerabilityAlertInput,
    DraftPullRequestReviewComment,
    DraftPullRequestReviewThread,
    EnablePullRequestAutoMergeInput,
    EnqueuePullRequestInput,
    EnterpriseAdministratorInvitationOrder,
    EnterpriseMemberInvitationOrder,
    EnterpriseMemberOrder,
    EnterpriseOrder,
    EnterpriseServerInstallationOrder,
    EnterpriseServerUserAccountEmailOrder,
    EnterpriseServerUserAccountOrder,
    EnterpriseServerUserAccountsUploadOrder,
    Environments,
    FileAddition,
    FileChanges,
    FileDeletion,
    FileExtensionRestrictionParametersInput,
    FilePathRestrictionParametersInput,
    FollowOrganizationInput,
    FollowUserInput,
    GistOrder,
    GrantEnterpriseOrganizationsMigratorRoleInput,
    GrantMigratorRoleInput,
    ImportProjectInput,
    InviteEnterpriseAdminInput,
    InviteEnterpriseMemberInput,
    IpAllowListEntryOrder,
    IssueCommentOrder,
    IssueFilters,
    IssueOrder,
    LabelOrder,
    LanguageOrder,
    LinkProjectV2ToRepositoryInput,
    LinkProjectV2ToTeamInput,
    LinkRepositoryToProjectInput,
    LockLockableInput,
    MannequinOrder,
    MarkDiscussionCommentAsAnswerInput,
    MarkFileAsViewedInput,
    MarkProjectV2AsTemplateInput,
    MarkPullRequestReadyForReviewInput,
    MaxFilePathLengthParametersInput,
    MaxFileSizeParametersInput,
    MergeBranchInput,
    MergePullRequestInput,
    MergeQueueParametersInput,
    MilestoneOrder,
    MinimizeCommentInput,
    MoveProjectCardInput,
    MoveProjectColumnInput,
    OrgEnterpriseOwnerOrder,
    OrganizationOrder,
    PackageFileOrder,
    PackageOrder,
    PackageVersionOrder,
    PinEnvironmentInput,
    PinIssueInput,
    PinnedEnvironmentOrder,
    ProjectCardImport,
    ProjectColumnImport,
    ProjectOrder,
    ProjectV2Collaborator,
    ProjectV2FieldOrder,
    ProjectV2FieldValue,
    ProjectV2Filters,
    ProjectV2ItemFieldValueOrder,
    ProjectV2ItemOrder,
    ProjectV2Order,
    ProjectV2SingleSelectFieldOptionInput,
    ProjectV2StatusOrder,
    ProjectV2ViewOrder,
    ProjectV2WorkflowOrder,
    PropertyTargetDefinitionInput,
    PublishSponsorsTierInput,
    PullRequestOrder,
    PullRequestParametersInput,
    ReactionOrder,
    RefNameConditionTargetInput,
    RefOrder,
    RefUpdate,
    RegenerateEnterpriseIdentityProviderRecoveryCodesInput,
    RegenerateVerifiableDomainTokenInput,
    RejectDeploymentsInput,
    ReleaseOrder,
    RemoveAssigneesFromAssignableInput,
    RemoveEnterpriseAdminInput,
    RemoveEnterpriseIdentityProviderInput,
    RemoveEnterpriseMemberInput,
    RemoveEnterpriseOrganizationInput,
    RemoveEnterpriseSupportEntitlementInput,
    RemoveLabelsFromLabelableInput,
    RemoveOutsideCollaboratorInput,
    RemoveReactionInput,
    RemoveStarInput,
    RemoveSubIssueInput,
    RemoveUpvoteInput,
    ReopenDiscussionInput,
    ReopenIssueInput,
    ReopenPullRequestInput,
    ReorderEnvironmentInput,
    RepositoryIdConditionTargetInput,
    RepositoryInvitationOrder,
    RepositoryMigrationOrder,
    RepositoryNameConditionTargetInput,
    RepositoryOrder,
    RepositoryPropertyConditionTargetInput,
    RepositoryRuleConditionsInput,
    RepositoryRuleInput,
    RepositoryRuleOrder,
    RepositoryRulesetBypassActorInput,
    ReprioritizeSubIssueInput,
    RequestReviewsInput,
    RequiredDeploymentsParametersInput,
    RequiredStatusCheckInput,
    RequiredStatusChecksParametersInput,
    RerequestCheckSuiteInput,
    ResolveReviewThreadInput,
    RetireSponsorsTierInput,
    RevertPullRequestInput,
    RevokeEnterpriseOrganizationsMigratorRoleInput,
    RevokeMigratorRoleInput,
    RuleParametersInput,
    SavedReplyOrder,
    SecurityAdvisoryIdentifierFilter,
    SecurityAdvisoryOrder,
    SecurityVulnerabilityOrder,
    SetEnterpriseIdentityProviderInput,
    SetOrganizationInteractionLimitInput,
    SetRepositoryInteractionLimitInput,
    SetUserInteractionLimitInput,
    SponsorAndLifetimeValueOrder,
    SponsorOrder,
    SponsorableOrder,
    SponsorsActivityOrder,
    SponsorsTierOrder,
    SponsorshipNewsletterOrder,
    SponsorshipOrder,
    StarOrder,
    StartOrganizationMigrationInput,
    StartRepositoryMigrationInput,
    StatusCheckConfigurationInput,
    SubmitPullRequestReviewInput,
    TagNamePatternParametersInput,
    TeamDiscussionCommentOrder,
    TeamDiscussionOrder,
    TeamMemberOrder,
    TeamOrder,
    TeamRepositoryOrder,
    TransferEnterpriseOrganizationInput,
    TransferIssueInput,
    UnarchiveProjectV2ItemInput,
    UnarchiveRepositoryInput,
    UnfollowOrganizationInput,
    UnfollowUserInput,
    UnlinkProjectV2FromRepositoryInput,
    UnlinkProjectV2FromTeamInput,
    UnlinkRepositoryFromProjectInput,
    UnlockLockableInput,
    UnmarkDiscussionCommentAsAnswerInput,
    UnmarkFileAsViewedInput,
    UnmarkIssueAsDuplicateInput,
    UnmarkProjectV2AsTemplateInput,
    UnminimizeCommentInput,
    UnpinIssueInput,
    UnresolveReviewThreadInput,
    UpdateBranchProtectionRuleInput,
    UpdateCheckRunInput,
    UpdateCheckSuitePreferencesInput,
    UpdateDiscussionCommentInput,
    UpdateDiscussionInput,
    UpdateEnterpriseAdministratorRoleInput,
    UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput,
    UpdateEnterpriseDefaultRepositoryPermissionSettingInput,
    UpdateEnterpriseDeployKeySettingInput,
    UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput,
    UpdateEnterpriseMembersCanCreateRepositoriesSettingInput,
    UpdateEnterpriseMembersCanDeleteIssuesSettingInput,
    UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput,
    UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput,
    UpdateEnterpriseMembersCanMakePurchasesSettingInput,
    UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput,
    UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput,
    UpdateEnterpriseOrganizationProjectsSettingInput,
    UpdateEnterpriseOwnerOrganizationRoleInput,
    UpdateEnterpriseProfileInput,
    UpdateEnterpriseRepositoryProjectsSettingInput,
    UpdateEnterpriseTeamDiscussionsSettingInput,
    UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput,
    UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput,
    UpdateEnvironmentInput,
    UpdateIpAllowListEnabledSettingInput,
    UpdateIpAllowListEntryInput,
    UpdateIpAllowListForInstalledAppsEnabledSettingInput,
    UpdateIssueCommentInput,
    UpdateIssueInput,
    UpdateLabelInput,
    UpdateNotificationRestrictionSettingInput,
    UpdateOrganizationAllowPrivateRepositoryForkingSettingInput,
    UpdateOrganizationWebCommitSignoffSettingInput,
    UpdateParametersInput,
    UpdatePatreonSponsorabilityInput,
    UpdateProjectCardInput,
    UpdateProjectColumnInput,
    UpdateProjectInput,
    UpdateProjectV2CollaboratorsInput,
    UpdateProjectV2DraftIssueInput,
    UpdateProjectV2FieldInput,
    UpdateProjectV2Input,
    UpdateProjectV2ItemFieldValueInput,
    UpdateProjectV2ItemPositionInput,
    UpdateProjectV2StatusUpdateInput,
    UpdatePullRequestBranchInput,
    UpdatePullRequestInput,
    UpdatePullRequestReviewCommentInput,
    UpdatePullRequestReviewInput,
    UpdateRefInput,
    UpdateRefsInput,
    UpdateRepositoryInput,
    UpdateRepositoryRulesetInput,
    UpdateRepositoryWebCommitSignoffSettingInput,
    UpdateSponsorshipPreferencesInput,
    UpdateSubscriptionInput,
    UpdateTeamDiscussionCommentInput,
    UpdateTeamDiscussionInput,
    UpdateTeamReviewAssignmentInput,
    UpdateTeamsRepositoryInput,
    UpdateTopicsInput,
    UpdateUserListInput,
    UpdateUserListsForItemInput,
    UserStatusOrder,
    VerifiableDomainOrder,
    VerifyVerifiableDomainInput,
    WorkflowFileReferenceInput,
    WorkflowRunOrder,
    WorkflowsParametersInput,
    AbortQueuedMigrationsPayload,
    AbortRepositoryMigrationPayload,
    AcceptEnterpriseAdministratorInvitationPayload,
    AcceptEnterpriseMemberInvitationPayload,
    AcceptTopicSuggestionPayload,
    AccessUserNamespaceRepositoryPayload,
    ActorLocation,
    AddAssigneesToAssignablePayload,
    AddCommentPayload,
    AddDiscussionCommentPayload,
    AddDiscussionPollVotePayload,
    AddEnterpriseOrganizationMemberPayload,
    AddEnterpriseSupportEntitlementPayload,
    AddLabelsToLabelablePayload,
    AddProjectCardPayload,
    AddProjectColumnPayload,
    AddProjectV2DraftIssuePayload,
    AddProjectV2ItemByIdPayload,
    AddPullRequestReviewCommentPayload,
    AddPullRequestReviewPayload,
    AddPullRequestReviewThreadPayload,
    AddPullRequestReviewThreadReplyPayload,
    AddReactionPayload,
    AddStarPayload,
    AddSubIssuePayload,
    AddUpvotePayload,
    AddVerifiableDomainPayload,
    AddedToMergeQueueEvent,
    AddedToProjectEvent,
    AnnouncementBanner,
    App,
    ApproveDeploymentsPayload,
    ApproveVerifiableDomainPayload,
    ArchiveProjectV2ItemPayload,
    ArchiveRepositoryPayload,
    AssignedEvent,
    AutoMergeDisabledEvent,
    AutoMergeEnabledEvent,
    AutoMergeRequest,
    AutoRebaseEnabledEvent,
    AutoSquashEnabledEvent,
    AutomaticBaseChangeFailedEvent,
    AutomaticBaseChangeSucceededEvent,
    BaseRefChangedEvent,
    BaseRefDeletedEvent,
    BaseRefForcePushedEvent,
    Blame,
    BlameRange,
    Blob,
    Bot,
    BranchNamePatternParameters,
    BranchProtectionRule,
    BranchProtectionRuleConflict,
    BranchProtectionRuleConflictConnection,
    BranchProtectionRuleConflictEdge,
    BranchProtectionRuleConnection,
    BranchProtectionRuleEdge,
    BypassForcePushAllowance,
    BypassForcePushAllowanceConnection,
    BypassForcePushAllowanceEdge,
    BypassPullRequestAllowance,
    BypassPullRequestAllowanceConnection,
    BypassPullRequestAllowanceEdge,
    CVSS,
    CWE,
    CWEConnection,
    CWEEdge,
    CancelEnterpriseAdminInvitationPayload,
    CancelEnterpriseMemberInvitationPayload,
    CancelSponsorshipPayload,
    ChangeUserStatusPayload,
    CheckAnnotation,
    CheckAnnotationConnection,
    CheckAnnotationEdge,
    CheckAnnotationPosition,
    CheckAnnotationSpan,
    CheckRun,
    CheckRunConnection,
    CheckRunEdge,
    CheckRunStateCount,
    CheckStep,
    CheckStepConnection,
    CheckStepEdge,
    CheckSuite,
    CheckSuiteConnection,
    CheckSuiteEdge,
    ClearLabelsFromLabelablePayload,
    ClearProjectV2ItemFieldValuePayload,
    CloneProjectPayload,
    CloneTemplateRepositoryPayload,
    CloseDiscussionPayload,
    CloseIssuePayload,
    ClosePullRequestPayload,
    ClosedEvent,
    CodeOfConduct,
    CodeScanningParameters,
    CodeScanningTool,
    CommentDeletedEvent,
    Commit,
    CommitAuthorEmailPatternParameters,
    CommitComment,
    CommitCommentConnection,
    CommitCommentEdge,
    CommitCommentThread,
    CommitConnection,
    CommitContributionsByRepository,
    CommitEdge,
    CommitHistoryConnection,
    CommitMessagePatternParameters,
    CommitterEmailPatternParameters,
    Comparison,
    ComparisonCommitConnection,
    ConnectedEvent,
    ContributingGuidelines,
    ContributionCalendar,
    ContributionCalendarDay,
    ContributionCalendarMonth,
    ContributionCalendarWeek,
    ContributionsCollection,
    ConvertProjectCardNoteToIssuePayload,
    ConvertProjectV2DraftIssueItemToIssuePayload,
    ConvertPullRequestToDraftPayload,
    ConvertToDraftEvent,
    ConvertedNoteToIssueEvent,
    ConvertedToDiscussionEvent,
    CopilotEndpoints,
    CopyProjectV2Payload,
    CreateAttributionInvitationPayload,
    CreateBranchProtectionRulePayload,
    CreateCheckRunPayload,
    CreateCheckSuitePayload,
    CreateCommitOnBranchPayload,
    CreateDeploymentPayload,
    CreateDeploymentStatusPayload,
    CreateDiscussionPayload,
    CreateEnterpriseOrganizationPayload,
    CreateEnvironmentPayload,
    CreateIpAllowListEntryPayload,
    CreateIssuePayload,
    CreateLabelPayload,
    CreateLinkedBranchPayload,
    CreateMigrationSourcePayload,
    CreateProjectPayload,
    CreateProjectV2FieldPayload,
    CreateProjectV2Payload,
    CreateProjectV2StatusUpdatePayload,
    CreatePullRequestPayload,
    CreateRefPayload,
    CreateRepositoryPayload,
    CreateRepositoryRulesetPayload,
    CreateSponsorsListingPayload,
    CreateSponsorsTierPayload,
    CreateSponsorshipPayload,
    CreateSponsorshipsPayload,
    CreateTeamDiscussionCommentPayload,
    CreateTeamDiscussionPayload,
    CreateUserListPayload,
    CreatedCommitContribution,
    CreatedCommitContributionConnection,
    CreatedCommitContributionEdge,
    CreatedIssueContribution,
    CreatedIssueContributionConnection,
    CreatedIssueContributionEdge,
    CreatedPullRequestContribution,
    CreatedPullRequestContributionConnection,
    CreatedPullRequestContributionEdge,
    CreatedPullRequestReviewContribution,
    CreatedPullRequestReviewContributionConnection,
    CreatedPullRequestReviewContributionEdge,
    CreatedRepositoryContribution,
    CreatedRepositoryContributionConnection,
    CreatedRepositoryContributionEdge,
    CrossReferencedEvent,
    CvssSeverities,
    DeclineTopicSuggestionPayload,
    DeleteBranchProtectionRulePayload,
    DeleteDeploymentPayload,
    DeleteDiscussionCommentPayload,
    DeleteDiscussionPayload,
    DeleteEnvironmentPayload,
    DeleteIpAllowListEntryPayload,
    DeleteIssueCommentPayload,
    DeleteIssuePayload,
    DeleteLabelPayload,
    DeleteLinkedBranchPayload,
    DeletePackageVersionPayload,
    DeleteProjectCardPayload,
    DeleteProjectColumnPayload,
    DeleteProjectPayload,
    DeleteProjectV2FieldPayload,
    DeleteProjectV2ItemPayload,
    DeleteProjectV2Payload,
    DeleteProjectV2StatusUpdatePayload,
    DeleteProjectV2WorkflowPayload,
    DeletePullRequestReviewCommentPayload,
    DeletePullRequestReviewPayload,
    DeleteRefPayload,
    DeleteRepositoryRulesetPayload,
    DeleteTeamDiscussionCommentPayload,
    DeleteTeamDiscussionPayload,
    DeleteUserListPayload,
    DeleteVerifiableDomainPayload,
    DemilestonedEvent,
    DependabotUpdate,
    DependabotUpdateError,
    DependencyGraphDependency,
    DependencyGraphDependencyConnection,
    DependencyGraphDependencyEdge,
    DependencyGraphManifest,
    DependencyGraphManifestConnection,
    DependencyGraphManifestEdge,
    DeployKey,
    DeployKeyConnection,
    DeployKeyEdge,
    DeployedEvent,
    Deployment,
    DeploymentConnection,
    DeploymentEdge,
    DeploymentEnvironmentChangedEvent,
    DeploymentProtectionRule,
    DeploymentProtectionRuleConnection,
    DeploymentProtectionRuleEdge,
    DeploymentRequest,
    DeploymentRequestConnection,
    DeploymentRequestEdge,
    DeploymentReview,
    DeploymentReviewConnection,
    DeploymentReviewEdge,
    DeploymentReviewerConnection,
    DeploymentReviewerEdge,
    DeploymentStatus,
    DeploymentStatusConnection,
    DeploymentStatusEdge,
    DequeuePullRequestPayload,
    DisablePullRequestAutoMergePayload,
    DisconnectedEvent,
    Discussion,
    DiscussionCategory,
    DiscussionCategoryConnection,
    DiscussionCategoryEdge,
    DiscussionComment,
    DiscussionCommentConnection,
    DiscussionCommentEdge,
    DiscussionConnection,
    DiscussionEdge,
    DiscussionPoll,
    DiscussionPollOption,
    DiscussionPollOptionConnection,
    DiscussionPollOptionEdge,
    DismissPullRequestReviewPayload,
    DismissRepositoryVulnerabilityAlertPayload,
    DraftIssue,
    EPSS,
    EnablePullRequestAutoMergePayload,
    EnqueuePullRequestPayload,
    Enterprise,
    EnterpriseAdministratorConnection,
    EnterpriseAdministratorEdge,
    EnterpriseAdministratorInvitation,
    EnterpriseAdministratorInvitationConnection,
    EnterpriseAdministratorInvitationEdge,
    EnterpriseBillingInfo,
    EnterpriseConnection,
    EnterpriseEdge,
    EnterpriseFailedInvitationConnection,
    EnterpriseFailedInvitationEdge,
    EnterpriseIdentityProvider,
    EnterpriseMemberConnection,
    EnterpriseMemberEdge,
    EnterpriseMemberInvitation,
    EnterpriseMemberInvitationConnection,
    EnterpriseMemberInvitationEdge,
    EnterpriseOrganizationMembershipConnection,
    EnterpriseOrganizationMembershipEdge,
    EnterpriseOutsideCollaboratorConnection,
    EnterpriseOutsideCollaboratorEdge,
    EnterpriseOwnerInfo,
    EnterprisePendingMemberInvitationConnection,
    EnterprisePendingMemberInvitationEdge,
    EnterpriseRepositoryInfo,
    EnterpriseRepositoryInfoConnection,
    EnterpriseRepositoryInfoEdge,
    EnterpriseServerInstallation,
    EnterpriseServerInstallationConnection,
    EnterpriseServerInstallationEdge,
    EnterpriseServerInstallationMembershipConnection,
    EnterpriseServerInstallationMembershipEdge,
    EnterpriseServerUserAccount,
    EnterpriseServerUserAccountConnection,
    EnterpriseServerUserAccountEdge,
    EnterpriseServerUserAccountEmail,
    EnterpriseServerUserAccountEmailConnection,
    EnterpriseServerUserAccountEmailEdge,
    EnterpriseServerUserAccountsUpload,
    EnterpriseServerUserAccountsUploadConnection,
    EnterpriseServerUserAccountsUploadEdge,
    EnterpriseUserAccount,
    Environment,
    EnvironmentConnection,
    EnvironmentEdge,
    ExternalIdentity,
    ExternalIdentityAttribute,
    ExternalIdentityConnection,
    ExternalIdentityEdge,
    ExternalIdentitySamlAttributes,
    ExternalIdentityScimAttributes,
    FileExtensionRestrictionParameters,
    FilePathRestrictionParameters,
    FollowOrganizationPayload,
    FollowUserPayload,
    FollowerConnection,
    FollowingConnection,
    FundingLink,
    GenericHovercardContext,
    Gist,
    GistComment,
    GistCommentConnection,
    GistCommentEdge,
    GistConnection,
    GistEdge,
    GistFile,
    GitActor,
    GitActorConnection,
    GitActorEdge,
    GitHubMetadata,
    GpgSignature,
    GrantEnterpriseOrganizationsMigratorRolePayload,
    GrantMigratorRolePayload,
    HeadRefDeletedEvent,
    HeadRefForcePushedEvent,
    HeadRefRestoredEvent,
    Hovercard,
    ImportProjectPayload,
    InviteEnterpriseAdminPayload,
    InviteEnterpriseMemberPayload,
    IpAllowListEntry,
    IpAllowListEntryConnection,
    IpAllowListEntryEdge,
    Issue,
    IssueComment,
    IssueCommentConnection,
    IssueCommentEdge,
    IssueConnection,
    IssueContributionsByRepository,
    IssueEdge,
    IssueTemplate,
    IssueTimelineConnection,
    IssueTimelineItemEdge,
    IssueTimelineItemsConnection,
    IssueTimelineItemsEdge,
    JoinedGitHubContribution,
    Label,
    LabelConnection,
    LabelEdge,
    LabeledEvent,
    Language,
    LanguageConnection,
    LanguageEdge,
    License,
    LicenseRule,
    LinkProjectV2ToRepositoryPayload,
    LinkProjectV2ToTeamPayload,
    LinkRepositoryToProjectPayload,
    LinkedBranch,
    LinkedBranchConnection,
    LinkedBranchEdge,
    LockLockablePayload,
    LockedEvent,
    Mannequin,
    MannequinConnection,
    MannequinEdge,
    MarkDiscussionCommentAsAnswerPayload,
    MarkFileAsViewedPayload,
    MarkProjectV2AsTemplatePayload,
    MarkPullRequestReadyForReviewPayload,
    MarkedAsDuplicateEvent,
    MarketplaceCategory,
    MarketplaceListing,
    MarketplaceListingConnection,
    MarketplaceListingEdge,
    MaxFilePathLengthParameters,
    MaxFileSizeParameters,
    MemberFeatureRequestNotification,
    MembersCanDeleteReposClearAuditEntry,
    MembersCanDeleteReposDisableAuditEntry,
    MembersCanDeleteReposEnableAuditEntry,
    MentionedEvent,
    MergeBranchPayload,
    MergePullRequestPayload,
    MergeQueue,
    MergeQueueConfiguration,
    MergeQueueEntry,
    MergeQueueEntryConnection,
    MergeQueueEntryEdge,
    MergeQueueParameters,
    MergedEvent,
    MigrationSource,
    Milestone,
    MilestoneConnection,
    MilestoneEdge,
    MilestonedEvent,
    MinimizeCommentPayload,
    MoveProjectCardPayload,
    MoveProjectColumnPayload,
    MovedColumnsInProjectEvent,
    OIDCProvider,
    OauthApplicationCreateAuditEntry,
    OrgAddBillingManagerAuditEntry,
    OrgAddMemberAuditEntry,
    OrgBlockUserAuditEntry,
    OrgConfigDisableCollaboratorsOnlyAuditEntry,
    OrgConfigEnableCollaboratorsOnlyAuditEntry,
    OrgCreateAuditEntry,
    OrgDisableOauthAppRestrictionsAuditEntry,
    OrgDisableSamlAuditEntry,
    OrgDisableTwoFactorRequirementAuditEntry,
    OrgEnableOauthAppRestrictionsAuditEntry,
    OrgEnableSamlAuditEntry,
    OrgEnableTwoFactorRequirementAuditEntry,
    OrgInviteMemberAuditEntry,
    OrgInviteToBusinessAuditEntry,
    OrgOauthAppAccessApprovedAuditEntry,
    OrgOauthAppAccessBlockedAuditEntry,
    OrgOauthAppAccessDeniedAuditEntry,
    OrgOauthAppAccessRequestedAuditEntry,
    OrgOauthAppAccessUnblockedAuditEntry,
    OrgRemoveBillingManagerAuditEntry,
    OrgRemoveMemberAuditEntry,
    OrgRemoveOutsideCollaboratorAuditEntry,
    OrgRestoreMemberAuditEntry,
    OrgRestoreMemberMembershipOrganizationAuditEntryData,
    OrgRestoreMemberMembershipRepositoryAuditEntryData,
    OrgRestoreMemberMembershipTeamAuditEntryData,
    OrgUnblockUserAuditEntry,
    OrgUpdateDefaultRepositoryPermissionAuditEntry,
    OrgUpdateMemberAuditEntry,
    OrgUpdateMemberRepositoryCreationPermissionAuditEntry,
    OrgUpdateMemberRepositoryInvitationPermissionAuditEntry,
    Organization,
    OrganizationAuditEntryConnection,
    OrganizationAuditEntryEdge,
    OrganizationConnection,
    OrganizationEdge,
    OrganizationEnterpriseOwnerConnection,
    OrganizationEnterpriseOwnerEdge,
    OrganizationIdentityProvider,
    OrganizationInvitation,
    OrganizationInvitationConnection,
    OrganizationInvitationEdge,
    OrganizationMemberConnection,
    OrganizationMemberEdge,
    OrganizationMigration,
    OrganizationTeamsHovercardContext,
    OrganizationsHovercardContext,
    Package,
    PackageConnection,
    PackageEdge,
    PackageFile,
    PackageFileConnection,
    PackageFileEdge,
    PackageStatistics,
    PackageTag,
    PackageVersion,
    PackageVersionConnection,
    PackageVersionEdge,
    PackageVersionStatistics,
    PageInfo,
    ParentIssueAddedEvent,
    ParentIssueRemovedEvent,
    PermissionSource,
    PinEnvironmentPayload,
    PinIssuePayload,
    PinnableItemConnection,
    PinnableItemEdge,
    PinnedDiscussion,
    PinnedDiscussionConnection,
    PinnedDiscussionEdge,
    PinnedEnvironment,
    PinnedEnvironmentConnection,
    PinnedEnvironmentEdge,
    PinnedEvent,
    PinnedIssue,
    PinnedIssueConnection,
    PinnedIssueEdge,
    PrivateRepositoryForkingDisableAuditEntry,
    PrivateRepositoryForkingEnableAuditEntry,
    ProfileItemShowcase,
    Project,
    ProjectCard,
    ProjectCardConnection,
    ProjectCardEdge,
    ProjectColumn,
    ProjectColumnConnection,
    ProjectColumnEdge,
    ProjectConnection,
    ProjectEdge,
    ProjectProgress,
    ProjectV2,
    ProjectV2ActorConnection,
    ProjectV2ActorEdge,
    ProjectV2Connection,
    ProjectV2Edge,
    ProjectV2Field,
    ProjectV2FieldConfigurationConnection,
    ProjectV2FieldConfigurationEdge,
    ProjectV2FieldConnection,
    ProjectV2FieldEdge,
    ProjectV2Item,
    ProjectV2ItemConnection,
    ProjectV2ItemEdge,
    ProjectV2ItemFieldDateValue,
    ProjectV2ItemFieldIterationValue,
    ProjectV2ItemFieldLabelValue,
    ProjectV2ItemFieldMilestoneValue,
    ProjectV2ItemFieldNumberValue,
    ProjectV2ItemFieldPullRequestValue,
    ProjectV2ItemFieldRepositoryValue,
    ProjectV2ItemFieldReviewerValue,
    ProjectV2ItemFieldSingleSelectValue,
    ProjectV2ItemFieldTextValue,
    ProjectV2ItemFieldUserValue,
    ProjectV2ItemFieldValueConnection,
    ProjectV2ItemFieldValueEdge,
    ProjectV2IterationField,
    ProjectV2IterationFieldConfiguration,
    ProjectV2IterationFieldIteration,
    ProjectV2SingleSelectField,
    ProjectV2SingleSelectFieldOption,
    ProjectV2SortBy,
    ProjectV2SortByConnection,
    ProjectV2SortByEdge,
    ProjectV2SortByField,
    ProjectV2SortByFieldConnection,
    ProjectV2SortByFieldEdge,
    ProjectV2StatusUpdate,
    ProjectV2StatusUpdateConnection,
    ProjectV2StatusUpdateEdge,
    ProjectV2View,
    ProjectV2ViewConnection,
    ProjectV2ViewEdge,
    ProjectV2Workflow,
    ProjectV2WorkflowConnection,
    ProjectV2WorkflowEdge,
    PropertyTargetDefinition,
    PublicKey,
    PublicKeyConnection,
    PublicKeyEdge,
    PublishSponsorsTierPayload,
    PullRequest,
    PullRequestChangedFile,
    PullRequestChangedFileConnection,
    PullRequestChangedFileEdge,
    PullRequestCommit,
    PullRequestCommitCommentThread,
    PullRequestCommitConnection,
    PullRequestCommitEdge,
    PullRequestConnection,
    PullRequestContributionsByRepository,
    PullRequestEdge,
    PullRequestParameters,
    PullRequestReview,
    PullRequestReviewComment,
    PullRequestReviewCommentConnection,
    PullRequestReviewCommentEdge,
    PullRequestReviewConnection,
    PullRequestReviewContributionsByRepository,
    PullRequestReviewEdge,
    PullRequestReviewThread,
    PullRequestReviewThreadConnection,
    PullRequestReviewThreadEdge,
    PullRequestRevisionMarker,
    PullRequestTemplate,
    PullRequestThread,
    PullRequestTimelineConnection,
    PullRequestTimelineItemEdge,
    PullRequestTimelineItemsConnection,
    PullRequestTimelineItemsEdge,
    Push,
    PushAllowance,
    PushAllowanceConnection,
    PushAllowanceEdge,
    RateLimit,
    ReactingUserConnection,
    ReactingUserEdge,
    Reaction,
    ReactionConnection,
    ReactionEdge,
    ReactionGroup,
    ReactorConnection,
    ReactorEdge,
    ReadyForReviewEvent,
    Ref,
    RefConnection,
    RefEdge,
    RefNameConditionTarget,
    RefUpdateRule,
    ReferencedEvent,
    RegenerateEnterpriseIdentityProviderRecoveryCodesPayload,
    RegenerateVerifiableDomainTokenPayload,
    RejectDeploymentsPayload,
    Release,
    ReleaseAsset,
    ReleaseAssetConnection,
    ReleaseAssetEdge,
    ReleaseConnection,
    ReleaseEdge,
    RemoveAssigneesFromAssignablePayload,
    RemoveEnterpriseAdminPayload,
    RemoveEnterpriseIdentityProviderPayload,
    RemoveEnterpriseMemberPayload,
    RemoveEnterpriseOrganizationPayload,
    RemoveEnterpriseSupportEntitlementPayload,
    RemoveLabelsFromLabelablePayload,
    RemoveOutsideCollaboratorPayload,
    RemoveReactionPayload,
    RemoveStarPayload,
    RemoveSubIssuePayload,
    RemoveUpvotePayload,
    RemovedFromMergeQueueEvent,
    RemovedFromProjectEvent,
    RenamedTitleEvent,
    ReopenDiscussionPayload,
    ReopenIssuePayload,
    ReopenPullRequestPayload,
    ReopenedEvent,
    ReorderEnvironmentPayload,
    RepoAccessAuditEntry,
    RepoAddMemberAuditEntry,
    RepoAddTopicAuditEntry,
    RepoArchivedAuditEntry,
    RepoChangeMergeSettingAuditEntry,
    RepoConfigDisableAnonymousGitAccessAuditEntry,
    RepoConfigDisableCollaboratorsOnlyAuditEntry,
    RepoConfigDisableContributorsOnlyAuditEntry,
    RepoConfigDisableSockpuppetDisallowedAuditEntry,
    RepoConfigEnableAnonymousGitAccessAuditEntry,
    RepoConfigEnableCollaboratorsOnlyAuditEntry,
    RepoConfigEnableContributorsOnlyAuditEntry,
    RepoConfigEnableSockpuppetDisallowedAuditEntry,
    RepoConfigLockAnonymousGitAccessAuditEntry,
    RepoConfigUnlockAnonymousGitAccessAuditEntry,
    RepoCreateAuditEntry,
    RepoDestroyAuditEntry,
    RepoRemoveMemberAuditEntry,
    RepoRemoveTopicAuditEntry,
    Repository,
    RepositoryCodeowners,
    RepositoryCodeownersError,
    RepositoryCollaboratorConnection,
    RepositoryCollaboratorEdge,
    RepositoryConnection,
    RepositoryContactLink,
    RepositoryEdge,
    RepositoryIdConditionTarget,
    RepositoryInteractionAbility,
    RepositoryInvitation,
    RepositoryInvitationConnection,
    RepositoryInvitationEdge,
    RepositoryMigration,
    RepositoryMigrationConnection,
    RepositoryMigrationEdge,
    RepositoryNameConditionTarget,
    RepositoryPlanFeatures,
    RepositoryPropertyConditionTarget,
    RepositoryRule,
    RepositoryRuleConditions,
    RepositoryRuleConnection,
    RepositoryRuleEdge,
    RepositoryRuleset,
    RepositoryRulesetBypassActor,
    RepositoryRulesetBypassActorConnection,
    RepositoryRulesetBypassActorEdge,
    RepositoryRulesetConnection,
    RepositoryRulesetEdge,
    RepositoryTopic,
    RepositoryTopicConnection,
    RepositoryTopicEdge,
    RepositoryVisibilityChangeDisableAuditEntry,
    RepositoryVisibilityChangeEnableAuditEntry,
    RepositoryVulnerabilityAlert,
    RepositoryVulnerabilityAlertConnection,
    RepositoryVulnerabilityAlertEdge,
    ReprioritizeSubIssuePayload,
    RequestReviewsPayload,
    RequestedReviewerConnection,
    RequestedReviewerEdge,
    RequiredDeploymentsParameters,
    RequiredStatusCheckDescription,
    RequiredStatusChecksParameters,
    RerequestCheckSuitePayload,
    ResolveReviewThreadPayload,
    RestrictedContribution,
    RetireSponsorsTierPayload,
    RevertPullRequestPayload,
    ReviewDismissalAllowance,
    ReviewDismissalAllowanceConnection,
    ReviewDismissalAllowanceEdge,
    ReviewDismissedEvent,
    ReviewRequest,
    ReviewRequestConnection,
    ReviewRequestEdge,
    ReviewRequestRemovedEvent,
    ReviewRequestedEvent,
    ReviewStatusHovercardContext,
    RevokeEnterpriseOrganizationsMigratorRolePayload,
    RevokeMigratorRolePayload,
    SavedReply,
    SavedReplyConnection,
    SavedReplyEdge,
    SearchResultItemConnection,
    SearchResultItemEdge,
    SecurityAdvisory,
    SecurityAdvisoryConnection,
    SecurityAdvisoryEdge,
    SecurityAdvisoryIdentifier,
    SecurityAdvisoryPackage,
    SecurityAdvisoryPackageVersion,
    SecurityAdvisoryReference,
    SecurityVulnerability,
    SecurityVulnerabilityConnection,
    SecurityVulnerabilityEdge,
    SetEnterpriseIdentityProviderPayload,
    SetOrganizationInteractionLimitPayload,
    SetRepositoryInteractionLimitPayload,
    SetUserInteractionLimitPayload,
    SmimeSignature,
    SocialAccount,
    SocialAccountConnection,
    SocialAccountEdge,
    SponsorAndLifetimeValue,
    SponsorAndLifetimeValueConnection,
    SponsorAndLifetimeValueEdge,
    SponsorConnection,
    SponsorEdge,
    SponsorableItemConnection,
    SponsorableItemEdge,
    SponsorsActivity,
    SponsorsActivityConnection,
    SponsorsActivityEdge,
    SponsorsGoal,
    SponsorsListing,
    SponsorsListingFeaturedItem,
    SponsorsTier,
    SponsorsTierAdminInfo,
    SponsorsTierConnection,
    SponsorsTierEdge,
    Sponsorship,
    SponsorshipConnection,
    SponsorshipEdge,
    SponsorshipNewsletter,
    SponsorshipNewsletterConnection,
    SponsorshipNewsletterEdge,
    SshSignature,
    StargazerConnection,
    StargazerEdge,
    StarredRepositoryConnection,
    StarredRepositoryEdge,
    StartOrganizationMigrationPayload,
    StartRepositoryMigrationPayload,
    Status,
    StatusCheckConfiguration,
    StatusCheckRollup,
    StatusCheckRollupContextConnection,
    StatusCheckRollupContextEdge,
    StatusContext,
    StatusContextStateCount,
    StripeConnectAccount,
    SubIssueAddedEvent,
    SubIssueRemovedEvent,
    SubIssuesSummary,
    SubmitPullRequestReviewPayload,
    Submodule,
    SubmoduleConnection,
    SubmoduleEdge,
    SubscribedEvent,
    SuggestedReviewer,
    Tag,
    TagNamePatternParameters,
    Team,
    TeamAddMemberAuditEntry,
    TeamAddRepositoryAuditEntry,
    TeamChangeParentTeamAuditEntry,
    TeamConnection,
    TeamDiscussion,
    TeamDiscussionComment,
    TeamDiscussionCommentConnection,
    TeamDiscussionCommentEdge,
    TeamDiscussionConnection,
    TeamDiscussionEdge,
    TeamEdge,
    TeamMemberConnection,
    TeamMemberEdge,
    TeamRemoveMemberAuditEntry,
    TeamRemoveRepositoryAuditEntry,
    TeamRepositoryConnection,
    TeamRepositoryEdge,
    TextMatch,
    TextMatchHighlight,
    Topic,
    TransferEnterpriseOrganizationPayload,
    TransferIssuePayload,
    TransferredEvent,
    Tree,
    TreeEntry,
    UnarchiveProjectV2ItemPayload,
    UnarchiveRepositoryPayload,
    UnassignedEvent,
    UnfollowOrganizationPayload,
    UnfollowUserPayload,
    UnknownSignature,
    UnlabeledEvent,
    UnlinkProjectV2FromRepositoryPayload,
    UnlinkProjectV2FromTeamPayload,
    UnlinkRepositoryFromProjectPayload,
    UnlockLockablePayload,
    UnlockedEvent,
    UnmarkDiscussionCommentAsAnswerPayload,
    UnmarkFileAsViewedPayload,
    UnmarkIssueAsDuplicatePayload,
    UnmarkProjectV2AsTemplatePayload,
    UnmarkedAsDuplicateEvent,
    UnminimizeCommentPayload,
    UnpinIssuePayload,
    UnpinnedEvent,
    UnresolveReviewThreadPayload,
    UnsubscribedEvent,
    UpdateBranchProtectionRulePayload,
    UpdateCheckRunPayload,
    UpdateCheckSuitePreferencesPayload,
    UpdateDiscussionCommentPayload,
    UpdateDiscussionPayload,
    UpdateEnterpriseAdministratorRolePayload,
    UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload,
    UpdateEnterpriseDefaultRepositoryPermissionSettingPayload,
    UpdateEnterpriseDeployKeySettingPayload,
    UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload,
    UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload,
    UpdateEnterpriseMembersCanDeleteIssuesSettingPayload,
    UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload,
    UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload,
    UpdateEnterpriseMembersCanMakePurchasesSettingPayload,
    UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload,
    UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload,
    UpdateEnterpriseOrganizationProjectsSettingPayload,
    UpdateEnterpriseOwnerOrganizationRolePayload,
    UpdateEnterpriseProfilePayload,
    UpdateEnterpriseRepositoryProjectsSettingPayload,
    UpdateEnterpriseTeamDiscussionsSettingPayload,
    UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingPayload,
    UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload,
    UpdateEnvironmentPayload,
    UpdateIpAllowListEnabledSettingPayload,
    UpdateIpAllowListEntryPayload,
    UpdateIpAllowListForInstalledAppsEnabledSettingPayload,
    UpdateIssueCommentPayload,
    UpdateIssuePayload,
    UpdateLabelPayload,
    UpdateNotificationRestrictionSettingPayload,
    UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload,
    UpdateOrganizationWebCommitSignoffSettingPayload,
    UpdateParameters,
    UpdatePatreonSponsorabilityPayload,
    UpdateProjectCardPayload,
    UpdateProjectColumnPayload,
    UpdateProjectPayload,
    UpdateProjectV2CollaboratorsPayload,
    UpdateProjectV2DraftIssuePayload,
    UpdateProjectV2FieldPayload,
    UpdateProjectV2ItemFieldValuePayload,
    UpdateProjectV2ItemPositionPayload,
    UpdateProjectV2Payload,
    UpdateProjectV2StatusUpdatePayload,
    UpdatePullRequestBranchPayload,
    UpdatePullRequestPayload,
    UpdatePullRequestReviewCommentPayload,
    UpdatePullRequestReviewPayload,
    UpdateRefPayload,
    UpdateRefsPayload,
    UpdateRepositoryPayload,
    UpdateRepositoryRulesetPayload,
    UpdateRepositoryWebCommitSignoffSettingPayload,
    UpdateSponsorshipPreferencesPayload,
    UpdateSubscriptionPayload,
    UpdateTeamDiscussionCommentPayload,
    UpdateTeamDiscussionPayload,
    UpdateTeamReviewAssignmentPayload,
    UpdateTeamsRepositoryPayload,
    UpdateTopicsPayload,
    UpdateUserListPayload,
    UpdateUserListsForItemPayload,
    User,
    UserBlockedEvent,
    UserConnection,
    UserContentEdit,
    UserContentEditConnection,
    UserContentEditEdge,
    UserEdge,
    UserEmailMetadata,
    UserList,
    UserListConnection,
    UserListEdge,
    UserListItemsConnection,
    UserListItemsEdge,
    UserListSuggestion,
    UserNamespaceRepository,
    UserNamespaceRepositoryConnection,
    UserNamespaceRepositoryEdge,
    UserStatus,
    UserStatusConnection,
    UserStatusEdge,
    VerifiableDomain,
    VerifiableDomainConnection,
    VerifiableDomainEdge,
    VerifyVerifiableDomainPayload,
    ViewerHovercardContext,
    Workflow,
    WorkflowFileReference,
    WorkflowRun,
    WorkflowRunConnection,
    WorkflowRunEdge,
    WorkflowRunFile,
    WorkflowsParameters,
    Actor,
    AnnouncementBannerI,
    Assignable,
    AuditEntry,
    Closable,
    Comment,
    Contribution,
    Deletable,
    EnterpriseAuditEntryData,
    GitObject,
    GitSignature,
    HovercardContext,
    Labelable,
    Lockable,
    MemberStatusable,
    Migration,
    Minimizable,
    Node,
    OauthApplicationAuditEntryData,
    OrganizationAuditEntryData,
    PackageOwner,
    ProfileOwner,
    ProjectOwner,
    ProjectV2FieldCommon,
    ProjectV2ItemFieldValueCommon,
    ProjectV2Owner,
    ProjectV2Recent,
    Reactable,
    RepositoryAuditEntryData,
    RepositoryDiscussionAuthor,
    RepositoryDiscussionCommentAuthor,
    RepositoryInfo,
    RepositoryNode,
    RepositoryOwner,
    RequirableByPullRequest,
    Sponsorable,
    Starrable,
    Subscribable,
    SubscribableThread,
    TeamAuditEntryData,
    TopicAuditEntryData,
    UniformResourceLocatable,
    Updatable,
    UpdatableComment,
    Votable,
    Assignee,
    AuditEntryActor,
    BranchActorAllowanceActor,
    BypassActor,
    Claimable,
    Closer,
    CreatedIssueOrRestrictedContribution,
    CreatedPullRequestOrRestrictedContribution,
    CreatedRepositoryOrRestrictedContribution,
    DeploymentReviewer,
    EnterpriseMember,
    IpAllowListOwner,
    IssueOrPullRequest,
    IssueTimelineItem,
    IssueTimelineItems,
    MilestoneItem,
    OrgRestoreMemberAuditEntryMembership,
    OrganizationAuditEntry,
    OrganizationOrUser,
    PermissionGranter,
    PinnableItem,
    ProjectCardItem,
    ProjectV2Actor,
    ProjectV2FieldConfiguration,
    ProjectV2ItemContent,
    ProjectV2ItemFieldValue,
    PullRequestTimelineItem,
    PullRequestTimelineItems,
    PushAllowanceActor,
    Reactor,
    ReferencedSubject,
    RenamedTitleSubject,
    RequestedReviewer,
    ReviewDismissalAllowanceActor,
    RuleParameters,
    RuleSource,
    SearchResultItem,
    Sponsor,
    SponsorableItem,
    SponsorsListingFeatureableItem,
    StatusCheckRollupContext,
    UserListItems,
    VerifiableDomainOwner,
    Query,
    Mutation,
  },
}

export { $schemaDrivenDataMap as schemaDrivenDataMap }
