/**
 * ====================================================================================
 * GENERATED FILE - DO NOT EDIT MANUALLY
 * ====================================================================================
 *
 * Generated by: Graffle Code Generator
 * Source: src/generator/generators/ArgumentsMap.ts
 *
 * @module ArgumentsMap
 *
 * ArgumentsMap is a type-level structure that mirrors your GraphQL schema's argument structure for type-safe variable inference.
 *
 * @description
 *
 * ArgumentsMap provides a complete type-level representation of all arguments in your GraphQL schema. It enables the Static Document Builder to infer variable types and requirements from your selection sets when you use `$var` placeholders.
 *
 * This module is generated from your GraphQL schema and creates TypeScript interfaces that encode:
 *
 * - Which fields accept arguments
 * - The types and nullability of those arguments
 * - Nested argument structures in complex queries
 * - Input object types used in arguments
 *
 * The ArgumentsMap works in conjunction with the variable inference system to provide compile-time validation of your GraphQL variables without requiring manual type annotations.
 *
 * @remarks
 *
 * ArgumentsMap follows the Schema-Driven Data Map (SDDM) pattern used throughout Graffle's generated code. This pattern uses specific property names with precise meanings:
 *
 * - `operations`: Root types (query, mutation, subscription) that can be directly queried
 * - `directives`: Directive definitions with their arguments
 * - `types`: All types in the schema that have fields with arguments
 * - `f`: Fields map - contains all fields for a given type
 * - `a`: Arguments - direct arguments on a specific field
 * - `ad`: Arguments descendant - reference to a type that has fields with arguments
 * - `nt`: Named type - the GraphQL type name as a string literal
 * - `it`: Inline type - tuple encoding nullability: `[0]` for nullable, `[1]` for required, `[0, [1]]` for list types
 * - `$t`: TypeScript type - the fully resolved TypeScript type for the argument
 *
 * The `ad` property is particularly important: it enables type traversal through fields that don't have direct arguments but return types that do have fields with arguments. This allows the type system to properly track argument requirements across nested selections.
 *
 * @example Basic Field Arguments
 *
 * A simple field with optional scalar arguments:
 *
 * ```typescript
 * export interface Query extends $$Utilities.SchemaDrivenDataMap.OutputObject {
 *   readonly f: {
 *     readonly userById: {
 *       readonly a: {
 *         readonly id: {
 *           readonly nt: 'ID'
 *           readonly it: readonly [0]
 *           readonly $t: string | undefined
 *         }
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @example Required Arguments
 *
 * A field with a required argument (non-null in GraphQL schema):
 *
 * ```typescript
 * readonly stringWithRequiredArg: {
 *   readonly a: {
 *     readonly string: {
 *       readonly nt: 'String'
 *       readonly it: readonly [1]
 *       readonly $t: string
 *     }
 *   }
 * }
 * ```
 *
 * @example List Arguments
 *
 * Arguments that accept arrays:
 *
 * ```typescript
 * readonly stringWithListArgRequired: {
 *   readonly a: {
 *     readonly ints: {
 *       readonly nt: 'Int'
 *       readonly it: readonly [1, [1]]
 *       readonly $t: readonly number[]
 *     }
 *   }
 * }
 * ```
 *
 * @example Nested Arguments with Descendant
 *
 * A field that doesn't have direct arguments but returns a type with fields that do:
 *
 * ```typescript
 * readonly objectNestedWithArgs: {
 *   readonly ad: ObjectNestedWithArgs
 * }
 * ```
 *
 * Where `ObjectNestedWithArgs` is defined elsewhere:
 *
 * ```typescript
 * export interface ObjectNestedWithArgs
 *   extends $$Utilities.SchemaDrivenDataMap.OutputObject
 * {
 *   readonly f: {
 *     readonly object: {
 *       readonly a: {
 *         readonly int: {
 *           readonly nt: 'Int'
 *           readonly it: readonly [0]
 *           readonly $t: number | undefined
 *         }
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @example Input Object Arguments
 *
 * Arguments that accept input objects:
 *
 * ```typescript
 * readonly stringWithArgInputObjectRequired: {
 *   readonly a: {
 *     readonly input: {
 *       readonly nt: 'InputObject'
 *       readonly it: readonly [1]
 *       readonly $t: TypeInputsIndex.InputObject
 *     }
 *   }
 * }
 * ```
 *
 * @see {@link https://graffle.js.org | Graffle Documentation}
 * @see {@link https://graffle.js.org/guides/document-builder | Static Document Builder Guide}
 */

import type * as $$Utilities from '#graffle/utilities-for-generated'
import type * as TypeInputsIndex from './type-inputs-index.js'

//
//
//
//
//
//
// ==================================================================================================
//                                            InputObject
// ==================================================================================================
//
//
//
//
//
//

export interface DateFilter extends $$Utilities.SchemaDrivenDataMap.InputObject {
  readonly n: 'DateFilter'
  readonly f: {
    readonly gte: {
      readonly nt: 'Date'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.Date | null | undefined
    }
    readonly lte: {
      readonly nt: 'Date'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.Date | null | undefined
    }
  }
}

export interface PokemonFilter extends $$Utilities.SchemaDrivenDataMap.InputObject {
  readonly n: 'PokemonFilter'
  readonly f: {
    readonly birthday: {
      readonly nt: 'DateFilter'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.DateFilter | null | undefined
    }
    readonly name: {
      readonly nt: 'StringFilter'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.StringFilter | null | undefined
    }
    readonly type: {
      readonly nt: 'PokemonType'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.PokemonType | null | undefined
    }
  }
}

export interface StringFilter extends $$Utilities.SchemaDrivenDataMap.InputObject {
  readonly n: 'StringFilter'
  readonly f: {
    readonly contains: {
      readonly nt: 'String'
      readonly it: readonly [0]
      readonly $t: TypeInputsIndex.String | null | undefined
    }
    readonly in: {
      readonly nt: 'String'
      readonly it: readonly [0, [1]]
      readonly $t: readonly TypeInputsIndex.String[] | null | undefined
    }
  }
}

//
//
//
//
//
//
// ==================================================================================================
//                                            OutputObject
// ==================================================================================================
//
//
//
//
//
//

// No OutputObject types with arguments in your schema.

//
//
//
//
//
//
// ==================================================================================================
//                                             Interface
// ==================================================================================================
//
//
//
//
//
//

// No Interface types with arguments in your schema.

//
//
//
//
//
//
// ==================================================================================================
//                                               Union
// ==================================================================================================
//
//
//
//
//
//

// No Union types with arguments in your schema.

//
//
//
//
//
//
// ==================================================================================================
//                                                Root
// ==================================================================================================
//
//
//
//
//
//

export interface Mutation extends $$Utilities.SchemaDrivenDataMap.OutputObject {
  readonly f: {
    readonly addPokemon: {
      readonly a: {
        readonly attack: {
          readonly nt: 'Int'
          readonly it: readonly [0]
          readonly $t: TypeInputsIndex.Int | null | undefined
        }
        readonly defense: {
          readonly nt: 'Int'
          readonly it: readonly [0]
          readonly $t: TypeInputsIndex.Int | null | undefined
        }
        readonly hp: {
          readonly nt: 'Int'
          readonly it: readonly [0]
          readonly $t: TypeInputsIndex.Int | null | undefined
        }
        readonly name: {
          readonly nt: 'String'
          readonly it: readonly [1]
          readonly $t: TypeInputsIndex.String
        }
        readonly type: {
          readonly nt: 'PokemonType'
          readonly it: readonly [1]
          readonly $t: TypeInputsIndex.PokemonType
        }
      }
    }
  }
}

export interface Query extends $$Utilities.SchemaDrivenDataMap.OutputObject {
  readonly f: {
    readonly pokemonByName: {
      readonly a: {
        readonly name: {
          readonly nt: 'String'
          readonly it: readonly [1]
          readonly $t: TypeInputsIndex.String
        }
      }
    }
    readonly pokemons: {
      readonly a: {
        readonly filter: {
          readonly nt: 'PokemonFilter'
          readonly it: readonly [0]
          readonly $t: TypeInputsIndex.PokemonFilter | null | undefined
        }
      }
    }
    readonly trainerByName: {
      readonly a: {
        readonly name: {
          readonly nt: 'String'
          readonly it: readonly [1]
          readonly $t: TypeInputsIndex.String
        }
      }
    }
  }
}

//
//
//
//
//
//
// ==================================================================================================
//                                               Index
// ==================================================================================================
//
//
//
//
//
//

export interface ArgumentsMap {
  operations: {
    query: Query
    mutation: Mutation
  }
  directives: {}
  types: {
    Mutation: Mutation
    Query: Query
    DateFilter: DateFilter
    PokemonFilter: PokemonFilter
    StringFilter: StringFilter
  }
}
